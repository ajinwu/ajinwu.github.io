<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字典和集合</title>
      <link href="/2019/11/12/zi-dian-he-ji-he/"/>
      <url>/2019/11/12/zi-dian-he-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="泛映射类型"><a href="#泛映射类型" class="headerlink" title="泛映射类型"></a>泛映射类型</h1><p>collection.abc 模块中有mapping和mutaleMapping这两个抽象基类, 往往为dict和其他类似的类型定义形式接口</p><p>非抽象映射类型一般不会直接继承抽象基类, 会直接对dict或者collection.userdict进行扩展</p><p>标准库里的所有映射类型都是利用dict来实现的, 因此只有可散列的数据类型才能用作这些键(只有键有要求, 值并无要求)</p><blockquote><p>可散列数据类型在这个对象的生命周期内, 其散列值不会改变, 同时还需要实现<strong>hash</strong>和<strong>eq</strong>方法才可进行比较</p></blockquote><blockquote><p>原子不可变类型(str, 数值, bytes)都是可散列类型, frozenset只能存放可散列类型, 因此他也是可散列类型, 元组中所有的元素都是可散列的, 元组才是可散列的</p></blockquote><h1 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h1><pre><code>{key: value for key, value in count.items}</code></pre><h1 id="键的映射方法"><a href="#键的映射方法" class="headerlink" title="键的映射方法"></a>键的映射方法</h1><p>要使用setdeafult来处理找不到的键r.setdeafult(key,[]), 这一句的意思是<code>if key is not in dict: dict[key] = []</code></p><h1 id="映射的弹性查询方法"><a href="#映射的弹性查询方法" class="headerlink" title="映射的弹性查询方法"></a>映射的弹性查询方法</h1><p>在某个键不存在时, 我们也想通过这个键读取一个默认值, 这样有两个方法, 1是使用defaultdict, 2是自己定义一个dict的子类实现<strong>missing</strong>方法</p><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>在设置默认值时, 要使用一个数据类型的构造方法,如<em>list</em>, 如果查找不到对应的记录, 会使用default_factory方法来设定一个值</p><h2 id="特殊的missing方法"><a href="#特殊的missing方法" class="headerlink" title="特殊的missing方法"></a>特殊的<strong>missing</strong>方法</h2><p>所有映射类型找不到键都会调用这个方法, 但是只对getitem有效, 对get和in没有影响</p><pre class="line-numbers language-python"><code class="language-python">l<span class="token punctuation">.</span>__getitem__<span class="token punctuation">(</span>key<span class="token punctuation">)</span>l<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">,</span>default<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种处理是不一样的, 第一种会报错, 第二中会是默认值或者返回为None</p><p>在找不到键的时候使用<strong>missing</strong>方法, 可以做一些特殊的操作</p><p>如果要使用key in dict方法, 就必须要实现<strong>contains</strong>方法, 因为找不到也会到<strong>missing</strong>里面寻找, 产生无限递归, 而使用in操作时, 会产生一个视图, 这种操作查找元素很快</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">strkey</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 再找不到键的时候会在这里进行字符装换</span>    <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>key<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> KeyError<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">[</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> default <span class="token operator">=</span> None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">[</span>key<span class="token punctuation">]</span>        <span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>            <span class="token keyword">return</span> default    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">or</span> str<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>d <span class="token operator">=</span> strkey<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">"2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"None"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 只对get有效而不对__getitem__无效</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h1><p>有序字典collections.OrderedDict 排序</p><pre class="line-numbers language-python"><code class="language-python">d <span class="token operator">=</span> collections<span class="token punctuation">.</span>OrderedDict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> s<span class="token punctuation">:</span>    <span class="token keyword">if</span> i <span class="token keyword">in</span> d<span class="token punctuation">:</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>d <span class="token operator">=</span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token keyword">lambda</span> d<span class="token punctuation">:</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> reverse <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">## 返回列表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>collections.chainMap()做模板之用, 适合嵌套数据</p><p>UserDict并不是dict的一个子类, 继承于dict更推荐使用UserDict, 前者会在有些实现上走一些捷径, 有些方法必须要重写</p><p>UserDict由一个data属性, 实际上是存储的dict里面的属性</p><p>UserDict 继承的是mutableMapping</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> UserDict<span class="token keyword">class</span> <span class="token class-name">user_dict</span><span class="token punctuation">(</span>UserDict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>key<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> KeyError<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">[</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> str<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>data <span class="token comment" spellcheck="true"># data是一个dict实例</span>    <span class="token keyword">def</span> <span class="token function">__setitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> itemd <span class="token operator">=</span> user_dict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">"2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"None"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h1><p>types模块中由一个封装类名叫做MapingProxyType, 使用此类包装的数据是动态的, 无法做改变, 需要修改原数据才可以改变包装后的数据</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> types <span class="token keyword">import</span> MappingProxyTyped <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token string">"A"</span><span class="token punctuation">}</span>d_proxy <span class="token operator">=</span> MappingProxyType<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"x"</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>d_proxy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"b"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合内的元素必须是可散列的, set本身是不可散列的, 但是frozenset可以散列</p><h2 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h2><p>a = {1}</p><blockquote><p>如果是空集, 必须使用无参构造方法<br>对于a = set([1,2]) 和a = {1, 2}来说, 后者的速度会更快一些</p></blockquote><p>frozenset没有特殊字面量说法, 只能采用构造方法</p><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>&amp; 交集</p><p>| 并集</p><p>- 差集</p><p>^ 对称差集 (A U B) - (A n B)</p><blockquote><p>在集合方法discard是移除元素, 不存在不会报错</p></blockquote><h1 id="dict和set的背后"><a href="#dict和set的背后" class="headerlink" title="dict和set的背后"></a>dict和set的背后</h1><p>dict和set搜索都比list快, 是由于list背后没有散列表来支持in运算, 因此每次都会扫描整个列表</p><h2 id="字典中的散列表"><a href="#字典中的散列表" class="headerlink" title="字典中的散列表"></a>字典中的散列表</h2><p>散列表是一个稀疏数组, 在dict的散列表中, 每个键值对都占有表元, 一个是键的引用, 一个是值得引用, 因为所有的表元的大小一致, 所以可以通过偏移量来读取, python会保证1/3是空的, 超过会自动复制到更大的空间</p><p>在插入新值时, python会按照散列表的拥堵程度来决定是否重新分配内存, 为了减小散列冲突, 散列值位数和索引位数也会增加</p><h2 id="dict的实现和后果"><a href="#dict的实现和后果" class="headerlink" title="dict的实现和后果"></a>dict的实现和后果</h2><p>散列需要满足的要求</p><ol><li>支持hash函数, 并且hash计算不变</li><li>支持<strong>eq</strong>来判等</li><li>若a==b, 则hash(a) == hash(b)</li></ol><p>所有用户自定义的对象都是可散列的, 因为散列值是id()来获取</p><blockquote><p>如果实现了<strong>eq</strong>方法, 并且希望是可散列的, 就必须实现<strong>hash</strong>方法, 并保证相等</p></blockquote><p>字典在内存上的开销巨大</p><p>字典的键查询很快, 空间换时间</p><p>键的次序取决于添加顺序</p><p>往字典添加新键可能会改变已有的顺序, 因为每一次添加新键都有可能使字典扩容, 造成散列冲突, 导致打乱原有的顺序</p><blockquote><p>keys, items, values返回的都是字典视图</p></blockquote><h2 id="set的实现以及后果"><a href="#set的实现以及后果" class="headerlink" title="set的实现以及后果"></a>set的实现以及后果</h2><ol><li>集合元素必须是可散列的</li><li>集合很消耗内存</li><li>in很高效</li><li>元素的次序决定于添加的次序</li><li>添加可能会改变次序</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>dict, defaultdict, userdict, orderedDict, ChainMap, Counter, UserDict</p><p>setdefault</p><p><strong>missing</strong></p><p>MappingProxyType</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列构成的数组</title>
      <link href="/2019/11/12/xu-lie-gou-cheng-de-shu-zu/"/>
      <url>/2019/11/12/xu-lie-gou-cheng-de-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="内置序列类型"><a href="#内置序列类型" class="headerlink" title="内置序列类型"></a>内置序列类型</h1><ol><li><p>python标准库使用c实现了丰富的序列类型</p><ol><li>容器序列:list, tuple, collection.deque这些序列能存放不同类型的数据</li><li>扁平序列:str, bytes, bytesarray, memoryview和array.array, 这种序列只能容纳一种类型<blockquote><p>容器序列存放的是他们所包含的对象的引用, 扁平序列存放的是值, 换句话来说, 扁平序列是一段连续的内存空间</p></blockquote></li><li>可变序列:list, bytesarray, array.array, collections.deque, memoryview</li><li>不可变序列: tuple, str和bytes</li></ol></li><li><p>列表推导和生成器表达式</p><ol><li>列表推导式并不一定比map慢</li><li>在初始化序列类型时, 使用生成器表达式是更好的选择, 生成器表达式遵守了迭代器协议, 可以逐个产生元素, 列表推导式是先建立一个完整的列表, 然后再把这个列表传递到某个构造函数里面, 不够节省内存.</li><li>生成器表达式每次for循环才会生成一个组合, 所以会省掉笛卡尔积的for循环开销</li></ol></li><li><p>元组不仅仅是不可变的列表</p><ol><li>元组和记录: 元组其实是对数据的记录, 元组的每个元素都存放了一个字段的数据, for循环可以自动拆包元组, 迭代过程中, print可以接受一个元组作为参数输入, 拆包让元组当做记录来使用.</li><li>元组拆包可以应用到任何可迭代对象上, 但是可迭代对象的元素必须要跟接受这些元素的元组的空挡数已知</li><li>拆包中对于不定长参数使用*获取, 可以应用与任何位置, 自动对应长度</li><li>python3中函数参数不接受元组型(不接受所有迭代序列, 例如(a, b), [a, b])</li></ol></li><li><p>具名元组</p><ol><li>创建一个具名元组需要两个参数, 一个是类名, 另一个是类的各个字段的名字, 后者可以由数个字符串组成的可迭代对象, 或者是有空格分割开的字段名组成的字符串</li><li>存放在对应字段里的数据要以一串参数的形式传入到构造函数中, 元组的构造函数只接受单一的可迭代对象</li><li>可以通过字段名获取对应位置的字段信息</li><li>具名元组里面可以叠加具名元组, 实现高级数据结构</li><li>具名元组相当于一个类</li><li>重复拼接方法<strong>mul</strong>(n), 生成一个新的对象</li></ol></li><li><p>切片</p><ol><li>切片和区间操作会忽略最后一个元素, 符合以0为开始的风格</li><li>python的内置序列类型都是一维的, 他们只支持单一索引</li><li>如果把切片放在赋值语句的左边, 或者把他作为del操作的对象, 我们就可以对序列进行嫁接, 切除, 或者就地修改等操作</li><li>如果赋值的对象是一个切片, 那么右值必须是一个可迭代序列</li></ol></li><li><p>对序列使用+*</p><ol><li>序列支持+*, 在拼接的过程中, 两个被操作的序列都不回被修改, python会新建一个包含同类型的序列作为拼接的结果</li><li>不要使用[[“_”]] * 3这种语法</li><li>序列增量赋值要实现<strong>iadd</strong>方法, 如果没有实现, 解释器会自动转向<strong>add</strong>方法</li><li>在元组中, 有可变序列时, 需要append而不是直接+=</li></ol></li><li><p>list.sort和内置函数sorted</p><ol><li>list.sort()方法会原地赋值, 返回值为None, 并不会产生新的对象</li><li>sorted可以接受任何可迭代的对象作为参数, 甚至不可变序列或生成器</li><li>reverse和key作为可选关键字, key用于序列中的每一个元素, 作为排序的对比关键字, 比如key=len, 进行基于字符串长度的排序</li></ol></li><li><p>用bisect来管理已排序的序列</p><ol><li>bisect.insort(list, item), 讲一个新的item放入list, 保持有序的同时插入, 函数有返回值, 返回值为在新序列中的位置</li><li>bisect中的方法都有left和right可选, 区别在于放在左边还是右边</li></ol></li><li><p>当列表不是首选时</p><ol><li>数组<ol><li>数组支持所有跟可变序列有关的操作, 还提供从文件读取和存入文件更快的方法, frombytes和tofile方法</li><li>数组只能存放限定类型的数据</li></ol></li><li>内存视图, 看不懂</li><li>双向队列<ol><li>maxlen是可选参数, 固定后不可改变</li><li>对满队列添加元素时会自动删除左端或者右端元素</li><li>deque原子操作, 是线程安全的</li></ol></li></ol></li><li><p>总结</p><ol><li>序列类型分为可变序列和不可变序列, 或者说是扁平序列和容器序列, 扁平序列只能保存原子操作, 容器序列可以保存其他序列, 容器:有些对象包含其他对象的引用.</li><li>对于重复拼接在遇到不可变序列时, 会产生新的序列, 如果遇到可变的会就地修改</li><li>元组存放没有关系的数据</li><li>sorted和list.sort背后的算法是timsort自适应算法, 会根据原始数据的特点交替使用插入排序和归并排序</li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机概论</title>
      <link href="/2019/11/11/ji-suan-ji-gai-lun/"/>
      <url>/2019/11/11/ji-suan-ji-gai-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="数据表示方式"><a href="#数据表示方式" class="headerlink" title="数据表示方式"></a>数据表示方式</h1><h2 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h2><p>在计算机中, 所有的数据都是二进制</p><h2 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h2><p>常用的英文编码都是ascii, 每个符号(英文, 数字, 或符号等)都会占用一个bytes, 总共会有2^8中变化, 目前所使用的Unicode编码系统解决了这个问题</p><h1 id="软件程序运作"><a href="#软件程序运作" class="headerlink" title="软件程序运作"></a>软件程序运作</h1><p>目前计算机都将软件分为两大类, 系统软件和应用程序</p><h2 id="机器程序与编译程序"><a href="#机器程序与编译程序" class="headerlink" title="机器程序与编译程序"></a>机器程序与编译程序</h2><p>cpu具有微指令集, 让cpu帮忙工作必须要参考微指令集, 这个流程包括一下方面</p><ol><li>需要了解机器语言</li><li>需要了解所有硬件的相关功能函数</li><li>程序具有不可移植性, 每个cpu都有独特的微指令集, 同样, 每个硬件都有相关功能函数</li><li>程序具有专一性, 要面对相关硬件来编写</li></ol><p>编译程序做了将高级语言转化为机器语言的功能来完成程序的运行</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统也是一组程序, 这组程序主要来管理计算机以及相关硬件</p><p>操作系统放置在内存中的受保护区域, 开机后一直常驻与内存</p><h2 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h2><p>操作系统除了核心程序之外, 通常会提供开发接口, 就是sc, 开发工程师只需要遵循sc参数开发软件</p><ol><li>操作系统的核心层直接参看硬件规格, 所以同一个操作系统不能再不同硬件平台运作</li><li>操作系统只管理硬件资源, 包括cpu, 内存, 输入输出装置及文件系统文件</li><li>应用程序开发参考操作系统提供开发接口</li></ol><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li>system call interface</li><li>程序管理, 内核控制分配cpu资源   </li><li>内存管理</li><li>文件系统管理</li><li>硬件驱动</li></ol><h2 id="操作系统与驱动程序"><a href="#操作系统与驱动程序" class="headerlink" title="操作系统与驱动程序"></a>操作系统与驱动程序</h2><p>操作系统会提供开发接口给硬件开发商, 根据接口设计驱动程序</p><ol><li>操作系统必须能够驱动硬件, 应用程序才能使用该硬件</li><li>一般来说, 操作系统会提供开发接口</li><li>使用新硬件, 必须安装驱动程序</li><li>驱动程序由开发者提供, 与操作系统开发者无关</li></ol><h1 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h1><p>应用程序是参考操作系统开发接口开发的软件, 达到某些计算机功能</p><p>应用程序与操作系统有关系</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>计算机定义: 接受用户输入指令与数据, 经过中央处理器的算逻单元运算后, 产生或存储有用的信息</li><li>计算机五大单元: 输入输出单元, 控制单元, 算逻单元, 记忆单元, cpu占有控制, 算逻单元, 记忆单元又包含主存储器与辅助内存</li><li>数据搂入流出是cpu发出的控制指令, cpu处理的数据来着主存储器</li><li>cpu设计理念分为: 精简指令集与复杂指令集</li><li>新的cpu设计中已经将北桥的内存控制芯片整合到cpu中, 而cpu与主存储器, 显示适配器沟通的总线是系统总线, 南桥是I/O总线</li><li>cpu每次能够处理的数据量称为字组大小, 目前有32/64位区分</li><li>一个byte=8bits</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机系统/linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统/linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据模型</title>
      <link href="/2019/11/09/python-shu-ju-mo-xing/"/>
      <url>/2019/11/09/python-shu-ju-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="python-风格"><a href="#python-风格" class="headerlink" title="python 风格"></a>python 风格</h1><ol><li><p>特殊风格</p><ol><li><strong>getitem</strong>方法是实现列表进行选取的方法, 并且还支持切片语法, 并且只要实现了这个方法, 这个对象就变成了可迭代的对象, 实现方式, 返回一个本对象的一个结点</li><li>in运算符是contains方法实现的, 如果没有实现这个方法, 那么in运算符就是按顺序进行一次迭代搜索</li></ol></li><li><p>如何使用特殊风格<br><br>特殊方法的存在是为了被解释器调用的, 不需要自己调用, 也就是你需要len(object)而不是object.len(), 如果是py内置的类型, 如list, str等, cpython的<strong>len</strong>会直接返回pyvarobject中的ob_size属性, pyvarobject是表示内存中长度可变的内置对象的C语言结构体. 速度会快很多.<br>很多时候, 特殊方法的调用是隐式的, 例如for i in xx, 背后使用的是iter(xx)函数, 而iter实现是xx.<strong>iter</strong>()方法, 通过内置的函数, 如len, str来使用特殊方法是最好的选择, 这些内置函数会调用特殊方法, 且对于内置类来说, 他们的速度会更快.</p><ol><li><p>模拟数值类型</p><ol><li>如果一个对象可以获取 obj 的字符串表示, 他需要实现<strong>repr</strong>或者<strong>str</strong>方法, + 为<strong>add</strong>方法, * 为<strong>mul</strong>方法</li></ol></li><li><p>字符串表示形式<br></p><ol><li><strong>repr</strong> 用于生成正式的表示。可以认为是将对象序列化的方法，原则上要能反序列化回对象。</li><li><strong>str</strong> 用于生成非正式的表示。format 或 print 会调用它来为用户生成“友好的”显示。<blockquote><p>str 与repr对比, repr 并不强制生成的字符串可以反序列化</p></blockquote></li></ol><blockquote><p>1.repr 生成的字符串一般用于 debug，所以一般生成的字符串一般要包含尽可能多的信息，信息要尽可能明确(如默认实现里用 ID 区分开两个不同的对象)。</p></blockquote><blockquote><p>2.不要使用 repr 和 eval 来做序列化/反序列化，用 pickle 或 json。<br>3.obj.<strong>str</strong>() 方法会在 print(obj) 或 ‘{}’.format(obj) 时被调用，一般是为了给用户提供 “友好的” 显示，所以 <strong>str</strong> 不像<strong>repr</strong> 那样原则上对返回值有约定，想怎么搞都行。</p></blockquote><blockquote><p>4.另外，<strong>str</strong> 的默认实现是直接调用了 <strong>repr</strong> 方法。因此如果覆盖了 <strong>repr</strong> 方法，<strong>str</strong> 的结果也会随之改变。</p></blockquote><blockquote><p>5.如果只想实现其中的一个方法, <strong>repr</strong>是最好的选择, 如果一个对象没有str方法而需要使用时, 会使用repr代替</p><ol start="3"><li>自定义的布尔值</li><li>默认情况下, 我们自定义的类总是被认为是真的, 除非是对<strong>bool</strong> 或者<strong>len</strong>做了实现, 如果不存在<strong>bool</strong>, 则会调用<strong>len</strong>方法</li></ol></blockquote></li><li><p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html" target="_blank" rel="noopener">特殊方法对照表</a></p></li></ol></li></ol><p>本章代码<br><a href="/file/getitem_len.py">getitem_len</a><br><a href="/file/vector.py">vector</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秦九韶算法详解</title>
      <link href="/2019/11/09/qin-jiu-shao-suan-fa-xiang-jie/"/>
      <url>/2019/11/09/qin-jiu-shao-suan-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>#秦九韶算法<br>秦九韶算法是将一元n次多项式的求值问题转化为n个一次式的算法，比普通计算方式提高了一个数量级<br>普通算式</p><pre><code>a*x^i</code></pre><p>因为多次求幂，消耗了大量的计算时间</p><p>我们来分析一下秦九韶算法<br>例如：</p><pre><code>求1+x+2x^2+3x^3当x=2时的值</code></pre><p>首先我们将系数按照从大到小的方式提出来排列<br>如图所示，我们需要将系数这样排列计算<br>除了第一个值以外，其他的处置我们都在循环内取得，首先我们需要得到第一个值（注明，从第二个循环开始即使用sum结果进行乘积）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">*</span> x <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从第一个数开始每次乘了加上下一个值，然后继续使用结果乘以x加下一个值<br>#下面附上源码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> MAX 10  </span><span class="token comment" spellcheck="true">//只建议十项</span><span class="token keyword">int</span> <span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token keyword">double</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> sum<span class="token punctuation">;</span>    sum <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">*</span> x <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> sum<span class="token punctuation">;</span>    <span class="token keyword">double</span> arr<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入项数(注明,项数为最高项的幂+1):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入从小到大的系数，以空格隔开，没有的用0代替:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//必须反向存</span>        <span class="token punctuation">{</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入乘数x:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.9lf"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
