<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>主机规划</title>
      <link href="/2019/12/16/zhu-ji-gui-hua/"/>
      <url>/2019/12/16/zhu-ji-gui-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘链接方式与装置名的关系"><a href="#磁盘链接方式与装置名的关系" class="headerlink" title="磁盘链接方式与装置名的关系"></a>磁盘链接方式与装置名的关系</h1><p>磁盘安装在不同的插槽, 会被自动识别为/dev/sd[a-p]</p><p>在早期的磁盘中, 第一扇区是储存重要信息, MBR格式, 但是大于2T以上的磁盘分区无法让某些操作系统读取, 因此新一种分区格式为GPT</p><h1 id="分区表格式与限制-MBR"><a href="#分区表格式与限制-MBR" class="headerlink" title="分区表格式与限制(MBR)"></a>分区表格式与限制(MBR)</h1><p><del>分区表是将大表的数据分成许多小的子集, 是将分区信息保存在磁盘的第一扇区的64/128字节中, 每个分区占用16个字节, 存有活动状态表示, 文件系统标识, 起止柱面号, 扇区号, 隐含扇区数目(4字节), 分区总扇区数目(4字节)等内容, 这也是MBR分区不能草果4个的原因</del></p><p>MBR(master Boot Record主要开机记录区)来处理开机管理程序与分区表, 通常放在第一扇区(512bytes)</p><ol><li>主要启动记录区:446bytes</li><li>分区表: 记录磁盘分区状态, 64bytes</li></ol><p>如果有四个分区, 则会被识别为sba[1-4]</p><ol><li>分区只是针对64bytes的分区表设定</li><li>磁盘默认分区表仅能写入四组分区信息</li><li>四组分区信息通常称为主分区或扩展分区</li><li>分区槽的最小单位为磁盘柱面</li></ol><p>分区考虑</p><ol><li>数据安全性</li><li>系统效率, 柱面搜索范围</li></ol><p>实际上可以将一个硬盘分区成10个以上的分区槽, 使用扩展分区(利用额外的扇区来记录更多的分区信息)</p><p>实际上扩展分区并不是只占一个区块, 而是会分布在每个分区槽最前面的几个扇区来记在分区信息</p><p>扩展分区的目的是使用额外的分区来记录分区信息, 扩展分区本身不能用来格式化, 我们可以使用扩展分区指向的区块来继续做分区记录, 由扩展分区切出来的分区槽称为逻辑分区</p><ol><li>扩展分区只能有一个</li><li>主分区和扩展分区最多只有四个</li><li>逻辑分区是被扩展分区切割出来的分区槽</li><li>扩展分区无法格式化</li><li>linux中sata硬盘可以突破63个以上的分区限制</li></ol><h1 id="GPT分区表"><a href="#GPT分区表" class="headerlink" title="GPT分区表"></a>GPT分区表</h1><p>在扇区的定义上使用逻辑区块地址(LBA)来处理, 所有区块都以此来规划(预设512bytes), 从0开始</p><ol><li>LBA0(MBR相容区块)<br>与MBR相似的是与之前使用446bytes来储存第一阶段的开机信息, 而在原本的分区表记录区内放入一段特殊标记分区表示GPT格式之意</li><li>GPT分区没有主, 扩展, 逻辑分区的区别</li></ol><h1 id="linux中开机流程的BIOS和uefi开机检测程序"><a href="#linux中开机流程的BIOS和uefi开机检测程序" class="headerlink" title="linux中开机流程的BIOS和uefi开机检测程序"></a>linux中开机流程的BIOS和uefi开机检测程序</h1><p>CMOS是记录各项硬件参数且嵌入到主板上面的存储器, BIOS是写入到硬件的一个软件程序, 是开机执行的第一个程序</p><p>接下来BIOS会寻找能够能够开机的硬盘, 并且到该硬盘去读取第一个扇区的MBR位置, 放有最基本的开机管理程序(如果分区表为GPT, BIOS也能从LBA0的MBR兼容区块读取第一阶段的开机管理程序代码)</p><p>UEFI是由C语言编写, 对于硬件是直接使用驱动程序, 支持多平台, 可编程</p><p>安全启动是uefi加入的, 有些时刻需要关闭才能开机</p><h1 id="恢复linux引导"><a href="#恢复linux引导" class="headerlink" title="恢复linux引导"></a>恢复linux引导</h1><p>找到sysimage,让后<code>chroot /mnt/sysimage  grub2-install /dev/sd?</code></p><h1 id="开启X-Window"><a href="#开启X-Window" class="headerlink" title="开启X-Window"></a>开启X-Window</h1><p><code>startx</code></p><h1 id="系统语言设置"><a href="#系统语言设置" class="headerlink" title="系统语言设置"></a>系统语言设置</h1><pre class="line-numbers language-bash"><code class="language-bash">LANG<span class="token operator">=</span>en_US.utf8<span class="token function">export</span> LC_ALL<span class="token operator">=</span>en_US.utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="分区规划-去参考arch-wiki"><a href="#分区规划-去参考arch-wiki" class="headerlink" title="分区规划(去参考arch wiki)"></a>分区规划(去参考arch wiki)</h1><p>/boot 2GB</p><p>/</p><p>/home</p><p>swap 2G</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机系统/linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统/linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker网络配置</title>
      <link href="/2019/12/10/docker-wang-luo-pei-zhi/"/>
      <url>/2019/12/10/docker-wang-luo-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h1><p>docker网络有六种设备, 对于不同的情景使用最优的设备是最好的选择</p><ol><li>bridge: 桥接网络, 是容器的默认网络, 桥接网络是经常使用在独立容器应用中, 用来通信的网络</li><li>host: 对于独立的容器, 去掉容器和主机之间的网络隔离, 使用主机网络转发, host网络仅可以使用在高于17.06的swarm服务中</li><li>overlay: overlay网络连接不同的docker daemon守护进程, 并且开启swarm服务在每一个docker daemon中通信, 能够使用overlay网络在不同的swarm服务和不同或者相同独立的容器中进行通信, 这个技术消除了操作系统级别的网络需求</li><li>macvlan: 虚拟地址网络允许给容器设置mac地址, 使其作为网络上的物理设备来使用, docker daemon将根据容器的mac地址将流量路由转发到容器</li><li>none: 对于这个容器, 禁用网络, 通常与自定义网络一起使用</li><li>网络插件: 查看dockerhub或者第三方提供商</li></ol><h1 id="网络选择"><a href="#网络选择" class="headerlink" title="网络选择"></a>网络选择</h1><ol><li>桥接网络在同一个主机上的不同容器间进行通信中使用</li><li>主机网路在需要不适用docker网络, 但是需要使用容器时使用(直接使用内网或者公网使用)</li><li>overlay网路在不同的docker主机中进行通信, 或者不同网络应用网络均使用swarm服务</li><li>macvlan网络在迁移容器到其他物理主机使用,使用唯一的mac地址</li><li>第三方网络</li></ol><h1 id="docker-EE-features"><a href="#docker-EE-features" class="headerlink" title="docker EE features"></a>docker EE features</h1><ol><li>相同网络上使用不同的服务, 根据客户机的需求, UCP路由转发到合适的服务上</li><li>对于需要有状态会话的应用程序，会话粘性允许您在HTTP标头中指定UCP用于将后续请求路由到相同服务任务的信息。(机翻)</li></ol><h1 id="使用桥接网络"><a href="#使用桥接网络" class="headerlink" title="使用桥接网络"></a>使用桥接网络</h1><p>桥接网络是链路层设备, 在不同的网络段中转发流量, docker允许连接同一个桥接网络的容器进行通信, 同时隔离没有与桥接网络连接的容器</p><h1 id="用户自定义网桥和默认网桥的区别"><a href="#用户自定义网桥和默认网桥的区别" class="headerlink" title="用户自定义网桥和默认网桥的区别"></a>用户自定义网桥和默认网桥的区别</h1><ol><li>用户自定义的网路在不同的容器间提供了更好的隔离性与互操作性</li></ol><p>容器连接一个桥接网络自动暴露所有的端口对于连接同一个桥接网络, 所有的端口都不暴露出去, 这样使得容器很容易进行通信</p><ol start="2"><li>用户自定义网桥提供了在不同容器间自动dns解析</li></ol><p>容器使用的默认桥接网络只能使用ip地址访问, 除非使用<code>--link</code> 选项, 在用户自定义网络中, 容器可使用别名进行互相解析, 对于很多的容器会增加复杂性, 或者使用hosts也会带来不可以预估的错误</p><ol start="3"><li>可以动态在用户自定义网段中删除或者添加容器</li><li>每一个自定义网段都可以创建配置</li></ol><p>对于使用默认网桥来说, 所有的容器使用一套配置, 重新配置后需要重启docker, 但是用自定义网桥, 可以创建不同的网络配置来满足需求</p><ol start="5"><li>连接默认容器来共享环境变量</li></ol><p>起初只有使用了<code>--like</code>连接了不同容器才能共享环境变量, 但是还有其他方案</p><ol><li>不同容器挂载同一个文件或者目录</li><li>使用docker-compose</li><li>swarm</li></ol><h1 id="管理用户自定义网络"><a href="#管理用户自定义网络" class="headerlink" title="管理用户自定义网络"></a>管理用户自定义网络</h1><p>docker create network –help</p><h2 id="正在运行中的容器进行网络切换"><a href="#正在运行中的容器进行网络切换" class="headerlink" title="正在运行中的容器进行网络切换"></a>正在运行中的容器进行网络切换</h2><pre class="line-numbers language-docker"><code class="language-docker">docker network connect mybr0 my<span class="token punctuation">-</span>nginxdocker network disconnect my<span class="token punctuation">-</span>net my<span class="token punctuation">-</span>nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="ipv6支持"><a href="#ipv6支持" class="headerlink" title="ipv6支持"></a>ipv6支持</h2><p>需要手动开启,创建是加上<code>--ipv6</code>来开启, 但是不能选择在支持ipv6的网桥上禁用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker构建一次性镜像以及缓存问题</title>
      <link href="/2019/12/10/docker-gou-jian-yi-ci-xing-jing-xiang-yi-ji-huan-cun-wen-ti/"/>
      <url>/2019/12/10/docker-gou-jian-yi-ci-xing-jing-xiang-yi-ji-huan-cun-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="通过管道传递dockerfile"><a href="#通过管道传递dockerfile" class="headerlink" title="通过管道传递dockerfile"></a>通过管道传递dockerfile</h1><p>管道中的dockerfile通过stdin可以执行一次性构建在无需在磁盘上构建</p><pre class="line-numbers language-docker"><code class="language-docker">echo <span class="token punctuation">-</span>e <span class="token string">'FROM busybox\nRUN echo "hello world"'</span> <span class="token punctuation">|</span> docker build <span class="token punctuation">-</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-docker"><code class="language-docker">docker build <span class="token punctuation">-</span>&lt;&lt;EOF<span class="token keyword">FROM</span> busybox<span class="token keyword">RUN</span> echo <span class="token string">"hello world"</span>EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="来自stdin构建的的镜像无需发送上下文-其中的连字符用来占据PATH位置-但是如果需要复制文件-这样就会无法找到path"><a href="#来自stdin构建的的镜像无需发送上下文-其中的连字符用来占据PATH位置-但是如果需要复制文件-这样就会无法找到path" class="headerlink" title="来自stdin构建的的镜像无需发送上下文, 其中的连字符用来占据PATH位置, 但是如果需要复制文件, 这样就会无法找到path"></a>来自stdin构建的的镜像无需发送上下文, 其中的连字符用来占据PATH位置, 但是如果需要复制文件, 这样就会无法找到path</h2><h2 id="如果需要复制文件应当使用-f-参数"><a href="#如果需要复制文件应当使用-f-参数" class="headerlink" title="如果需要复制文件应当使用-f-参数"></a>如果需要复制文件应当使用<code>-f-</code>参数</h2><pre class="line-numbers language-docker"><code class="language-docker">docker build <span class="token punctuation">-</span>t myimage<span class="token punctuation">:</span>latest <span class="token punctuation">-</span>f<span class="token punctuation">-</span> . &lt;&lt;EOF<span class="token keyword">FROM</span> busybox<span class="token keyword">COPY</span> somefile.txt .<span class="token keyword">RUN</span> cat /somefile.txtEOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不使用本地文件, 他可以从github拉取文件</p><h1 id="利用缓存构建镜像"><a href="#利用缓存构建镜像" class="headerlink" title="利用缓存构建镜像"></a>利用缓存构建镜像</h1><p>在构建镜像时, docker将顺序执行指令, 在检查每一条指令时, docker会在缓存中查找可重用的镜像, 这符合docker的分层理念.</p><p>如果不想使用缓存时, 可以在构建时加上<code>--no-cache=true</code>来强制构建新镜像, docker匹配遵守下列规则</p><ol><li>从已缓存的父镜像开始, 将下一条指令从基本镜像进行比较, 查看是否是完全相同的命令产生的指令构建</li><li>对于ADD和COPY指令, 将检查镜像中的内容, 并检查文件计算校验和, 不考虑最后修改时间和最后访问时间, 如果文件内容发生了更改, 缓存失效</li><li>除了ADD和COPY以外, 缓存不会检查容器中的更新的文件以确定是否存在缓存, 仅使用命令字符串本身来查找匹配内容</li></ol><p>一旦缓存失效, 所有后续命令都会生成新镜像, 并且不适用缓存</p><h1 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h1><p>安装工具必须首先更新缓存, 安装完成后建议删除缓存rm -rf /var/lib/apt/lists/*</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本与字符序列</title>
      <link href="/2019/12/02/wen-ben-yu-zi-fu-xu-lie/"/>
      <url>/2019/12/02/wen-ben-yu-zi-fu-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="字符问题"><a href="#字符问题" class="headerlink" title="字符问题"></a>字符问题</h1><p>对于字节序列, 可以理解为机器转储, Unicode字符是人类可读的文本</p><p>python3的str类型基本相当于python2的Unicode类型</p><h1 id="字节概要"><a href="#字节概要" class="headerlink" title="字节概要"></a>字节概要</h1><p>python3内置两种基本的二进制序列类型: python3引入的不可变bytes类型和python2.6添加的可变bytearray类型(python2.6的bytes类型是str的别名, 与python3不同)</p><p>bytes及bytesarray对象切片后还是bytes或者bytesarray对象</p><p>bytes也拥有str对象(除了几个)的方法</p><p>解决单个有符号整数<code>int.from_bytes(b'\xfe\xff', 'little', signed=True)</code></p><h1 id="结构体和内存视图"><a href="#结构体和内存视图" class="headerlink" title="结构体和内存视图"></a>结构体和内存视图</h1><p>bytes的解码方式</p><pre class="line-numbers language-python"><code class="language-python">struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">"&lt;hhhhh"</span><span class="token punctuation">,</span>bytes<span class="token punctuation">(</span>b<span class="token string">"\xfe\xff\xff\xff\x00\x00\x01\x00\x02\x00"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他format地址<a href="https://docs.python.org/zh-cn/3/library/struct.html#byte-order-size-and-alignment" target="_blank" rel="noopener">struct</a></p><h1 id="基本的编解码器"><a href="#基本的编解码器" class="headerlink" title="基本的编解码器"></a>基本的编解码器</h1><ol><li>Latin1(即iso8859_1)一种重要的编码, 是其他编码的基础, 例如cp1512和Unicode</li><li>cp1512是微软的latin1超集</li><li>cp437是最初的IBM最初的字符集, 与Latin1不兼容</li><li>gb2312用于编码简体中文的陈旧标准</li><li>utf-8是常见的8位编码, 与ascii兼容</li><li>字节使用decode解码</li><li>字符使用encode编码</li></ol><h1 id="了解编解码问题"><a href="#了解编解码问题" class="headerlink" title="了解编解码问题"></a>了解编解码问题</h1><ol><li>对字符编码时, 可以采用errors=”ignore”或者”replace”来忽略或者替换错误</li><li>cp1252可以解码拉丁文, 他是Latin1的有效超集</li><li>一个检查字符头的哭chardet, 使用chardetect filiname来判断或者在code里面<code>chardet.detect(f.read())</code></li><li>字节序标记即BOM头</li><li>需要在多台设备或者不同平台下运行代码必须要指明编码格式</li><li>除非是进行编码判断, 尽量不要使用二进制打开文本文件</li></ol><h1 id="规范Unicode字符串"><a href="#规范Unicode字符串" class="headerlink" title="规范Unicode字符串"></a>规范Unicode字符串</h1><p>使用unicodedata.normalize函数进行规范化中, NFC, NFD, NFKC, NFKD都可以使用</p><ol><li>NFC使用最少的码位构成等价的字符串, 而NFD是把组合字符分解成基字符和单独的组合字符</li><li>NFKC或者NFKD规范时会导致数据损失</li><li>在大小写折叠中casefold与lower是相同的, 但是<code>μ</code>和<code>β</code>是不同的</li><li>使用nfc对比时是最好的规范化形式, 规范中不区分大小写是应该使用cafeflod</li><li>极端规范化可以将变音符号去掉</li></ol><h1 id="Unicode文本排序"><a href="#Unicode文本排序" class="headerlink" title="Unicode文本排序"></a>Unicode文本排序</h1><ol><li>非ascii文本排序使用的是locale.strxfrm作为key, 但是要这样做必须要设置区域, 不建议这样使用</li><li>使用pyuca可以直接进行排序</li></ol><h1 id="本章代码"><a href="#本章代码" class="headerlink" title="本章代码"></a>本章代码</h1><pre class="line-numbers language-python"><code class="language-python">s <span class="token operator">=</span> <span class="token string">"Café"</span> <span class="token comment" spellcheck="true"># 是四个Unicode字符</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 转换为字节(bytes)对象</span>b <span class="token operator">=</span> s<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 转换为str对象</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span>cafe <span class="token operator">=</span> bytes<span class="token punctuation">(</span><span class="token string">"café"</span><span class="token punctuation">,</span> encoding <span class="token operator">=</span> <span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cafe<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cafe<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 是range(256)以内的整数</span><span class="token comment" spellcheck="true"># print(cafe[-1]) # 还是bytes类型</span><span class="token keyword">print</span><span class="token punctuation">(</span>cafe<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>cafe_arr <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>cafe<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cafe_arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cafe_arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cafe_arr<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">import</span> arraynum <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 有符号整数</span><span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>bytes<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> chardetcity <span class="token operator">=</span> <span class="token string">"São Paulo"</span><span class="token keyword">print</span><span class="token punctuation">(</span>city<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>city<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-16"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>city<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"iso8859_1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>city<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"cp437"</span><span class="token punctuation">,</span> errors <span class="token operator">=</span> <span class="token string">"ignore"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>city<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"cp437"</span><span class="token punctuation">,</span> errors <span class="token operator">=</span> <span class="token string">"replace"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>octes <span class="token operator">=</span> b<span class="token string">"Montr\xe9al"</span><span class="token keyword">print</span><span class="token punctuation">(</span>octes<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"cp1252"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>octes<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"iso8859_7"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>octes<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"koi8_r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"/home/ajin_w/github/record-for-ajin_w/流畅的python/文本和字节序列/编码.py"</span><span class="token punctuation">,</span><span class="token string">"rb"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>chardet<span class="token punctuation">.</span>detect<span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>chardet<span class="token punctuation">.</span>detect<span class="token punctuation">(</span>b<span class="token string">"Montr\xe9al"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> unicodedata <span class="token keyword">import</span> normalizes2 <span class="token operator">=</span> <span class="token string">"cafe\u0301"</span>s1 <span class="token operator">=</span> <span class="token string">"café"</span><span class="token keyword">print</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>normalize<span class="token punctuation">(</span><span class="token string">"NFC"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>normalize<span class="token punctuation">(</span><span class="token string">"NFC"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>normalize<span class="token punctuation">(</span><span class="token string">"NFD"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>normalize<span class="token punctuation">(</span><span class="token string">"NFD"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>normalize<span class="token punctuation">(</span><span class="token string">"NFD"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> len<span class="token punctuation">(</span>normalize<span class="token punctuation">(</span><span class="token string">"NFD"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>micro <span class="token operator">=</span> <span class="token string">"μ"</span><span class="token keyword">from</span> unicodedata <span class="token keyword">import</span> name<span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">(</span>micro<span class="token punctuation">)</span><span class="token punctuation">)</span>micro_cf <span class="token operator">=</span> micro<span class="token punctuation">.</span>casefold<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">(</span>micro_cf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>micro <span class="token operator">==</span> micro_cf<span class="token punctuation">)</span><span class="token keyword">import</span> unicodedata<span class="token keyword">def</span> <span class="token function">shave_marks</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">:</span>    norm_txt <span class="token operator">=</span> normalize<span class="token punctuation">(</span><span class="token string">"NFD"</span><span class="token punctuation">,</span> txt<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 分解基字符和组合记号</span>    shaved <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>c <span class="token keyword">for</span> c <span class="token keyword">in</span> norm_txt <span class="token keyword">if</span> <span class="token operator">not</span> unicodedata<span class="token punctuation">.</span>combining<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 去掉组合记号</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>shaved<span class="token punctuation">)</span>    <span class="token keyword">return</span> normalize<span class="token punctuation">(</span><span class="token string">"NFC"</span><span class="token punctuation">,</span> shaved<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 重新规范化</span><span class="token keyword">print</span><span class="token punctuation">(</span>shave_marks<span class="token punctuation">(</span><span class="token string">"café"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">import</span> localel <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"éac"</span><span class="token punctuation">,</span><span class="token string">"eac"</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>l<span class="token punctuation">,</span> key <span class="token operator">=</span> locale<span class="token punctuation">.</span>strxfrm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">import</span> pyucacoll <span class="token operator">=</span> pyuca<span class="token punctuation">.</span>Collator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>l<span class="token punctuation">,</span> key<span class="token operator">=</span>coll<span class="token punctuation">.</span>sort_key<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文本与字符序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络复习概要</title>
      <link href="/2019/11/28/ji-suan-ji-wang-luo-fu-xi-gai-yao/"/>
      <url>/2019/11/28/ji-suan-ji-wang-luo-fu-xi-gai-yao/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>互联网的核心部分起特殊作用的是路由器. 路由器实现分组交换的关键构件, 其任务是转发收到的分组</p><ol><li><p>电路交换的三个步骤:</p><ol><li>建立连接</li><li>通话</li><li>释放连接;在通话的全部时间内, 通话的两个用户始终占用全部端到端的通信资源</li></ol></li><li><p>分组交换技术的主要特点:</p><ol><li>采用存储转发技术, 我们要发送的整块数据称为一个报文, 发送报文时将报文划分成登场数据段, 加上必要的首部就成了一个分组/包</li><li>位于网络边缘的主机和位于网络核心部分的路由器都是计算机, 主机为用户进行信息处理, 路由器用来转发分组</li><li>路由器收到分组, 暂时存储, 检查其首部, 查找转发表, 检查首部目的地址, 从合适的接口转发出去, 将分组交给下一个路由器</li></ol></li><li><p>分组交换的主要有点</p><ol><li>高效, 在分组传输中动态分配传输贷款, 对通信链路逐段占用</li><li>灵活, 为每一个分组独立的选择最合适的转发路由</li><li>迅速, 以分组为单位, 可以不先建立连接就能向其他主机发送分组</li><li>可靠, 保证可靠性的网络协议, 分布式多路由的分组交换网</li></ol></li><li><p>几种不同的计算机网络</p><p> 作用范围:</p><ol><li><p>广域网(WAN)</p></li><li><p>城域网(MAN), 覆盖范围5-50km, 采用以太网技术</p></li><li><p>局域网(LAN), 范围1km</p></li><li><p>个人区域网(PAN)和无线个人区域网(WPAN)</p><p>按照使用中分类</p></li><li><p>公用网</p></li><li><p>专用网</p></li></ol></li><li><p>计算机网络的性能</p><p> 计算机网络的性能指标</p><ol><li><p>速率: 指数据的传送速率, 也称为数据率或比特率</p></li><li><p>带宽: 在频域中是信号具有的频带宽度, 在时域中网络通道内传送数据的能力</p></li><li><p>吞吐量: 单位时间内通过某个网络的实际数据量</p></li><li><p>时延是指数据(一个报文或者分组)从网络(链路)的一端传送带另一端所需的时间</p><ol><li><p>发送时延: 是主机或路由器发送数据帧所需要的时间, 也叫传输时延, 发送时延=(数据帧长度)/(发送速率)</p></li><li><p>传播时延: 是电磁波在信道中传播一定的距离需要花费的时间, 传播时延=信道长度/电磁波在信道上的传播速率</p><p>电磁波在自由空间的传播速率是光速3<em>10^5Km/s, 在铜线电缆中的传播速率为2.3</em>10^5Km/s, 在光纤中的传播速率为2*10^5Km/s</p><p>发送时延是只在网络适配器内部转发分组的时延, 传播时延在链路中的发送时延</p></li><li><p>处理时延: 是主机或者路由器收到分组是花费一定的时间进行处理(分析首部等)</p></li><li><p>排队时延: 是分组经过网络传输是经过路由器后要先在输入队列中排队等待处理的时延</p></li><li><p>时延带宽积: 是传播时延和带宽相乘, 时延带宽积是指链路的容纳量</p></li><li><p>往返时间RTT, 发送时间=数据长度/发送速率, 有效数据率=数据长度/(发送时间+RTT)</p></li><li><p>利用率有信道利用率和网络利用率, 网络当前时延=网络空闲时的时延/(1 - 利用率)</p></li></ol></li></ol></li><li><p>计算机网络</p><ol><li><p>协议与划分层次</p><p>  网络协议是为进行网络中的数据交换而建立规则,标准或约定</p><ol><li>语法, 即数据与控制信息的结构或格式</li><li>语义, 即需要发出何种控制信息, 完成何种动作以及做出何种响应</li><li>同步, 即事件实现顺序的详细说明</li></ol></li><li><p>网络层次</p><ol><li><p>各层是独立的. 不需要知道他的下一层是如何实现的, 只需要通过层间的接口提供服务</p></li><li><p>灵活性好, 当某一层发生变化时, 只要层间接口关系不便, 各层均不受影响</p></li><li><p>结构上可分割开, 各层采用最适合的技术来实现</p></li><li><p>易于实现和维护, 能够实现和调试一个庞大而又复杂的系统变得易于处理</p></li><li><p>能促进标准化工作</p><p>通常各层需要完成的功能</p><ol><li>差错控制</li><li>流量控制</li><li>分段和重装</li><li>复用和分用</li><li>连接建立和释放</li></ol></li></ol></li><li><p>具有五层协议的体系结构</p><p>  OSI参考模型具有七层体系结构, 物理层, 数据链路层, 数据链路层, 网路层, 传输层, 会话层, 表示层, 应用层<a href="https://zh.wikipedia.org/zh-hans/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI参考模型</a></p><p>  TCP/IP参考模型, 链路层, 网络层, 传输层, 应用层</p><p>  五层参考模型</p><ol><li><p>应用层, 通过应用进程间的交互来完成特定网络应用, 交互数据单元称为报文</p></li><li><p>运输层, 负责向两台主机中的进程之间的通信提供数据传输服务, 并不指定某个特定层网络应用, 多种应用都可以使用同一个运输层服务, 因此有复用和分用的功能, 复用是指多个应用同时使用运输层服务, 分用是运输层收到的信息分别交付到应用层中的相应进程</p><ol><li>transmission Control protocol协议—-提供面向连接的, 可靠的数据传输服务, 数据传输单位是报文段</li><li>User Datagram protocol协议—-提供无连接的,尽力的数据传输服务, 数据传输单位是用户数据报</li></ol></li><li><p>网络层, 为分组交换网上的不同主机提供通信服务, 将运输层产生的报文段或用户数据报封装成分组或包进行传送, 分组也称IP数据报, 另一个任务是将源主机运输层传下来的分组通过网络中的路由器找到目的主机</p></li><li><p>数据链路层, 数据链路层将网络层交下来的网络IP数据报组装成帧, 在相邻结点链路上传送帧, 每一帧包括数据和必要的控制信息(如同步信息等)</p></li><li><p>物理层, 光纤等</p><p>人们经常提到的TCP/IP并不一定是指这两个具体协议, 往往是整个TCP/IP协议族</p></li></ol></li><li><p>实体, 协议, 服务和服务访问点</p><p>  协议是控制两个对等实体(或多个)进行通信的规则的集合</p><p>  在协议的控制下, 两个对等实体间的通信是的本层能够向上一层提供服务, 要实现本层协议还需要实现下面一层所提供的服务</p><p>  协议是水平的, 服务是垂直的, 上层使用下层提供的服务必须通过与下一层交换命令(服务原语)</p><p>  TCP/IP协议可以为各式各样的应用提供服务, 同时TCP/IP协议也允许IP协议在各式各样的网络构成的互联网上运行</p></li></ol></li></ol><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>物理层在计算机内部多采用并行传输方式, 但数据在通信线路上采用串行传输</p><p>一个数据通信系统可以划分为源系统, 传输系统, 目的系统</p><ol><li>源系统<ol><li>源点, 信号源</li><li>发送器, 通常源点生成的数字比特流要通过发送器编码后才能在传输系统进行传输, 典型的发送器是调制器, 很多计算机使用内置的调制解调器</li><li>接收器, 解调器</li><li>终点, 屏幕等</li></ol></li><li>信号<ol><li>模拟信号, 或连续信号, 调制解调器到电话局之间的用户线</li><li>数字信号, 或离散信号, 计算机到调制解调器</li></ol></li></ol><h2 id="信道基本概念"><a href="#信道基本概念" class="headerlink" title="信道基本概念"></a>信道基本概念</h2><ol><li>单向通信, 单工通信</li><li>双向交替通信, 半双工通信</li><li>双向同时通信, 全双工通信</li></ol><blockquote><p>来自信源的信号称为基带信号, 计算机输出的代表各种文字或图像文件的数据信号都属于基带信号, 基带信号中往往包含较多的低频成分, 甚至有直流成分, 因此需要对基带信号进行调制解调</p></blockquote><blockquote><p>调制可分为两类, 一种是仅对基带信号的波形进行变换, 使他能与信道特性相适应, 变换后的信号还是基带信号, 这类调制称为<code>基带调制</code>, 另一类调制需要使用载波进行调制, 把基带信号的频率范围搬移到较高的频段, bin转换为模拟信号, 进过载波的信号称为<code>带通信号调制</code></p></blockquote><ol><li><p>常用编码方式</p><ol><li>不归零值, 正电平为1, 负电平为0</li><li>归零制, 正脉冲为代表1, 负脉冲为0</li><li>曼彻斯特编码, 周期内向上跳的代表0, 向下跳代表1</li><li>差分曼彻斯特编码, 在每一位中心处始终有跳变, 位开始边界有跳变代表0，而位开始边界没有跳变代表1。</li></ol></li><li><p>基本的带通调制方法</p><ol><li>调幅(AM) 载波的振幅随基带数字信号而变化</li><li>调频(FM) 载波的频率随基带数字信号而变化</li><li>调相(PM) 载波的初始相位随基带数字信号而变化</li></ol></li><li><p>信噪比 = 10 log 10(s/n)</p></li></ol><p>香农公式: 信道的极限信息传输速率是 C = W log2(1 + s/N)(bit/s), w是信道的带宽(以hz为单位), S为信道内所传信号的平均功率, N为信道内部的高斯噪声功率</p><p>信道的带宽或信道中的信噪比越大, 信息的极限传输速率就越高, 用编码的方法让每一个码元携带更多比特的信息量</p><h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><ol><li>导引型媒体<ol><li>双绞线</li><li>同轴电缆</li><li>光缆, 传输损耗小, 中继距离长, 抗干扰强, 保密性好, 体积轻</li></ol></li></ol><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ol><li>频分复用, 时分复用和统计时分复用<ol><li>频分复用是所有用户在同样的时间占用不同的带宽(频率带宽)资源</li><li>时分复用的所有用户在不同的时间占用相同的频带宽度, 时分复用则有利于数字信号的传输</li></ol></li><li>波分复用是光的频分复用</li><li>码分复用: 每一个用户可以在同样的时间使用同样的频带进行通信, 由于各用户使用不同码型, 因此各用户之间不会造成干扰, 其频谱类似与白噪声, 不易被发现</li></ol><h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><ol><li>ADSL技术, 非对称数字用户线, 是用数字技术对现有的模拟电话用户线进行改造, 是他能承载宽带数字业务</li><li>光纤同轴混合网(HFC网)</li><li>FTTx技术, 光纤到户技术</li></ol><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>数据链路层属于计算机网络的低层</p><ol><li>点对点通道, 这种通道使用一对一的点对点通信方式</li><li>广播信道, 这种信道使用一对多的广播通信方式</li></ol><h2 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h2><ol><li>数据链路和帧<ol><li>链路就是一个结点到相邻结点的一段物理线路(有线或无线)</li><li>数据链路是另一个概念, 在一条线路上传送数据时, 除了一条必须的物理链路外, 还需要包括必要的通信协议来控制这些数据的传输才构成了数据链路, 现在最常用的方法是使用网络适配器来实现这些协议, 一般的适配器都包括了数据链路层和物理层这两层功能</li></ol></li><li>帧<ol><li>数据链路层将网络层交下来的数据构成帧发送到链路上, 以及把收到的帧中的数据取出在上交到网络层, 网络层协议数据单元是IP数据报</li></ol></li><li>三个基本问题<ol><li>封装成帧是在一段数据的前后加上首部和尾部, 首部和尾部的一个重要作用是帧定界, 为了提高数据传输速率, 帧的数据部分长度应尽可能的大于首部和尾部的长度, 每一种链路层协议所能传送的帧的数据部分长度上线为最大传送单元MTU</li><li>透明传输, 由于帧的开始就结束的标记使用专门的控制字符, 因此所传输任何8比特组合总一定不允许和用作帧定界的控制字符比特编码相同, 在数据链路层透明传输表示无论什么样的比特组合的数据都能够原样无差错的通过数据链路层, 因此, 对于所传送的数据来说, 这些数据就看不见数据链路层有什么妨碍数据传输的东西(转义字符)</li><li>差错检测, 传输错误的比特总数站所传输比特总数的比率称为误码率, 信噪比越高误码率越小(循环冗余校验)<ol><li>循环冗余检验, 帧检验序列FCS是帧检验序列, 一般使用冗余检验法是模二运算, 异或运算, 发送的FCS是M + FCS(余数)</li><li>如果帧无差错, 将每一帧都除以除数, 余数为0</li><li>凡是被接收端数据链路层接受的帧均无差错</li><li>数据链路层没有提供可靠传输服务</li><li>在CRC上加上了帧编号, 确认和重传机制, 对于质量较好的有线传输线路, 不适用确认和重传机制</li></ol></li></ol></li></ol><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><p>PPP协议满足的需求</p><ol><li>简单, 只进行封装校验</li><li>封装成帧</li><li>透明性</li><li>多种网络协议</li><li>多种类型链路</li><li>差错检测</li><li>检测连接状态</li><li>最大传送单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ol><p>只支持点对点链路通信, 只支持全双工链路</p><p>协议的组成</p><ol><li>将IP数据报封装到串行链路的方法, PPP既支持异步链路(无奇偶校验的8比特数据), 也支持面向比特的同步链路</li><li>一个用来建立配置和测试数据链路连接的链路控制协议LCP</li><li>一套网络控制协议NCP, 其中每一个协议支持不同的网络层协议</li></ol><p>PPP协议帧格式<br><img src="https://img-blog.csdn.net/20160204105742700" alt="PPP协议帧格式"></p><ol><li>首部的第一个字段和尾部第二字段都是标志字段, 字段A和C没有携带帧信息,第四个字段是协议字段, 当协议字段是0x0021时, ppp帧信息字段是IP数据报, 若为0xC021是ppp链路协议的LCP数据, 0x8021是控制数据</li><li>字节填充<ol><li>将信息字段中的每一个0x7E 字节转变为2字节序列(0x7D, 0x5E)</li><li>若信息中出现了一个0x7D字节, 转变为(0x7D,0x5D)</li><li>若信息字段中出现小于0x20字符, 则在字符前加入一个0x7D字节, 同时改变编码</li></ol></li><li>零比特填充, 在使用SONET/SDH链路使用同步传输时, 只要发现连续5个一,则立即加入一个0</li></ol><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><ol><li><p>局域网的数据链路层</p><p>网络为一个单位所有, 且地理范围和站点数目均有限</p><ol><li>具有广播功能</li><li>便于系统的扩展和逐渐演变, 各设备的位置可灵活调整和改变</li><li>提高了系统的可靠性, 可用性, 生存性</li></ol></li></ol><p>分类,星形网, 总线网, 环形网, 总线网中以太网最为出名</p><ol start="2"><li><p>以太网标准<br>数据链路层被拆分为两层, 逻辑链路控制层LLC, 媒体接入控制MAC</p></li><li><p>适配器作用: 进行数据串行传输和并行传输的转换</p></li><li><p>CSMA/CD, 载波监听多点接入/碰撞检测</p><ol><li>采用无连接的方式, 尽最大努力交付, 重传也当做新的数据帧</li><li>曼彻斯特编码</li><li>载波监听是检测信道, 每个站都必须不停检测信道</li><li>碰撞检测也就是边发边听</li><li>一个站不可能同时进行发送和接收</li><li>争用期是值以太网在发送数据帧后至多经过两个时间, 又称碰撞窗口, 经过争用期还没有检测到碰撞才能肯定这次发送没有发生碰撞</li><li>以太网使用截断二进制指数退避算法, 发生碰撞后不是等待信道空闲后立即重发, 而是推迟一个最忌时间, 若连续多次发生冲突, 使用此算法可以使重传需要推迟的平均时间随重传次数二增大(动态退避)</li></ol></li><li><p>使用集线器的星形拓扑</p><ol><li>使用集线器的以太网逻辑上仍是总线网, 使用的还是CSMA/CD协议</li><li>一个集线器有许多接口</li><li>集线器工作在物理层, 每个接口仅简单转发比特不进行检测</li></ol></li><li><p>以太网的MAC层</p></li><li><p>硬件地址又称MAC地址, 固化在适配器ROM中的地址</p></li></ol><p>mac帧由五个字段组成, 前两段分别为6字节长的目的地址和原地址地址, 第三个字段是类型字段</p><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><p>最初是网桥, 对收到的帧进行转发和过滤, 交换式集线器称为以太网交换机</p><ol><li>实质是多接口网桥, 每个接口都直接与单台主机或另一个以太网交换机相连, 还具有并行性, 链接多个主机同时通信</li><li>相互通信的主机都是独占传输媒体, 无碰撞的传输数据</li></ol><h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>100BASE-T 以太网, 使用IEEE802.3CSMA/CD协议, IEE802.3u<br>吉比特以太网IEE802.3z<br>10吉比特以太网和更快地以太网IEE802.3an</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>##　网络层提供的两种服务<br>网络层向上只提供简单灵活的，无连接的尽最大努力交付的数据报服务</p><p>虚电路服务和数据报服务的对比<br>对比的方面 | 虚电路服务 | 数据报服务<br>— | — | —-<br>思路|可靠通信应当由网络来保证|可靠通信应该由用户主机来保证<br>连接的建立 | 必须有 | 不需要<br>终点的地址 | 仅在连接建立阶段使用, 每个分组使用短的虚电路好 | 每个端点都有终点的完整地址<br>分组的转发 | 属于同一虚电路的分组按照同意路由转发 | 每个分组独立选择路由进行转发<br>结点故障 | 均失败 | 丢失分组<br>分组顺序 | 按序到达 | 无序<br>差错控制流量控制 | 由网络或者用户主机负责 | 由用户主机负责</p><h2 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h2><p>与IP协议配套的协议还有三个协议</p><ol><li>地址解析协议ARP, 反向的RARP逆地址解析协议</li><li>网际控制报文协议ICMP</li><li>网际组管理协议IGMP</li></ol><h3 id="虚电路互连网络"><a href="#虚电路互连网络" class="headerlink" title="虚电路互连网络"></a>虚电路互连网络</h3><p>将网络互连起来的设备要使用一些中间设备</p><ol><li>物理层使用的中间设备叫做转发器</li><li>数据链路层使用的中间设备叫做网桥</li><li>网络层使用的中间设备叫做路由器</li><li>在网络层以上使用的中间设备叫做网关, 用网关连接两个不兼容的系统需要在高层进行协议的转换</li></ol><p>当中间设备是装阿奇或网桥, 这仅仅是扩大一个网络, 这仍然是一个网络, 并不是网络互连</p><p>互联网可以由多种易购网络互连组成</p><h3 id="分类ip地址"><a href="#分类ip地址" class="headerlink" title="分类ip地址"></a>分类ip地址</h3><p>IP地址由两个长度的字段组成, 第一个字段是网络号, 标志主机(或路由器)所连接到的网络, 一个网络号在整个互联网范围内是必须是唯一的, 第二个字段是主机号, 标志主机</p><p>A类B类C类地址的网络号字段分别为一个, 两个, 三个字节长<br>D类地址(前四位1110)用于多播<br>E类地址(前四位1111)保留以后用</p><p>A类地址网络号占一个字节,只有7位可供使用, 可使用的网络好为(2^7 - 2), 一个是全0地址, 代表网络本身. 一个是127保留作为本地软件环回测试主机间进程使用</p><p>A类地址主机号占三个字节, 每一个A类网络最大主机数为(2^24 -2): 全0的表示表示网络地址, 全1的表示网络上的所有主机</p><p>B类地址可指派的网络数为2^14 -1个, 最大主机数为2^16 - 2个</p><h3 id="ip地址与硬件地址"><a href="#ip地址与硬件地址" class="headerlink" title="ip地址与硬件地址"></a>ip地址与硬件地址</h3><p>物理地址是数据链路层和物理层使用的地址, IP地址是网络层和以上各层使用的地址, 是一种逻辑地址</p><p>IP地址放在IP数据报的首部, 硬件地址放在mac帧的首部, 在网络层和网络层以上使用的是ip地址, 数据链路层及一下使用的是链路地址</p><ol><li>在ip抽象的互联网上只能看见IP数据报</li><li>路由器只根据目的站的ip地址的网络号进行路由选择</li><li>在局域网的链路层, 只能看见mac帧</li><li>隐藏细节</li></ol><h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><p>ARP是在主机ARP高速缓存中存放一个IP地址到硬件地址的映射表, 并且实时更新</p><p>广播请求分组</p><h2 id="ip数据报格式"><a href="#ip数据报格式" class="headerlink" title="ip数据报格式"></a>ip数据报格式</h2><ol><li><p>固定首部</p><ol><li><p>版本号4位, 协议版本ipv?</p></li><li><p>首部长度4位, 表示最大十进制数值为15字节, 最常用的首部长度为20字节(即0101)</p></li><li><p>区分服务8位, 一般不使用</p></li><li><p>总长度值首部和数据数据之和的长度, 单位为字节, 总长度为16位, 数据报最大长度为2^16 - 1字节</p><blockquote><p>IP协议规定, 所有的主机路由必须能够接受长度不超过576字节的数据报, 超过时需要分片</p></blockquote></li><li><p>标识16位, 作为计数器, 产生一个数据报就加1, ip作为无连接服务不存在按序接收,用来重组数据报, 在分片时这个标识字段复制给所有的数据报标识字段</p></li><li><p>标志3位, 只有两位有意义</p><ol><li>最低位字段为MF,MF=1 标识后面还有分片的数据报,MF=0 标识是若干数据报片中的最后一个</li><li>中间一位为DF, 标识不能分片, 当DF=0才允许分片</li></ol></li><li><p>片偏移13位, 分片后在原分组的相对位置</p></li><li><p>生存时间8位, 防止无法转发的, 每经过一个路由器就把TTL减去数据报在路由器消耗的时间, 小于一就减一,现在是跳数限制</p></li><li><p>协议8位,例如ICMP</p></li><li><p>首部校验和16位, 只校验数据报的首部, 先把IP数据报首部划分为16字节的序列, 校验和字段设为0, 算数运算想加所有的, 写入到检验和字段, 接收方收到后把所有的16字节使用运算相加后取反码, 未发生变化结果为0</p></li><li><p>源地址</p></li><li><p>目的地址</p></li></ol></li></ol><h2 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h2><ol><li><p>划分子网</p><ol><li>ip地址空间利用率不合理</li><li>给每一个物理网络分配一个网络号会使路由表变的太大, 互联网中的网络越多, 路由器中的路由表项目数越多, 也会导致路由器成本变高</li><li>两级IP地址不灵活</li></ol></li><li><p>划分子网的思路与</p><ol><li>一个拥有许多物理网络的单位, 可将所属的网络划分成若干子网, 划分子网是单位内部的, 单位以外的看不见, 只表现一个物理网络</li><li>从主机网络号借用若干位做子网号</li></ol></li><li><p>子网掩码, 用来确定网络划分</p><ol><li>把三级ip地址和收到的数据报目的地址按位与就能得出子网的网络地址</li></ol></li><li><p>使用子网时分组的转发</p><ol><li>路由表必须包含: 目的网络地址, 子网掩码, 下一跳地址</li><li>相与之后的结果如果不在路由表, 继续将结果再次相与</li></ol></li><li><p>无分类编址CIDR(构造超网)</p><ol><li>消除了传统A类等划分子网的概念</li><li>将32位IP地址分为前后两部分, 前面部分是网络前缀,后面部分指主机</li><li>使用斜线记法,IP地址后面加上斜线,然后协商网络前缀所占的位数</li><li>CIDR使用32为的地址掩码,也可称为子网掩码,斜线表示1的个数</li><li>最长前缀匹配</li></ol></li></ol><h2 id="网际控制报文协议"><a href="#网际控制报文协议" class="headerlink" title="网际控制报文协议"></a>网际控制报文协议</h2><p>允许主机或路由器报告差错</p><ol><li>种类<ol><li>ICMP差错报告报文</li><li>ICMP询问报文</li></ol></li></ol><p>统一三个字段: 类型, 代码和校验和</p><table><thead><tr><th>ICMP报文种类</th><th>类型值</th><th>ICMP报文类型</th></tr></thead><tbody><tr><td>差错报告报文</td><td>3</td><td>终点不可达</td></tr><tr><td>–</td><td>11</td><td>时间超过</td></tr><tr><td>–</td><td>12</td><td>参数问题</td></tr><tr><td>–</td><td>5</td><td>改变路由</td></tr><tr><td>询问报文</td><td>8/0</td><td>回送请求或应答</td></tr><tr><td>–</td><td>13/14</td><td>时间戳请求或回答</td></tr></tbody></table><p>应用在ping/tracerout</p><h2 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h2><ol><li><p>理想的路由算法</p><ol><li>算法完整</li><li>计算简单</li><li>适应变化</li><li>具有稳定性</li><li>公平的</li><li>最佳的</li></ol></li><li><p>分层次路由选择协议</p><ol><li>自治系统</li><li>内部网关协议IGP, 处在相同同的自治系统中, 如RIP和OSPF协议</li><li>外部网关EGP协议</li></ol></li><li><p>内部网关RIP是一种分布式的基于距离向量的路由网关协议, 距离也称跳数, RIP允许一条路劲最多15个路由器, 只适用于小型互联网</p><ol><li>仅仅和邻路由器交换信息</li><li>交换的信息是路由表</li><li>按固定时间间隔交换信息</li></ol></li></ol><p>RIP协议首部4字节, 每个路由信息20字节, 最多包含25个路由</p><ol start="4"><li><p>内部网关协议OSPF</p></li><li><p>开放最短路径优先, 是分布式的链路状态协议</p><ol><li>洪泛法向本自治系统所有路由器发送信息</li><li>发送的是与本路由器相邻的所有路由器链路状态</li><li>只有当链路状态发生变化后才向路由器发送信息</li></ol></li><li><p>外部网关协议BGP</p><ol><li>互联网规模太大, 自治系统之间路由选择困难</li><li>自治系统之间的路由选择必须考虑油管策略</li></ol></li></ol><h2 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h2><ol><li><p>IPv6基本首部</p><ol><li>更大的地址空间</li><li>扩展的地址层次结构</li><li>灵活的首部格式</li><li>允许协议的继续扩充</li><li>支持资源的预分配</li><li>首部8字节对其</li></ol></li><li><p>IPv6的改变</p><ol><li>取消了首部长度字段, 固定40字节</li><li>取消服务类型字段, 优先级和流标号实现了功能</li><li>取消了总长度字段改为有效载荷长度字段</li><li>取消了标识,标志, 片偏移字段, 包含在分片扩展首部</li><li>取消了协议字段, 改用下一个首部字段</li><li>取消了检验和字段</li><li>取消了选项字段, 用扩展来实现功能</li></ol></li><li><p>首部格式</p><ol><li>版本4位</li><li>通信量8位,区分数据报类别或优先级</li><li>流标号20位,流是互联网上从特定源点到特定终点(单播或多播)的一些了数据报(视频等), 流经过的路径上都保证指明服务质量</li><li>有效载荷长度16位, 除基本首部以外的字节数, 最大值为64kB</li><li>下一个首部8位,相当于ipv4协议字段或可选字段</li><li>跳数限制,TTL</li><li>源地址128位</li><li>目的地址128位</li></ol></li><li><p>ipv6的地址</p><ol><li>单播:点对点通信</li><li>多播:一点对多点的通信</li><li>任播:终点是一组计算机</li></ol></li></ol><p>IPv4到IPv6的转变</p><ol><li>双协议栈值一部分主机装有双协议站,v4和v6,双向通信,若DNS返回的是ipv4的地址,双协议栈主机就是用v4, 在v4向v6转发的时候转换后再发, 但是有些数据没法恢复, 例如流标号</li><li>隧道技术, 在ipv6进入v4网络时, 将ipv6数据报封装为v4数据部分,整个v6数据报变成了v4数据报数据部分</li><li>ip多播</li></ol><h2 id="vpn和网络地址转换NAT"><a href="#vpn和网络地址转换NAT" class="headerlink" title="vpn和网络地址转换NAT"></a>vpn和网络地址转换NAT</h2><p>vpn在对路由器中的所有路由器, 对目的地址是专用地址的数据报一律不进行转发,也称专用互联网</p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h2><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><p>运输层向它上面的应用层提供通信服务, 是面向通信部分的最高层, 也是用户功能的最低层</p><p>运输层为相互通信的应用进程提供了端到端的逻辑通信</p><p>IP层真正通信的实体是主机中的进程</p><h3 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h3><ol><li>用户数据报协议UDP</li><li>传输控制协议TCP</li></ol><h3 id="运输层端口"><a href="#运输层端口" class="headerlink" title="运输层端口"></a>运输层端口</h3><p>运输层所有的应用进程都可以通过运输层传送到IP层,这就是复用, 运输层从IP层收到发送给各应用进程的数据够分别交付给应用进程, 这就是分用</p><p>通信的终点虽然是应用进程, 单报文交付的是目的主机端口</p><h2 id="晕乎数据协议UDP"><a href="#晕乎数据协议UDP" class="headerlink" title="晕乎数据协议UDP"></a>晕乎数据协议UDP</h2><ol><li>udp是无连接的</li><li>尽最大努力交付</li><li>UDP是面向报文的, 一次性交付一个完整的报文</li><li>没有拥塞控制</li><li>UDP支持一对一, 一对多, 多对多的交互通信</li><li>UDP首部开销小</li></ol><h3 id="UDP首部格式-首部字段只有8个字节"><a href="#UDP首部格式-首部字段只有8个字节" class="headerlink" title="UDP首部格式, 首部字段只有8个字节"></a>UDP首部格式, 首部字段只有8个字节</h3><ol><li>源端口, 不需要可全为0</li><li>目的端口</li><li>长度, 最小值为8</li><li>检验和, 判断是够有误</li></ol><p>计算校验和时, 需要在头部加上一个伪首部(源IP地址, 目的IP地址, 0, 17, UDP长度), 仅用作计算检验和</p><h2 id="传输控制TCP"><a href="#传输控制TCP" class="headerlink" title="传输控制TCP"></a>传输控制TCP</h2><ol><li>面向连接</li><li>每条连接有两个TCP</li><li>TCP提供全双工通信</li><li>面向字节流, 指流入到进程或从进程流出的字节序列</li></ol><h3 id="tcp的链接"><a href="#tcp的链接" class="headerlink" title="tcp的链接"></a>tcp的链接</h3><p>TCP连接的端点是套接字,套接字是IP拼接端口</p><h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><p>TCP下面的网络提供的都是不可靠的传输, 不可靠的传输信道能够实现可靠传输</p><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p>停等就是每发送一个分组就停止发送等到确认</p><ol><li>无差错情况</li><li>出现差错后重传, 设置重传等待时间</li><li>确认丢失和确认迟到</li></ol><p>信道利用率= 发送分组时间/(发送分组时间 + RTT + 确认分组所需时间)</p><p>为了提高传输速率, 使用流水线传输</p><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>滑动窗口协议, 每收到一个确认, 发送窗口就向前滑动一个分组位置,接受方采用累计确认的方式</p><h2 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h2><ol><li>源端口和目的端口, 各占2个字节</li><li>序号,占四个字节, 报文段序号</li><li>确认号, 占四字节, 期望收到对方下一个报文段的第一个数据字节的序号, 确认号表示序号前的所有数据都已正确收到</li><li>数据偏移, 占4位, 指出TCP报文段的数据起始处距离TCP报文段的起始出有多远</li><li>保留文6位</li><li>控制位6位, URG=1紧急字段</li><li>ACK=1是确认号字段才有效</li><li>推送PSH=1是立即创建一个报文段发送过去, 接收方收到后立即交付</li><li>复位RST=1表示需要释放链接,然后重新建立链接</li><li>同步SYN=1而ACK=0是表示这是一个请求连接报文段, 若同意连接, 响应报文段syn=1,ACK=1</li><li>终止FIN用来释放连接</li><li>窗口站两字节</li><li>检验和占两字节, 同UDP一样都要加上伪首部, 第四个字段应改为6</li><li>紧急指针,2字节在URG=1才有效,指出本报文段中的紧急数据字节数</li><li>选项, 长度可变, 最长20字节</li></ol><h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>流量控制是让发送方的发送速率不要太快, 要让接收方来得及接收,设置持续计时器防止丢失后形成死锁</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>拥塞控制是防止过多的数据注入到网络中, 这样可以使用网络中的路由器或链路不会过载</p><p>流量控制是点对点通信量的控制, 是一个端到端的问题, 抑制发送方的数据发送速率</p><h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p>慢开始, 拥塞避免, 快重传, 快恢复</p><ol><li>慢开始和拥塞避免</li></ol><p>基于窗口的拥塞控制, 发送方维持一个拥塞窗口的状态变量, 窗口的大小取决于网络的拥塞程度, 发送方让自己的发送窗口等于拥塞窗口</p><p>判断出现网络拥塞的依据是出现了超时</p><p>慢开始是由小到大逐渐增大拥塞窗口数值,每经过一个传输轮次就加倍</p><p>防止拥塞窗口增长过大引起拥塞,设置慢开始门限</p><p>拥塞避免算法就是让拥塞串口慢慢增大, 每经过一个往返时间RTT就加1</p><p>快重传是不等待自己发送数据是才确认,而是立即发送确认</p><h2 id="TCP运输链接管理"><a href="#TCP运输链接管理" class="headerlink" title="TCP运输链接管理"></a>TCP运输链接管理</h2><p>三次握手<br>四次挥手</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>不同的网络应用的应用进程之间, 需要不同通信规则</p><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p>域名到IP的解析是有分布在互联网的域名服务器程序完成</p><p>域名不区分大小写, 完整域名不超过255个字符</p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>一个服务器所负责管辖的范围叫区, 一个区的所有节点必须是能够连通的, DNS服务器的范围不是以域作为单位, 而是区作为单位, 区小于等于域</p><ol><li>根域名服务器是最高层次的域名服务器, 所有根域名服务器都知道所有的顶级域名服务器</li><li>顶级域名服务器, 这些域名管理所有二级域名</li><li>权限域名服务器, 一个区的域名服务器</li><li>本地域名服务器<ol><li>主机向本地域名服务器的查询一般采用递归查询</li><li>本地域名服务器向根域名服务器查询使用迭代查询</li></ol></li><li>维护有高速缓存</li></ol><h2 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h2><p>FTP客户与服务器建立两个连接, “控制连接”和”数据传送连接”</p><h3 id="简单文件传送协议TFTP"><a href="#简单文件传送协议TFTP" class="headerlink" title="简单文件传送协议TFTP"></a>简单文件传送协议TFTP</h3><ol><li>每次传送512字节数据</li><li>数据报文按序编号,从1开始</li><li>支持ASCII码或二进制传送</li><li>可以对文件读写</li><li>使用简单的首部</li></ol><h2 id="远程终端协议TELNET"><a href="#远程终端协议TELNET" class="headerlink" title="远程终端协议TELNET"></a>远程终端协议TELNET</h2><h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><h3 id="统一资源定位符url"><a href="#统一资源定位符url" class="headerlink" title="统一资源定位符url"></a>统一资源定位符url</h3><h3 id="超文本传送协议HTTP"><a href="#超文本传送协议HTTP" class="headerlink" title="超文本传送协议HTTP"></a>超文本传送协议HTTP</h3><p>http1.1 使用的持续连接</p><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><ol><li>请求代理服务器</li><li>若存在就返回</li><li>否则代理服务器与互联网上的源点服务器建立TCP连接,并发送http报文</li><li>源点服务器吧请求的对象放在http响应报文返回代理服务器</li><li>代理服务器收到后复制到自己本地存储器中, 在吧这个对象放在http响应报文总通过已建立的链接返回请求该对象的浏览器</li></ol><h3 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构"></a>http报文结构</h3><ol><li>开始行, 区分请求报文和响应报文, 在开始行的三个字段之间用空格分隔开</li><li>首部行, 说明浏览器服务器或报文主体的一些信息,每一行的结束位置都要有回车和换行, 整个首部结束时, 还要空一行隔开</li><li>实体主题</li></ol><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>简单邮件传送协议SMTP, 通用互联网邮件扩充(附件),邮件读取协议pop3</p><ol><li>连接建立250, 不可用421</li><li>邮件传送, 出错451, 452空间不够, 500命令无法识别</li><li>连接释放221</li></ol><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><h2 id="简单网络管理协议SNMP"><a href="#简单网络管理协议SNMP" class="headerlink" title="简单网络管理协议SNMP"></a>简单网络管理协议SNMP</h2><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><p>被动攻击是从网络上窃听他人通信内容</p><p>主动攻击</p><ol><li>篡改, 更改报文流</li><li>恶意程序<ol><li>计算机病毒</li><li>计算机蠕虫</li><li>特洛伊木马</li><li>逻辑炸弹</li><li>后门入侵</li><li>流氓软件</li></ol></li><li>拒绝服务</li></ol><h3 id="安全的计算机网络"><a href="#安全的计算机网络" class="headerlink" title="安全的计算机网络"></a>安全的计算机网络</h3><ol><li>保密性</li><li>端点鉴别</li><li>信息完整性</li><li>运行完全性</li></ol><h2 id="两类密码体制"><a href="#两类密码体制" class="headerlink" title="两类密码体制"></a>两类密码体制</h2><ol><li>对称密码密码体制,DES属于对称秘钥密码体制, 保密性取决于对秘钥的保密, 算法是公开的</li><li>公钥密码体制使用不同的加密秘钥和解密秘钥,基于大数分解的RSA体制</li><li>数字签名<ol><li>接受者能够核实发送至对报文的签名</li><li>接受者确认收到的数据没有被篡改过</li><li>发送者不可抵赖</li></ol></li><li>鉴别<ol><li>报文鉴别<ol><li>密码散列函数</li><li>MD5和SHA-1,SHA</li><li>报文鉴别码</li></ol></li></ol></li></ol><h2 id="运输层安全协议"><a href="#运输层安全协议" class="headerlink" title="运输层安全协议"></a>运输层安全协议</h2><ol><li>安全套接字层SSL</li><li>运输层安全TLS</li></ol><h2 id="应用层安全协议PGP"><a href="#应用层安全协议PGP" class="headerlink" title="应用层安全协议PGP"></a>应用层安全协议PGP</h2><h2 id="系统安全防火墙"><a href="#系统安全防火墙" class="headerlink" title="系统安全防火墙"></a>系统安全防火墙</h2><p>防火墙是一种访问控制技术,严格控制网络边界的分组禁止任何不必要的通信</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker高级</title>
      <link href="/2019/11/21/docker-gao-ji/"/>
      <url>/2019/11/21/docker-gao-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ol><li>docker隔离的东西(linux namespace+chroot)<ul><li>UTS(主机名和域名)</li><li>User(用户)</li><li>Mount挂载点(文件系统)</li><li>IPC(信号量, 消息队列, 共享队列)</li><li>Pid(进程编号)</li><li>Network(网络)</li></ul></li><li>Control Groups(控制组)</li><li>LinuX Container(LXC)的增强版是docker</li><li>镜像:静态=&gt;进程</li><li>容器:生命周期=&gt;程序  </li></ol><h1 id="docker挂载机制"><a href="#docker挂载机制" class="headerlink" title="docker挂载机制"></a>docker挂载机制</h1><ol><li>采用分层挂载机制, 最底层为bootfs, 其次为rootfs<ol><li>bootfs:用于系统引导的文件系统, 包括bootloader和kernel, 容器启动后会被卸载以节约内存资源</li><li>rootfs:位于bootfs之上, 表现为容器的根文件系统<ol><li>传统模式中, 系统启动之时.内核会挂载rootfs时会首先将其挂载为只读模式, 完整性自检完成后将其重新挂载为读写模式</li><li>docker中, rootfs有内核挂载为只读模式, 而后通过联合挂载技术额外挂载一个可写层</li></ol></li><li><blockquote><p>联合挂载的意思是自下往上依次挂载</p></blockquote></li><li><blockquote><p>每一个功能都是一个image(镜像)</p></blockquote></li><li>位于最下层的镜像称为父镜像, 最底层的称为基础镜像</li><li>最上层的为可写层, 其下的均为只读层</li></ol></li></ol><h1 id="docker-虚拟网络"><a href="#docker-虚拟网络" class="headerlink" title="docker 虚拟网络"></a>docker 虚拟网络</h1><ol><li>在宿主机上建立一个桥接网卡docker0, brctl show显示桥接网卡绑定方式</li><li>将docker0的网卡作为一条网线,一般在宿主机docker0上,一般在docker容器中</li><li>docker0是一个nat桥,iptables -t nat -vnL, 可以看见postrouting规则, 所有进入的流量, 只要不是从docker0桥出去的流量, 原地址来自172.17.0.0/16,无论到达任何主机, 都要进行地址伪装</li><li>docker四种网络模式<ol><li>none, 批处理文件所用, 挂载本地卷, docker run -it –name b1 –network none –rm busybox</li><li>bridge网络, nat桥接docker0,default模式, docker run -it –name b1 –network bridge –rm busybox</li><li>共享同一个网络, IPC, pid模式, 网络对于多个容器可见</li><li>桥接物理网卡</li></ol></li><li>创建网络命名空间并实现网卡互联<ol><li>ip netns add r1创建一个网络名称空间r1</li><li>ip netns list 列出名称空间的网卡</li><li>ip netns exec r1 ifconfig -a进入名称空间r1执行ifconfig命令</li><li>ip link add name veth1.1 type veth peer name veth1.2添加一块类型为veth的虚拟网卡veth1.1,另一半网卡名veth1.2</li><li>ip link show 显示两块网卡连接状态</li><li>ip link set dev veth1.2 netns r1,将veth1.2网卡迁移到r1名称空间</li><li>ip netns exec r1 ip link set dev veth1.2 name eth0进入r1名称空间,并设置设备veth1.2的网卡名为eth0</li><li>ip netns exec r1 ifconfig eth0 10.1.0.1/24 up,将eth0网卡开启并设置ip为10.1.0.1,24位掩码</li><li>ip link set dev veth1.1 netns r2,将veth1.1网卡迁移到r2名称空间</li><li>ip netns exec r2 ip link set dev veth1.1 name eth0,设置网卡名称</li><li>ip netns exec r2 ifconfig eth0 10.1.0.2/24 up, 设置ip并开启网卡</li><li>ip netns exec r1 ping 10.1.0.2测试网络连通性</li></ol></li></ol><h1 id="docker容器注入"><a href="#docker容器注入" class="headerlink" title="docker容器注入"></a>docker容器注入</h1><ol><li>注入容器中主机名, docker run -it –name b1 –network bridge -h test –rm busybox</li><li>注入dns服务器, docker run -it –name b1 –network bridge -h test –dns 114.114.114.114 –rm busybox</li><li>注入host, docker run -it –name b1 –network bridge -h test –dns 114.114.114.114 –add-host <a href="http://www.baidu.com:192.168.0.148" target="_blank" rel="noopener">www.baidu.com:192.168.0.148</a> –rm busybox</li></ol><h1 id="docker-端口映射"><a href="#docker-端口映射" class="headerlink" title="docker 端口映射"></a>docker 端口映射</h1><ol><li>docker run -d –name b1 –rm -p 80 ajinwu/httpd:v1.1</li><li>docker run -d –name b1 –rm -p 192.168.0.148::80 ajinwu/httpd:v1.1</li><li>docker run -d –name b1 –rm -p 192.168.0.148:80:80 ajinwu/httpd:v1.1</li><li>docker run -d –name b1 –rm -p 80:80 ajinwu/httpd:v1.1</li><li>自动暴露使用大写的p</li></ol><h1 id="联盟式容器"><a href="#联盟式容器" class="headerlink" title="联盟式容器"></a>联盟式容器</h1><ol><li>docker run -it –name b2 –network container:b1 –rm busybox, 共享b1的网络名称空间, 但是文件系统也是隔离的</li><li>docker run -it –name b1 –network host –rm busybox, 共享主机的网络</li><li>docker远程连接机器控制docker, 按照官方文档, 修改docker.service文件可行, ubuntu19.04修改daemon.json文件无效, 原因未知</li></ol><h1 id="自己创建网络"><a href="#自己创建网络" class="headerlink" title="自己创建网络"></a>自己创建网络</h1><ol><li>docker network create -d bridge –subnet “172.26.0.0/16” –gateway “172.26.0.1” mybr0, 创建网络mybr0,方式为桥接,子网为172.26.0.0, 网关如上</li></ol><h1 id="数据卷的必要性"><a href="#数据卷的必要性" class="headerlink" title="数据卷的必要性"></a>数据卷的必要性</h1><ol><li>关闭并重启容器, 其数据不受影响, 但是删除docker容器, 其更改会消失</li><li>存在的问题<ol><li>存储在联合文件系统中, 不易于宿主机访问</li><li>容器间数据共享不方便</li><li>删除数据数据会丢失</li></ol></li><li>解决方案:卷<ol><li>卷是容器上的一个或多个目录, 此类目录会绕过联合文件系统, 与宿主机上的某目录绑定关联</li></ol></li><li>docker run –name b1 -it -v /data busybox, docker自己管理的绑定卷, 使用inspect可以查看挂载地址</li><li>docker run –name b1 -it -v /home/ajin_w/docker/volumes:/data –rm busybox, 挂载本地卷存放数据, 不存在会默认创建, 双向创建</li><li>容器间共享数据:使用挂载卷, 两个容器使用同一个挂载卷</li><li>复制一个容器已存在的卷<ol><li>docker run –name infracon -it -v /home/ajin_w/docker/volumes/infracon:/data/web/html busybox, 创建一个基础容器, 可以不用交互式, 也可以不用启动, 但是不能删除, 只提供给其他容器复制</li><li>docker run –name nginx –network container:infracon –volumes-from infracon -it –rm busybox, 创建一个nginx容器, 继承infracon容器的网络, 存储卷也使用infracon相同的配置</li></ol></li></ol><h1 id="docker信息查询"><a href="#docker信息查询" class="headerlink" title="docker信息查询"></a>docker信息查询</h1><ol><li>docker inspect b1 -f , 使用json层级读取数据</li></ol><h1 id="dockerfile制作"><a href="#dockerfile制作" class="headerlink" title="dockerfile制作"></a>dockerfile制作</h1><ol><li>指令格式format<ol><li>comment, 注释信息</li><li>指令和指令参数</li></ol></li><li>指令本身不区分字符大小写, 约定俗称使用大写</li><li>docker运行自上而下</li><li>第一个非注释行一定是以from开头</li><li>dockerfile文件首字母一定要大写</li><li>打包文件一定要在本目录以及本目录之下</li><li>FROM格式, FROM <repository>[:tag] 或者FROM <repository>@<digest> digest为哈希码, 不会被冒名顶替</digest></repository></repository></li><li>COPY, 将本机的文件复制到镜像, 源文件一般为相对与dockerfile文件目录, 目标文件一般为镜像中的绝对路径<ol><li>复制目录目录本身不会被复制, 只会递归复制目录下的文件</li><li>必须以/结尾</li></ol></li><li>ADD, 语法和COPY相同, 可以加上url, 会自动下载文件, 本地打包文件会自动解压</li><li>WORKDIR, 制定工作目录</li><li>VOLUME, 指定挂载卷, 只能指定容器内的, 容器外只能使用默认的</li><li>EXPOSE, 为容器打开指定要监听的端口与外部通信, 在dockerfile中写入只是会作为待暴露的端口, 而不是直接暴露, 加上P会暴露</li><li>ENV <key>=<value> …value中含有空白字符等需要使用反斜杠转义, 或者引号转义, 反斜线也可以进行续行</value></key></li><li>RUN, 正常写linux操作命令, 必须是基础镜像有的命令, 在docker build的时候执行<ol><li>作为shell的子进程来运行, 以”/bin/bash -c”来运行, 此进程pid不为1, 不能接受unix信号, 因此, docker stop无法停止容器</li><li>RUN [“<executable>“, “param”]格式的命令不以”bash”运行, 因此shell常见操作不会进行(通配符))</executable></li><li>依赖shell特性可RUN[“bin/bash”, “-c”, “executable”, “param”]信号也不是1</li></ol></li><li>CMD, 类似与RUN指令, 定义一个镜像文件启动为容器时默认要运行的程序, 只能出现一个CMD, CMD指令可以被dockerfile命令选项覆盖<ol><li>CMD <commend> pid不为1,可以使用shell命令</commend></li><li>CMD[“executable”,”param”]创建的是pid为1的进程, 这里不能默认启动shell, 可以手动运行为shell子进程</li><li>CMD [“param”]结合entrypoint来运行</li></ol></li><li>ENTRYPOINT命令不会被覆盖, 也不允许被覆盖, 多余输入的命令会被当做参数传入, 可以在启动容器时修改entrypoint命令<ol><li>如果CMD和ENTRYPOINT同时使用, 则CMD的命令会被当做参数传入ENTRYPOINT</li></ol></li><li>docker参数-e, 设置环境变量</li><li>shell命令, exec顶替上一个进程, “$@”, 后面任意长度字段的作为参数, exec “$@”, 顶替当前进程, 然后将后面的命令传入当做下一个程序执行</li><li>HEALTHCHECK健康监测<ol><li>HEALTHCHECK –interval=duration(default:30s), 检测周期</li><li>–timeout=duration(default:30s)超时时间</li><li>–start-period=duration(default:0s), 容器启动多少秒开始检测</li><li>–retries=N (default:3), 检测次数</li><li>example===&gt; HEALTHCHECK –interval=5m –timeout=3s CMD curl -f <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> || exit 1</li></ol></li><li>ONBUILD触发器命令, 在别人使用你的镜像时会执行这个命令, 后门</li></ol><h1 id="docker-仓库"><a href="#docker-仓库" class="headerlink" title="docker 仓库"></a>docker 仓库</h1><ol><li>apt install docker-registry</li><li>insecure-registries</li><li>vmrare harbor</li></ol><h1 id="docker-资源限制"><a href="#docker-资源限制" class="headerlink" title="docker 资源限制"></a>docker 资源限制</h1><ol><li>linux 通过内核来管理资源调度, 使用内存计算算法来管理, oom-score最高的会被最先杀死, 重要应用应使用oom_obj来分配权重</li><li>内存限制<ol><li>–momery内存不应该大于主机内存</li><li>–momery-swap为交换空间, 不设置memory则无法设置此选项<ol><li>-m-s为正数S, m为正数M, 容器总空间为S, 其中ram为M, swap为(S-M), 如S=M, 则无可用swap资源</li><li>0, M, 相当于未设置swap(unset)</li><li>unset, M, 若主机弃用了swap, 容器可用swap为2*M</li><li>-1, M, 若主机弃用了swap, 容器可使用最大主机swap资源</li></ol></li><li>–oom-kill-disable, 禁止kill</li></ol></li><li>cpu限制<ol><li>默认可使用所有的cpu</li><li>cpu可压缩, 共享式cpu-shares共享, 按照比例切分, 不用的时候cpu可以尽可能共享给他人, 使用的时候按比例给他最大的, 然后检查其他进程cpu资源是否空闲, 空闲可继续使用</li><li>–cpus=1.5, 显示cpu最多使用几核, 可使用小数</li><li>–cpuset-cpus, 限制使用的cpu是哪几个, 不建议使用</li></ol></li><li>docker run –name stress -it –rm -m 256m lorel/docker-stress-ng stress –vm 2, 验证memory限制, docker stats显示详细信息</li><li>docker run –name stress -it –rm –cpus 2 lorel/docker-stress-ng stress –cpu 8, cpu压测</li><li>docker run –name stress -it –rm –cpu-shares 1024 lorel/docker-stress-ng stress –cpu 8, 共享式分配, 首先会占用完cpu, 然后再来一个容器会互相分配</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker初级</title>
      <link href="/2019/11/21/docker-chu-ji/"/>
      <url>/2019/11/21/docker-chu-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="获取docker镜像"><a href="#获取docker镜像" class="headerlink" title="获取docker镜像"></a>获取docker镜像</h1><ul><li>获取镜像<ul><li>docker pull ubuntu:18.10  下载镜像<ul><li>默认不填版本号会选最新版本的，即latest，默认使用官方镜像</li><li>非官方镜像下载 <blockquote><p>docker pull hub.c.163.com/public/centos:6.5</p></blockquote></li><li>pull 参数<ul><li>-a，    –all表示获取所有镜像，默认为否</li></ul></li></ul></li></ul></li></ul><pre><code>- 查看镜像    - docker images列出镜像        - images参数            - -a，    列出所有镜像            - -f ，   列出过滤的镜像，例如列出没有被使用的镜像                &gt;docker images -f dangling=true    - docker tag ubuntu:latest ajinwu:test给镜像起别名，类似于软链接    - docker inspect web列出web这个容器的详细信息(注意，并不是镜像名)        - -f参数            &gt;docker inspect -f {{".Networks"}} web  显示web容器的网络信息    - docker history ajinwu:test列出镜像的创建过程        &gt;docker history --no-trunc ajinwu:test  显示截断的信息- 搜寻镜像    - docker search [option] keyword        - -f    过滤输出内容            &gt; docker search -f=is-official=true nginx   查找镜像，官方给出的带有nginx的镜像        - --limit int 限制输出内容            &gt; docker search --limit=3 nginx         显示前三条结果- 清理镜像    - docker rmi ubuntu:18.10       删除镜像标签为18.10的ubuntu镜像    - -f强制删除，即使有容器依赖    - docker ps -a  列出本机用过的所有容器    - 先删除容器在删除镜像        &gt; docker rm [CONTAINER ID]  删除镜像        &gt; docker rmi -f ajinwu/commit_test1:latest  强制删除镜像        &gt; docker images prune -f 自动清除遗留文件层- 创建镜像    - docker commit -m "add a new file" -a "docker ajin" c57 ajinwu/commit_test     制作一个新镜像，信息为add  file，作者信息为docker  ajin，容器id为c57开头,仓库名为ajinwu/,镜像名为commit_test 的新镜像    - 还可以添加-p暂停容器的运行    - 可以使用openVZ提供的模板来创建镜像        - cat ubuntu-18.04-x86_64.tar.gz | docker import - ubuntu:18.04    - dockerfile构建镜像        - docker build -t="ajinwu/dockerfile" .     -t参数为镜像名，后面加上dockerfile的目录- 存出镜像和载入镜像    - 存出镜像 docker save -o ubuntu_commit.tar ajinwu/commit_test    - 载入镜像  docker load &lt; ubuntu_commit.tar    - 上传镜像        - 先修改标签，格式为用户ID/镜像名docker tag test:test ajinwu/test        - 上传  docker push ajinwu/test</code></pre><ul><li><p>操作容器</p><ul><li><p>创建容器</p><ul><li><p>docker create -it ajinwu:test创建一个容器不运行</p></li><li><p>docker run -it ajinwu:test /bin/bash 使用ajinwu:test镜像创建一个容器并开启交互式终端使用/bin/bash</p></li><li><p>docker run -p 8111:80 –name nginx -i -t ubuntu /bin/bash     创建一个容器名为nginx的容器，将本地的8111端口映射到容器的80端口，可使用容器的地址直接访问</p></li><li><p>常用参数说明</p><ul><li>-i    保持标准输入输出打开</li><li>-t    分配伪终端</li><li>-d    是否后台运行，默认为否</li><li>–net=”bridge”    开启桥接网络</li><li>–expose      暴露端口</li><li>-p映射端口 -p</li></ul></li><li><p>开启容器docker start 042  注意，只能使用id</p></li><li><p>docker run ubuntu /bin/echo “hello wolrd”</p><ul><li>检查本地是否有ubuntu镜像</li><li>利用镜像创建一个容器，并启动该容器</li><li>分配一个文件系统给容器，并在只读镜像层外面挂载一层可读写层</li><li>从宿主主机的配置的网桥接口中桥接一个虚拟接口到容器</li><li>从网桥的地址池配置一个ip给容器</li><li>执行用户指定的应用程序</li><li>执行完命令容器被自动终止</li></ul></li><li><p>查看容器输出</p><ul><li><blockquote><p>docker logs  -f -t  –tail 10 test       查看最后10条并持续输出显示时间</p></blockquote></li></ul></li></ul></li><li><p>停止容器</p><ul><li>docker run –name=ajin2 -it –rm ubuntu bash运行一个容器，命名为ajin2，交互式伪终端运行bash，运行结束后删除该容器</li><li>Ctrl +p    Ctrl+q 后台运行容器，不停止容器的退出</li><li>docker pause ajin2 暂停容器ajin2</li><li>docker stop ajin2 终止容器ajin2</li><li>docker ps 查看容器<ul><li>-l    查看正在运行的容器</li><li>-a    查看所有容器</li><li>-qa   只查看所有容器的id</li></ul></li><li>docker restart 042    重启容器</li></ul></li><li><p>进入容器</p><ul><li>docker attach 042  进入后台容器</li><li>docker exec -it 042 bash  推荐这种方式，在不影响运行应用的情况下开启一个新的bash</li></ul></li><li><p>docker rm -f 042      强行删除容器（不建议）</p></li><li><p>导入和导出容器</p><ul><li>导出容器<ul><li>docker export -o test_export.tar 4ac</li></ul></li><li>导入容器<ul><li>docker import test_export.tar - test/ubuntu:v11这命令我不知道为啥错了</li></ul></li></ul></li><li><p>查看容器</p><ul><li>docker top 4ac       查看运行中的容器进程</li><li>docker stats 4ac  类似与htop命令</li><li>docker inspect 4ac    查看容器信息</li></ul></li><li><p>其他容器命令</p><ul><li>复制文件docker cp dp_2.py 4ac:/tmp，复制本机的文件到容器的tmp下</li><li>反向赋值docker cp 4ac:/test.txt .</li><li>docker  diff 4ac     查看容器数据修改</li><li>docker container port d8  查看端口映射<h1 id="访问docker仓库"><a href="#访问docker仓库" class="headerlink" title="访问docker仓库"></a>访问docker仓库</h1></li></ul></li></ul></li><li><p>各大镜像仓库</p><ul><li>阿里云，网易云，腾讯云docker pull  url</li></ul></li><li><p>搭建本地私有仓库，大家自行学习</p></li></ul><h1 id="docker数据管理"><a href="#docker数据管理" class="headerlink" title="docker数据管理"></a>docker数据管理</h1><ul><li><p>数据卷</p><ul><li>docker volume create -d local test 会在宿主机/var/lib/docker/volumes下创建一个test数据卷</li><li>绑定数据卷<br>  docker run -it -p 80 –name=blog -v /home/ajin_w/blogbak:/home/ajin_w/blog ubuntu /bin/bash     此命令为开启一个名为blog的容器，-v参数为映射本地文件夹blogbak目录到容器blog下，映射目录相当于一个网络驱动器，容器内外的修改均会生效，可在映射结束的位置添加读写权限，例如ro</li></ul></li><li><p>数据容器</p><ul><li><p>数据容器的创建使得挂载该数据容器的容器间可以很方便的进行数据交换</p></li><li><p>创建数据容器</p><ul><li>docker run -it -v /dbdata –name dbdata ubuntu</li></ul></li><li><p>挂载数据容器</p><ul><li>docker run -it –volumes-from dbdata –name db1 ubuntu</li></ul></li><li><p>数据容器不需要保持在运行状态</p></li><li><p>删除数据卷必须在最后一个挂载他的容器显式使用docker rm -v命令来指定同时删除关联的容器</p></li><li><p>数据迁移</p><ul><li>docker run –volumes-from dbdata -v $(pwd):/backup –name worker ubuntu tar -cvf /backup/backup.tar /dbdata</li><li>以上命令解释：创建一个worker容器，挂载dbdata数据卷，使用-v参数挂载本地当前目录到worker的容器的backup目录，容器启动后，打包dbdata为容器的/backup/backup.tar，即宿主机的当前目录下的backup.tar      意思就是挂载两个数据卷，一个本地目录，一个数据卷或者数据容器，将容器内的数据卷打包到容器的backup目录，因为直接挂载数据卷在/目录下，在挂载一个目录，将/目录下的数据卷打包进backup就好，本地目录变成了backup</li></ul></li><li><p>数据恢复</p><ul><li>docker run -v /dbdata –name dbdata2 ubuntu /bin/bash </li><li>创建一个容器挂载dbdata数据卷，名为dbdata2</li><li>docker run –volumes-from dbdata2 -v $(pwd):/backup ubuntu tar xvf /backup/backup.tar </li><li>创建另一份容器挂载dbdata2和当前目录到/backup目录，将本地的目录解压</li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典和集合</title>
      <link href="/2019/11/12/zi-dian-he-ji-he/"/>
      <url>/2019/11/12/zi-dian-he-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="泛映射类型"><a href="#泛映射类型" class="headerlink" title="泛映射类型"></a>泛映射类型</h1><p>collection.abc 模块中有mapping和mutaleMapping这两个抽象基类, 往往为dict和其他类似的类型定义形式接口</p><p>非抽象映射类型一般不会直接继承抽象基类, 会直接对dict或者collection.userdict进行扩展</p><p>标准库里的所有映射类型都是利用dict来实现的, 因此只有可散列的数据类型才能用作这些键(只有键有要求, 值并无要求)</p><blockquote><p>可散列数据类型在这个对象的生命周期内, 其散列值不会改变, 同时还需要实现<strong>hash</strong>和<strong>eq</strong>方法才可进行比较</p></blockquote><blockquote><p>原子不可变类型(str, 数值, bytes)都是可散列类型, frozenset只能存放可散列类型, 因此他也是可散列类型, 元组中所有的元素都是可散列的, 元组才是可散列的</p></blockquote><h1 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h1><pre><code>{key: value for key, value in count.items}</code></pre><h1 id="键的映射方法"><a href="#键的映射方法" class="headerlink" title="键的映射方法"></a>键的映射方法</h1><p>要使用setdeafult来处理找不到的键r.setdeafult(key,[]), 这一句的意思是<code>if key is not in dict: dict[key] = []</code></p><h1 id="映射的弹性查询方法"><a href="#映射的弹性查询方法" class="headerlink" title="映射的弹性查询方法"></a>映射的弹性查询方法</h1><p>在某个键不存在时, 我们也想通过这个键读取一个默认值, 这样有两个方法, 1是使用defaultdict, 2是自己定义一个dict的子类实现<strong>missing</strong>方法</p><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>在设置默认值时, 要使用一个数据类型的构造方法,如<em>list</em>, 如果查找不到对应的记录, 会使用default_factory方法来设定一个值</p><h2 id="特殊的missing方法"><a href="#特殊的missing方法" class="headerlink" title="特殊的missing方法"></a>特殊的<strong>missing</strong>方法</h2><p>所有映射类型找不到键都会调用这个方法, 但是只对getitem有效, 对get和in没有影响</p><pre class="line-numbers language-python"><code class="language-python">l<span class="token punctuation">.</span>__getitem__<span class="token punctuation">(</span>key<span class="token punctuation">)</span>l<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">,</span>default<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种处理是不一样的, 第一种会报错, 第二中会是默认值或者返回为None</p><p>在找不到键的时候使用<strong>missing</strong>方法, 可以做一些特殊的操作</p><p>如果要使用key in dict方法, 就必须要实现<strong>contains</strong>方法, 因为找不到也会到<strong>missing</strong>里面寻找, 产生无限递归, 而使用in操作时, 会产生一个视图, 这种操作查找元素很快</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">strkey</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 再找不到键的时候会在这里进行字符装换</span>    <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>key<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> KeyError<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">[</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> default <span class="token operator">=</span> None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">[</span>key<span class="token punctuation">]</span>        <span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>            <span class="token keyword">return</span> default    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">or</span> str<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>d <span class="token operator">=</span> strkey<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">"2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"None"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 只对get有效而不对__getitem__无效</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h1><p>有序字典collections.OrderedDict 排序</p><pre class="line-numbers language-python"><code class="language-python">d <span class="token operator">=</span> collections<span class="token punctuation">.</span>OrderedDict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> s<span class="token punctuation">:</span>    <span class="token keyword">if</span> i <span class="token keyword">in</span> d<span class="token punctuation">:</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>d <span class="token operator">=</span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token keyword">lambda</span> d<span class="token punctuation">:</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> reverse <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">## 返回列表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>collections.chainMap()做模板之用, 适合嵌套数据</p><p>UserDict并不是dict的一个子类, 继承于dict更推荐使用UserDict, 前者会在有些实现上走一些捷径, 有些方法必须要重写</p><p>UserDict由一个data属性, 实际上是存储的dict里面的属性</p><p>UserDict 继承的是mutableMapping</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> UserDict<span class="token keyword">class</span> <span class="token class-name">user_dict</span><span class="token punctuation">(</span>UserDict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>key<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> KeyError<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">[</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> str<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>data <span class="token comment" spellcheck="true"># data是一个dict实例</span>    <span class="token keyword">def</span> <span class="token function">__setitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> itemd <span class="token operator">=</span> user_dict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">"2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"None"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h1><p>types模块中由一个封装类名叫做MapingProxyType, 使用此类包装的数据是动态的, 无法做改变, 需要修改原数据才可以改变包装后的数据</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> types <span class="token keyword">import</span> MappingProxyTyped <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token string">"A"</span><span class="token punctuation">}</span>d_proxy <span class="token operator">=</span> MappingProxyType<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"x"</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>d_proxy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"b"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合内的元素必须是可散列的, set本身是不可散列的, 但是frozenset可以散列</p><h2 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h2><p>a = {1}</p><blockquote><p>如果是空集, 必须使用无参构造方法<br>对于a = set([1,2]) 和a = {1, 2}来说, 后者的速度会更快一些</p></blockquote><p>frozenset没有特殊字面量说法, 只能采用构造方法</p><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>&amp; 交集</p><p>| 并集</p><p>- 差集</p><p>^ 对称差集 (A U B) - (A n B)</p><blockquote><p>在集合方法discard是移除元素, 不存在不会报错</p></blockquote><h1 id="dict和set的背后"><a href="#dict和set的背后" class="headerlink" title="dict和set的背后"></a>dict和set的背后</h1><p>dict和set搜索都比list快, 是由于list背后没有散列表来支持in运算, 因此每次都会扫描整个列表</p><h2 id="字典中的散列表"><a href="#字典中的散列表" class="headerlink" title="字典中的散列表"></a>字典中的散列表</h2><p>散列表是一个稀疏数组, 在dict的散列表中, 每个键值对都占有表元, 一个是键的引用, 一个是值得引用, 因为所有的表元的大小一致, 所以可以通过偏移量来读取, python会保证1/3是空的, 超过会自动复制到更大的空间</p><p>在插入新值时, python会按照散列表的拥堵程度来决定是否重新分配内存, 为了减小散列冲突, 散列值位数和索引位数也会增加</p><h2 id="dict的实现和后果"><a href="#dict的实现和后果" class="headerlink" title="dict的实现和后果"></a>dict的实现和后果</h2><p>散列需要满足的要求</p><ol><li>支持hash函数, 并且hash计算不变</li><li>支持<strong>eq</strong>来判等</li><li>若a==b, 则hash(a) == hash(b)</li></ol><p>所有用户自定义的对象都是可散列的, 因为散列值是id()来获取</p><blockquote><p>如果实现了<strong>eq</strong>方法, 并且希望是可散列的, 就必须实现<strong>hash</strong>方法, 并保证相等</p></blockquote><p>字典在内存上的开销巨大</p><p>字典的键查询很快, 空间换时间</p><p>键的次序取决于添加顺序</p><p>往字典添加新键可能会改变已有的顺序, 因为每一次添加新键都有可能使字典扩容, 造成散列冲突, 导致打乱原有的顺序</p><blockquote><p>keys, items, values返回的都是字典视图</p></blockquote><h2 id="set的实现以及后果"><a href="#set的实现以及后果" class="headerlink" title="set的实现以及后果"></a>set的实现以及后果</h2><ol><li>集合元素必须是可散列的</li><li>集合很消耗内存</li><li>in很高效</li><li>元素的次序决定于添加的次序</li><li>添加可能会改变次序</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>dict, defaultdict, userdict, orderedDict, ChainMap, Counter, UserDict</p><p>setdefault</p><p><strong>missing</strong></p><p>MappingProxyType</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列构成的数组</title>
      <link href="/2019/11/12/xu-lie-gou-cheng-de-shu-zu/"/>
      <url>/2019/11/12/xu-lie-gou-cheng-de-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="内置序列类型"><a href="#内置序列类型" class="headerlink" title="内置序列类型"></a>内置序列类型</h1><ol><li><p>python标准库使用c实现了丰富的序列类型</p><ol><li>容器序列:list, tuple, collection.deque这些序列能存放不同类型的数据</li><li>扁平序列:str, bytes, bytesarray, memoryview和array.array, 这种序列只能容纳一种类型<blockquote><p>容器序列存放的是他们所包含的对象的引用, 扁平序列存放的是值, 换句话来说, 扁平序列是一段连续的内存空间</p></blockquote></li><li>可变序列:list, bytesarray, array.array, collections.deque, memoryview</li><li>不可变序列: tuple, str和bytes</li></ol></li><li><p>列表推导和生成器表达式</p><ol><li>列表推导式并不一定比map慢</li><li>在初始化序列类型时, 使用生成器表达式是更好的选择, 生成器表达式遵守了迭代器协议, 可以逐个产生元素, 列表推导式是先建立一个完整的列表, 然后再把这个列表传递到某个构造函数里面, 不够节省内存.</li><li>生成器表达式每次for循环才会生成一个组合, 所以会省掉笛卡尔积的for循环开销</li></ol></li><li><p>元组不仅仅是不可变的列表</p><ol><li>元组和记录: 元组其实是对数据的记录, 元组的每个元素都存放了一个字段的数据, for循环可以自动拆包元组, 迭代过程中, print可以接受一个元组作为参数输入, 拆包让元组当做记录来使用.</li><li>元组拆包可以应用到任何可迭代对象上, 但是可迭代对象的元素必须要跟接受这些元素的元组的空挡数已知</li><li>拆包中对于不定长参数使用*获取, 可以应用与任何位置, 自动对应长度</li><li>python3中函数参数不接受元组型(不接受所有迭代序列, 例如(a, b), [a, b])</li></ol></li><li><p>具名元组</p><ol><li>创建一个具名元组需要两个参数, 一个是类名, 另一个是类的各个字段的名字, 后者可以由数个字符串组成的可迭代对象, 或者是有空格分割开的字段名组成的字符串</li><li>存放在对应字段里的数据要以一串参数的形式传入到构造函数中, 元组的构造函数只接受单一的可迭代对象</li><li>可以通过字段名获取对应位置的字段信息</li><li>具名元组里面可以叠加具名元组, 实现高级数据结构</li><li>具名元组相当于一个类</li><li>重复拼接方法<strong>mul</strong>(n), 生成一个新的对象</li></ol></li><li><p>切片</p><ol><li>切片和区间操作会忽略最后一个元素, 符合以0为开始的风格</li><li>python的内置序列类型都是一维的, 他们只支持单一索引</li><li>如果把切片放在赋值语句的左边, 或者把他作为del操作的对象, 我们就可以对序列进行嫁接, 切除, 或者就地修改等操作</li><li>如果赋值的对象是一个切片, 那么右值必须是一个可迭代序列</li></ol></li><li><p>对序列使用+*</p><ol><li>序列支持+*, 在拼接的过程中, 两个被操作的序列都不回被修改, python会新建一个包含同类型的序列作为拼接的结果</li><li>不要使用[[“_”]] * 3这种语法</li><li>序列增量赋值要实现<strong>iadd</strong>方法, 如果没有实现, 解释器会自动转向<strong>add</strong>方法</li><li>在元组中, 有可变序列时, 需要append而不是直接+=</li></ol></li><li><p>list.sort和内置函数sorted</p><ol><li>list.sort()方法会原地赋值, 返回值为None, 并不会产生新的对象</li><li>sorted可以接受任何可迭代的对象作为参数, 甚至不可变序列或生成器</li><li>reverse和key作为可选关键字, key用于序列中的每一个元素, 作为排序的对比关键字, 比如key=len, 进行基于字符串长度的排序</li></ol></li><li><p>用bisect来管理已排序的序列</p><ol><li>bisect.insort(list, item), 讲一个新的item放入list, 保持有序的同时插入, 函数有返回值, 返回值为在新序列中的位置</li><li>bisect中的方法都有left和right可选, 区别在于放在左边还是右边</li></ol></li><li><p>当列表不是首选时</p><ol><li>数组<ol><li>数组支持所有跟可变序列有关的操作, 还提供从文件读取和存入文件更快的方法, frombytes和tofile方法</li><li>数组只能存放限定类型的数据</li></ol></li><li>内存视图, 看不懂</li><li>双向队列<ol><li>maxlen是可选参数, 固定后不可改变</li><li>对满队列添加元素时会自动删除左端或者右端元素</li><li>deque原子操作, 是线程安全的</li></ol></li></ol></li><li><p>总结</p><ol><li>序列类型分为可变序列和不可变序列, 或者说是扁平序列和容器序列, 扁平序列只能保存原子操作, 容器序列可以保存其他序列, 容器:有些对象包含其他对象的引用.</li><li>对于重复拼接在遇到不可变序列时, 会产生新的序列, 如果遇到可变的会就地修改</li><li>元组存放没有关系的数据</li><li>sorted和list.sort背后的算法是timsort自适应算法, 会根据原始数据的特点交替使用插入排序和归并排序</li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机概论</title>
      <link href="/2019/11/11/ji-suan-ji-gai-lun/"/>
      <url>/2019/11/11/ji-suan-ji-gai-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="数据表示方式"><a href="#数据表示方式" class="headerlink" title="数据表示方式"></a>数据表示方式</h1><h2 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h2><p>在计算机中, 所有的数据都是二进制</p><h2 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h2><p>常用的英文编码都是ascii, 每个符号(英文, 数字, 或符号等)都会占用一个bytes, 总共会有2^8中变化, 目前所使用的Unicode编码系统解决了这个问题</p><h1 id="软件程序运作"><a href="#软件程序运作" class="headerlink" title="软件程序运作"></a>软件程序运作</h1><p>目前计算机都将软件分为两大类, 系统软件和应用程序</p><h2 id="机器程序与编译程序"><a href="#机器程序与编译程序" class="headerlink" title="机器程序与编译程序"></a>机器程序与编译程序</h2><p>cpu具有微指令集, 让cpu帮忙工作必须要参考微指令集, 这个流程包括一下方面</p><ol><li>需要了解机器语言</li><li>需要了解所有硬件的相关功能函数</li><li>程序具有不可移植性, 每个cpu都有独特的微指令集, 同样, 每个硬件都有相关功能函数</li><li>程序具有专一性, 要面对相关硬件来编写</li></ol><p>编译程序做了将高级语言转化为机器语言的功能来完成程序的运行</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统也是一组程序, 这组程序主要来管理计算机以及相关硬件</p><p>操作系统放置在内存中的受保护区域, 开机后一直常驻与内存</p><h2 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h2><p>操作系统除了核心程序之外, 通常会提供开发接口, 就是sc, 开发工程师只需要遵循sc参数开发软件</p><ol><li>操作系统的核心层直接参看硬件规格, 所以同一个操作系统不能再不同硬件平台运作</li><li>操作系统只管理硬件资源, 包括cpu, 内存, 输入输出装置及文件系统文件</li><li>应用程序开发参考操作系统提供开发接口</li></ol><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li>system call interface</li><li>程序管理, 内核控制分配cpu资源   </li><li>内存管理</li><li>文件系统管理</li><li>硬件驱动</li></ol><h2 id="操作系统与驱动程序"><a href="#操作系统与驱动程序" class="headerlink" title="操作系统与驱动程序"></a>操作系统与驱动程序</h2><p>操作系统会提供开发接口给硬件开发商, 根据接口设计驱动程序</p><ol><li>操作系统必须能够驱动硬件, 应用程序才能使用该硬件</li><li>一般来说, 操作系统会提供开发接口</li><li>使用新硬件, 必须安装驱动程序</li><li>驱动程序由开发者提供, 与操作系统开发者无关</li></ol><h1 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h1><p>应用程序是参考操作系统开发接口开发的软件, 达到某些计算机功能</p><p>应用程序与操作系统有关系</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>计算机定义: 接受用户输入指令与数据, 经过中央处理器的算逻单元运算后, 产生或存储有用的信息</li><li>计算机五大单元: 输入输出单元, 控制单元, 算逻单元, 记忆单元, cpu占有控制, 算逻单元, 记忆单元又包含主存储器与辅助内存</li><li>数据搂入流出是cpu发出的控制指令, cpu处理的数据来着主存储器</li><li>cpu设计理念分为: 精简指令集与复杂指令集</li><li>新的cpu设计中已经将北桥的内存控制芯片整合到cpu中, 而cpu与主存储器, 显示适配器沟通的总线是系统总线, 南桥是I/O总线</li><li>cpu每次能够处理的数据量称为字组大小, 目前有32/64位区分</li><li>一个byte=8bits</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机系统/linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统/linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据模型</title>
      <link href="/2019/11/09/python-shu-ju-mo-xing/"/>
      <url>/2019/11/09/python-shu-ju-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="python-风格"><a href="#python-风格" class="headerlink" title="python 风格"></a>python 风格</h1><ol><li><p>特殊风格</p><ol><li><strong>getitem</strong>方法是实现列表进行选取的方法, 并且还支持切片语法, 并且只要实现了这个方法, 这个对象就变成了可迭代的对象, 实现方式, 返回一个本对象的一个结点</li><li>in运算符是contains方法实现的, 如果没有实现这个方法, 那么in运算符就是按顺序进行一次迭代搜索</li></ol></li><li><p>如何使用特殊风格<br><br>特殊方法的存在是为了被解释器调用的, 不需要自己调用, 也就是你需要len(object)而不是object.len(), 如果是py内置的类型, 如list, str等, cpython的<strong>len</strong>会直接返回pyvarobject中的ob_size属性, pyvarobject是表示内存中长度可变的内置对象的C语言结构体. 速度会快很多.<br>很多时候, 特殊方法的调用是隐式的, 例如for i in xx, 背后使用的是iter(xx)函数, 而iter实现是xx.<strong>iter</strong>()方法, 通过内置的函数, 如len, str来使用特殊方法是最好的选择, 这些内置函数会调用特殊方法, 且对于内置类来说, 他们的速度会更快.</p><ol><li><p>模拟数值类型</p><ol><li>如果一个对象可以获取 obj 的字符串表示, 他需要实现<strong>repr</strong>或者<strong>str</strong>方法, + 为<strong>add</strong>方法, * 为<strong>mul</strong>方法</li></ol></li><li><p>字符串表示形式<br></p><ol><li><strong>repr</strong> 用于生成正式的表示。可以认为是将对象序列化的方法，原则上要能反序列化回对象。</li><li><strong>str</strong> 用于生成非正式的表示。format 或 print 会调用它来为用户生成“友好的”显示。<blockquote><p>str 与repr对比, repr 并不强制生成的字符串可以反序列化</p></blockquote></li></ol><blockquote><p>1.repr 生成的字符串一般用于 debug，所以一般生成的字符串一般要包含尽可能多的信息，信息要尽可能明确(如默认实现里用 ID 区分开两个不同的对象)。</p></blockquote><blockquote><p>2.不要使用 repr 和 eval 来做序列化/反序列化，用 pickle 或 json。<br>3.obj.<strong>str</strong>() 方法会在 print(obj) 或 ‘{}’.format(obj) 时被调用，一般是为了给用户提供 “友好的” 显示，所以 <strong>str</strong> 不像<strong>repr</strong> 那样原则上对返回值有约定，想怎么搞都行。</p></blockquote><blockquote><p>4.另外，<strong>str</strong> 的默认实现是直接调用了 <strong>repr</strong> 方法。因此如果覆盖了 <strong>repr</strong> 方法，<strong>str</strong> 的结果也会随之改变。</p></blockquote><blockquote><p>5.如果只想实现其中的一个方法, <strong>repr</strong>是最好的选择, 如果一个对象没有str方法而需要使用时, 会使用repr代替</p><ol start="3"><li>自定义的布尔值</li><li>默认情况下, 我们自定义的类总是被认为是真的, 除非是对<strong>bool</strong> 或者<strong>len</strong>做了实现, 如果不存在<strong>bool</strong>, 则会调用<strong>len</strong>方法</li></ol></blockquote></li><li><p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html" target="_blank" rel="noopener">特殊方法对照表</a></p></li></ol></li></ol><p>本章代码<br><a href="/file/getitem_len.py">getitem_len</a><br><a href="/file/vector.py">vector</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秦九韶算法详解</title>
      <link href="/2019/11/09/qin-jiu-shao-suan-fa-xiang-jie/"/>
      <url>/2019/11/09/qin-jiu-shao-suan-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>#秦九韶算法<br>秦九韶算法是将一元n次多项式的求值问题转化为n个一次式的算法，比普通计算方式提高了一个数量级<br>普通算式</p><pre><code>a*x^i</code></pre><p>因为多次求幂，消耗了大量的计算时间</p><p>我们来分析一下秦九韶算法<br>例如：</p><pre><code>求1+x+2x^2+3x^3当x=2时的值</code></pre><p>首先我们将系数按照从大到小的方式提出来排列<br>如图所示，我们需要将系数这样排列计算<br>除了第一个值以外，其他的处置我们都在循环内取得，首先我们需要得到第一个值（注明，从第二个循环开始即使用sum结果进行乘积）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">*</span> x <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从第一个数开始每次乘了加上下一个值，然后继续使用结果乘以x加下一个值<br>#下面附上源码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> MAX 10  </span><span class="token comment" spellcheck="true">//只建议十项</span><span class="token keyword">int</span> <span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token keyword">double</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> sum<span class="token punctuation">;</span>    sum <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">*</span> x <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> sum<span class="token punctuation">;</span>    <span class="token keyword">double</span> arr<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入项数(注明,项数为最高项的幂+1):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入从小到大的系数，以空格隔开，没有的用0代替:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//必须反向存</span>        <span class="token punctuation">{</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入乘数x:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.9lf"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
