<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>序列构成的数组</title>
      <link href="/2019/11/12/xu-lie-gou-cheng-de-shu-zu/"/>
      <url>/2019/11/12/xu-lie-gou-cheng-de-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="内置序列类型"><a href="#内置序列类型" class="headerlink" title="内置序列类型"></a>内置序列类型</h1><ol><li><p>python标准库使用c实现了丰富的序列类型</p><ol><li>容器序列:list, tuple, collection.deque这些序列能存放不同类型的数据</li><li>扁平序列:str, bytes, bytesarray, memoryview和array.array, 这种序列只能容纳一种类型<blockquote><p>容器序列存放的是他们所包含的对象的引用, 扁平序列存放的是值, 换句话来说, 扁平序列是一段连续的内存空间</p></blockquote></li><li>可变序列:list, bytesarray, array.array, collections.deque, memoryview</li><li>不可变序列: tuple, str和bytes</li></ol></li><li><p>列表推导和生成器表达式</p><ol><li>列表推导式并不一定比map慢</li><li>在初始化序列类型时, 使用生成器表达式是更好的选择, 生成器表达式遵守了迭代器协议, 可以逐个产生元素, 列表推导式是先建立一个完整的列表, 然后再把这个列表传递到某个构造函数里面, 不够节省内存.</li><li>生成器表达式每次for循环才会生成一个组合, 所以会省掉笛卡尔积的for循环开销</li></ol></li><li><p>元组不仅仅是不可变的列表</p><ol><li>元组和记录: 元组其实是对数据的记录, 元组的每个元素都存放了一个字段的数据, for循环可以自动拆包元组, 迭代过程中, print可以接受一个元组作为参数输入, 拆包让元组当做记录来使用.</li><li>元组拆包可以应用到任何可迭代对象上, 但是可迭代对象的元素必须要跟接受这些元素的元组的空挡数已知</li><li>拆包中对于不定长参数使用*获取, 可以应用与任何位置, 自动对应长度</li><li>python3中函数参数不接受元组型(不接受所有迭代序列, 例如(a, b), [a, b])</li></ol></li><li><p>具名元组</p><ol><li>创建一个具名元组需要两个参数, 一个是类名, 另一个是类的各个字段的名字, 后者可以由数个字符串组成的可迭代对象, 或者是有空格分割开的字段名组成的字符串</li><li>存放在对应字段里的数据要以一串参数的形式传入到构造函数中, 元组的构造函数只接受单一的可迭代对象</li><li>可以通过字段名获取对应位置的字段信息</li><li>具名元组里面可以叠加具名元组, 实现高级数据结构</li><li>具名元组相当于一个类</li><li>重复拼接方法<strong>mul</strong>(n), 生成一个新的对象</li></ol></li><li><p>切片</p><ol><li>切片和区间操作会忽略最后一个元素, 符合以0为开始的风格</li><li>python的内置序列类型都是一维的, 他们只支持单一索引</li><li>如果把切片放在赋值语句的左边, 或者把他作为del操作的对象, 我们就可以对序列进行嫁接, 切除, 或者就地修改等操作</li><li>如果赋值的对象是一个切片, 那么右值必须是一个可迭代序列</li></ol></li><li><p>对序列使用+*</p><ol><li>序列支持+*, 在拼接的过程中, 两个被操作的序列都不回被修改, python会新建一个包含同类型的序列作为拼接的结果</li><li>不要使用[[“_”]] * 3这种语法</li><li>序列增量赋值要实现<strong>iadd</strong>方法, 如果没有实现, 解释器会自动转向<strong>add</strong>方法</li><li>在元组中, 有可变序列时, 需要append而不是直接+=</li></ol></li><li><p>list.sort和内置函数sorted</p><ol><li>list.sort()方法会原地赋值, 返回值为None, 并不会产生新的对象</li><li>sorted可以接受任何可迭代的对象作为参数, 甚至不可变序列或生成器</li><li>reverse和key作为可选关键字, key用于序列中的每一个元素, 作为排序的对比关键字, 比如key=len, 进行基于字符串长度的排序</li></ol></li><li><p>用bisect来管理已排序的序列</p><ol><li>bisect.insort(list, item), 讲一个新的item放入list, 保持有序的同时插入, 函数有返回值, 返回值为在新序列中的位置</li><li>bisect中的方法都有left和right可选, 区别在于放在左边还是右边</li></ol></li><li><p>当列表不是首选时</p><ol><li>数组<ol><li>数组支持所有跟可变序列有关的操作, 还提供从文件读取和存入文件更快的方法, frombytes和tofile方法</li><li>数组只能存放限定类型的数据</li></ol></li><li>内存视图, 看不懂</li><li>双向队列<ol><li>maxlen是可选参数, 固定后不可改变</li><li>对满队列添加元素时会自动删除左端或者右端元素</li><li>deque原子操作, 是线程安全的</li></ol></li></ol></li><li><p>总结</p><ol><li>序列类型分为可变序列和不可变序列, 或者说是扁平序列和容器序列, 扁平序列只能保存原子操作, 容器序列可以保存其他序列, 容器:有些对象包含其他对象的引用.</li><li>对于重复拼接在遇到不可变序列时, 会产生新的序列, 如果遇到可变的会就地修改</li><li>元组存放没有关系的数据</li><li>sorted和list.sort背后的算法是timsort自适应算法, 会根据原始数据的特点交替使用插入排序和归并排序</li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机概论</title>
      <link href="/2019/11/11/ji-suan-ji-gai-lun/"/>
      <url>/2019/11/11/ji-suan-ji-gai-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="数据表示方式"><a href="#数据表示方式" class="headerlink" title="数据表示方式"></a>数据表示方式</h1><h2 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h2><p>在计算机中, 所有的数据都是二进制</p><h2 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h2><p>常用的英文编码都是ascii, 每个符号(英文, 数字, 或符号等)都会占用一个bytes, 总共会有2^8中变化, 目前所使用的Unicode编码系统解决了这个问题</p><h1 id="软件程序运作"><a href="#软件程序运作" class="headerlink" title="软件程序运作"></a>软件程序运作</h1><p>目前计算机都将软件分为两大类, 系统软件和应用程序</p><h2 id="机器程序与编译程序"><a href="#机器程序与编译程序" class="headerlink" title="机器程序与编译程序"></a>机器程序与编译程序</h2><p>cpu具有微指令集, 让cpu帮忙工作必须要参考微指令集, 这个流程包括一下方面</p><ol><li>需要了解机器语言</li><li>需要了解所有硬件的相关功能函数</li><li>程序具有不可移植性, 每个cpu都有独特的微指令集, 同样, 每个硬件都有相关功能函数</li><li>程序具有专一性, 要面对相关硬件来编写</li></ol><p>编译程序做了将高级语言转化为机器语言的功能来完成程序的运行</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统也是一组程序, 这组程序主要来管理计算机以及相关硬件</p><p>操作系统放置在内存中的受保护区域, 开机后一直常驻与内存</p><h2 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h2><p>操作系统除了核心程序之外, 通常会提供开发接口, 就是sc, 开发工程师只需要遵循sc参数开发软件</p><ol><li>操作系统的核心层直接参看硬件规格, 所以同一个操作系统不能再不同硬件平台运作</li><li>操作系统只管理硬件资源, 包括cpu, 内存, 输入输出装置及文件系统文件</li><li>应用程序开发参考操作系统提供开发接口</li></ol><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li>system call interface</li><li>程序管理, 内核控制分配cpu资源   </li><li>内存管理</li><li>文件系统管理</li><li>硬件驱动</li></ol><h2 id="操作系统与驱动程序"><a href="#操作系统与驱动程序" class="headerlink" title="操作系统与驱动程序"></a>操作系统与驱动程序</h2><p>操作系统会提供开发接口给硬件开发商, 根据接口设计驱动程序</p><ol><li>操作系统必须能够驱动硬件, 应用程序才能使用该硬件</li><li>一般来说, 操作系统会提供开发接口</li><li>使用新硬件, 必须安装驱动程序</li><li>驱动程序由开发者提供, 与操作系统开发者无关</li></ol><h1 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h1><p>应用程序是参考操作系统开发接口开发的软件, 达到某些计算机功能</p><p>应用程序与操作系统有关系</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>计算机定义: 接受用户输入指令与数据, 经过中央处理器的算逻单元运算后, 产生或存储有用的信息</li><li>计算机五大单元: 输入输出单元, 控制单元, 算逻单元, 记忆单元, cpu占有控制, 算逻单元, 记忆单元又包含主存储器与辅助内存</li><li>数据搂入流出是cpu发出的控制指令, cpu处理的数据来着主存储器</li><li>cpu设计理念分为: 精简指令集与复杂指令集</li><li>新的cpu设计中已经将北桥的内存控制芯片整合到cpu中, 而cpu与主存储器, 显示适配器沟通的总线是系统总线, 南桥是I/O总线</li><li>cpu每次能够处理的数据量称为字组大小, 目前有32/64位区分</li><li>一个byte=8bits</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机系统/linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统/linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据模型</title>
      <link href="/2019/11/09/python-shu-ju-mo-xing/"/>
      <url>/2019/11/09/python-shu-ju-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="python-风格"><a href="#python-风格" class="headerlink" title="python 风格"></a>python 风格</h1><ol><li><p>特殊风格</p><ol><li><strong>getitem</strong>方法是实现列表进行选取的方法, 并且还支持切片语法, 并且只要实现了这个方法, 这个对象就变成了可迭代的对象, 实现方式, 返回一个本对象的一个结点</li><li>in运算符是contains方法实现的, 如果没有实现这个方法, 那么in运算符就是按顺序进行一次迭代搜索</li></ol></li><li><p>如何使用特殊风格<br><br>特殊方法的存在是为了被解释器调用的, 不需要自己调用, 也就是你需要len(object)而不是object.len(), 如果是py内置的类型, 如list, str等, cpython的<strong>len</strong>会直接返回pyvarobject中的ob_size属性, pyvarobject是表示内存中长度可变的内置对象的C语言结构体. 速度会快很多.<br>很多时候, 特殊方法的调用是隐式的, 例如for i in xx, 背后使用的是iter(xx)函数, 而iter实现是xx.<strong>iter</strong>()方法, 通过内置的函数, 如len, str来使用特殊方法是最好的选择, 这些内置函数会调用特殊方法, 且对于内置类来说, 他们的速度会更快.</p><ol><li><p>模拟数值类型</p><ol><li>如果一个对象可以获取 obj 的字符串表示, 他需要实现<strong>repr</strong>或者<strong>str</strong>方法, + 为<strong>add</strong>方法, * 为<strong>mul</strong>方法</li></ol></li><li><p>字符串表示形式<br></p><ol><li><strong>repr</strong> 用于生成正式的表示。可以认为是将对象序列化的方法，原则上要能反序列化回对象。</li><li><strong>str</strong> 用于生成非正式的表示。format 或 print 会调用它来为用户生成“友好的”显示。<blockquote><p>str 与repr对比, repr 并不强制生成的字符串可以反序列化</p></blockquote></li></ol><blockquote><p>1.repr 生成的字符串一般用于 debug，所以一般生成的字符串一般要包含尽可能多的信息，信息要尽可能明确(如默认实现里用 ID 区分开两个不同的对象)。</p></blockquote><blockquote><p>2.不要使用 repr 和 eval 来做序列化/反序列化，用 pickle 或 json。<br>3.obj.<strong>str</strong>() 方法会在 print(obj) 或 ‘{}’.format(obj) 时被调用，一般是为了给用户提供 “友好的” 显示，所以 <strong>str</strong> 不像<strong>repr</strong> 那样原则上对返回值有约定，想怎么搞都行。</p></blockquote><blockquote><p>4.另外，<strong>str</strong> 的默认实现是直接调用了 <strong>repr</strong> 方法。因此如果覆盖了 <strong>repr</strong> 方法，<strong>str</strong> 的结果也会随之改变。</p></blockquote><blockquote><p>5.如果只想实现其中的一个方法, <strong>repr</strong>是最好的选择, 如果一个对象没有str方法而需要使用时, 会使用repr代替</p><ol start="3"><li>自定义的布尔值</li><li>默认情况下, 我们自定义的类总是被认为是真的, 除非是对<strong>bool</strong> 或者<strong>len</strong>做了实现, 如果不存在<strong>bool</strong>, 则会调用<strong>len</strong>方法</li></ol></blockquote></li><li><p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html" target="_blank" rel="noopener">特殊方法对照表</a></p></li></ol></li></ol><p>本章代码<br><a href="/file/getitem_len.py">getitem_len</a><br><a href="/file/vector.py">vector</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秦九韶算法详解</title>
      <link href="/2019/11/09/qin-jiu-shao-suan-fa-xiang-jie/"/>
      <url>/2019/11/09/qin-jiu-shao-suan-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>#秦九韶算法<br>秦九韶算法是将一元n次多项式的求值问题转化为n个一次式的算法，比普通计算方式提高了一个数量级<br>普通算式</p><pre><code>a*x^i</code></pre><p>因为多次求幂，消耗了大量的计算时间</p><p>我们来分析一下秦九韶算法<br>例如：</p><pre><code>求1+x+2x^2+3x^3当x=2时的值</code></pre><p>首先我们将系数按照从大到小的方式提出来排列<br>如图所示，我们需要将系数这样排列计算<br>除了第一个值以外，其他的处置我们都在循环内取得，首先我们需要得到第一个值（注明，从第二个循环开始即使用sum结果进行乘积）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">*</span> x <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从第一个数开始每次乘了加上下一个值，然后继续使用结果乘以x加下一个值<br>#下面附上源码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> MAX 10  </span><span class="token comment" spellcheck="true">//只建议十项</span><span class="token keyword">int</span> <span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token keyword">double</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> sum<span class="token punctuation">;</span>    sum <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">*</span> x <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> sum<span class="token punctuation">;</span>    <span class="token keyword">double</span> arr<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入项数(注明,项数为最高项的幂+1):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入从小到大的系数，以空格隔开，没有的用0代替:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//必须反向存</span>        <span class="token punctuation">{</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入乘数x:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.9lf"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
