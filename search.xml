<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>装饰器学习</title>
      <link href="/2020/03/20/zhuang-shi-qi-xue-xi/"/>
      <url>/2020/03/20/zhuang-shi-qi-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>写在开头, 昨天参加了一场面试, 可能是疏于使用, 面试官的一道装饰器题目没有写出来, 因此这次我们来翻译一篇python装饰器的文章并结合具体题目来学习装饰器, 原文链接 <a href="https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators" target="_blank" rel="noopener">stackouverflow</a></p><p>题目</p><p><img src="/medias/image_upload/namenode%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png" alt="面试题目"></p><h2 id="装饰器基础"><a href="#装饰器基础" class="headerlink" title="装饰器基础"></a>装饰器基础</h2><p>###　python函数是一个对象<br>想理解装饰器, 就必须先理解python函数也是一个对象, 先看一个例子</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">shout</span><span class="token punctuation">(</span>word <span class="token operator">=</span> <span class="token string">"yes"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> word<span class="token punctuation">.</span>capitalize<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"!"</span><span class="token keyword">print</span><span class="token punctuation">(</span>shout<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># outputs : 'Yes!'</span>scream <span class="token operator">=</span> shout<span class="token keyword">print</span><span class="token punctuation">(</span>scream<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># outputs : 'Yes!'</span><span class="token keyword">del</span> shout<span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>scream<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : "Yes!", 这里的原因是还有弱引用, 去掉后依然可以使用</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>shout<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : name 'shout' is not defined, 原来的函数引用删除, 没有shout, 因此name errors</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个有趣的是python函数能被定义在函数里面</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">talk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">whisper</span><span class="token punctuation">(</span>word <span class="token operator">=</span> <span class="token string">"yes"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> word<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"..."</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>whisper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 你能够调用 "talk", whisper在 talk里面调用</span>talk<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : talk, 但是whisper不能再talk以外使用</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>whisper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : name 'whisper' is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数参考"><a href="#函数参考" class="headerlink" title="函数参考"></a>函数参考</h3><p>你已经熟悉了函数就是一个对象, 因此, 函数:</p><ol><li>能够分配变量</li><li>能够定义其他的函数</li></ol><p>这就意味着<em>一个函数可以返回另一个函数</em></p><p>这并不是解决方案</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> timeredis <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">cache</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">"expensive_action"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">expensive_action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># redis耗时查询</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>        redis<span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">return</span> redis<span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 这里假设redis缓存里面存在, 直接返回</span>    <span class="token keyword">def</span> <span class="token function">not_expensive_action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> redis<span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> key <span class="token operator">==</span> <span class="token string">"expensive_action"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> expensive_action    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> not_expensive_action<span class="token comment" spellcheck="true"># 如何使用他呢, 这里的c也是一个对象</span>c <span class="token operator">=</span> cache<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : &lt;function cache.&lt;locals>.expensive_action at 0x7fb6aec36ef0></span><span class="token comment" spellcheck="true"># 这个对象返回一个函数</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : 1</span><span class="token comment" spellcheck="true"># 也可以这样使用</span><span class="token keyword">print</span><span class="token punctuation">(</span>cache<span class="token punctuation">(</span><span class="token string">"expensive_action"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多的, 你可以添加一个参数,在返回一个函数的时候</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"在调用函数之前做一些事情"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>doSomething<span class="token punctuation">(</span>scream<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : 在调用函数之前做一些事情 \n Yes!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很好, 已经理解了一点装饰器, 装饰器就是一个wrapper(包装), 意味着, <em>你可以在函数调用之前和之后执行任何代码去改变函数自身的行为</em></p><h3 id="手动装饰"><a href="#手动装饰" class="headerlink" title="手动装饰"></a>手动装饰</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 一个装饰器就是函数的参数是另一个函数</span><span class="token keyword">def</span> <span class="token function">my_shiny_new_decorator</span><span class="token punctuation">(</span>a_function_to_decorate<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">the_wrapper_around_the_original_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Before the function runs"</span><span class="token punctuation">)</span>        a_function_to_decorate<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"After the funtion runs"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 此时， 装饰器函数还没有运行</span>    <span class="token comment" spellcheck="true"># 返回wrapper函数</span>    <span class="token keyword">return</span> the_wrapper_around_the_original_function<span class="token keyword">def</span> <span class="token function">a_stand_alone_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"i am a stand function, not modify me "</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 标准运行</span>a_stand_alone_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># i am a stand function, not modify me </span><span class="token comment" spellcheck="true"># 现在可以使用装饰器开扩展函数行为</span>a_stand_alone_decorator <span class="token operator">=</span> my_shiny_new_decorator<span class="token punctuation">(</span>a_stand_alone_func<span class="token punctuation">)</span>a_stand_alone_decorator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : </span><span class="token comment" spellcheck="true"># Before the function runs</span><span class="token comment" spellcheck="true"># i am a stand function, not modify me </span><span class="token comment" spellcheck="true"># After the funtion runs</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="装饰器神秘面纱"><a href="#装饰器神秘面纱" class="headerlink" title="装饰器神秘面纱"></a>装饰器神秘面纱</h3><p>这是之前的例子， 使用装饰器语法</p><pre class="line-numbers language-python"><code class="language-python">@my_shiny_new_decorator<span class="token keyword">def</span> <span class="token function">another_stand_alone_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"leave me alone"</span><span class="token punctuation">)</span>another_stand_alone_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output :</span><span class="token comment" spellcheck="true"># Before the function runs</span><span class="token comment" spellcheck="true"># leave me alone</span><span class="token comment" spellcheck="true"># After the funtion runs</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个简单的例子, <code>@decorator</code>仅仅是这样做了</p><p><code>another_stand_alone_func = my_shiny_new_decorator(another_stand_alone_func)</code></p><p>装饰器仅仅是一个pythonic的变体, 下面是一些例子</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bread</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;/''''''\>"</span><span class="token punctuation">)</span>        func<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;\______/>"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper<span class="token keyword">def</span> <span class="token function">ingredients</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"#tomatoes#"</span><span class="token punctuation">)</span>        func<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"~salad~"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper<span class="token keyword">def</span> <span class="token function">sandwich</span><span class="token punctuation">(</span>food<span class="token operator">=</span><span class="token string">"--ham--"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>food<span class="token punctuation">)</span>sandwich<span class="token punctuation">(</span><span class="token punctuation">)</span>sandwich <span class="token operator">=</span> bread<span class="token punctuation">(</span>ingredients<span class="token punctuation">(</span>sandwich<span class="token punctuation">)</span><span class="token punctuation">)</span>sandwich<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 这个例子就是上面的简写形式, 运行结果一样</span>@bread@ingredients<span class="token keyword">def</span> <span class="token function">sandwich</span><span class="token punctuation">(</span>food<span class="token operator">=</span><span class="token string">"--ham--"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>food<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="装饰器进阶"><a href="#装饰器进阶" class="headerlink" title="装饰器进阶"></a>装饰器进阶</h3><h4 id="将参数传递给函数"><a href="#将参数传递给函数" class="headerlink" title="将参数传递给函数"></a>将参数传递给函数</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I got args! Look: {0}, {1}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">)</span>        func<span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@decorator<span class="token keyword">def</span> <span class="token function">print_full_name</span><span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"My name is {0} {1}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">)</span><span class="token punctuation">)</span>print_full_name<span class="token punctuation">(</span><span class="token string">"ajin"</span><span class="token punctuation">,</span> <span class="token string">"wu"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="装饰方法"><a href="#装饰方法" class="headerlink" title="装饰方法"></a>装饰方法</h4><p>在python中,函数和方法是相同的, 唯一的区别就是方法的第一个参数是self</p><p>这就意味着你可以使用相同的方法来装饰方法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">method_decorator</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lie<span class="token punctuation">)</span><span class="token punctuation">:</span>        lie <span class="token operator">=</span> lie <span class="token operator">-</span> <span class="token number">3</span>        <span class="token keyword">return</span> method<span class="token punctuation">(</span>self<span class="token punctuation">,</span> lie<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper<span class="token keyword">class</span> <span class="token class-name">Lucy</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>    @method_decorator    <span class="token keyword">def</span> <span class="token function">get_age</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lie<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I am {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token punctuation">.</span>age <span class="token operator">+</span> lie<span class="token punctuation">)</span><span class="token punctuation">)</span>Lucy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_age<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想制作一个通用的装饰器, 可以使用参数*args等</p><p>让我们来解决第一个问题</p><pre class="line-numbers language-python"><code class="language-python">redis <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span> i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">cache</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    redis_cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>arg1<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> arg1 <span class="token keyword">in</span> redis_cache<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"using cache"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> redis_cache<span class="token punctuation">[</span>arg1<span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"not using cache"</span><span class="token punctuation">)</span>            redis_cache<span class="token punctuation">[</span>arg1<span class="token punctuation">]</span> <span class="token operator">=</span> arg1            <span class="token keyword">return</span> func<span class="token punctuation">(</span>arg1<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper<span class="token keyword">def</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> redis<span class="token punctuation">[</span>num<span class="token punctuation">]</span>@cache<span class="token keyword">def</span> <span class="token function">expensive_action</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    res <span class="token operator">=</span> doSomething<span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token keyword">return</span> res<span class="token comment" spellcheck="true"># 测试代码</span><span class="token keyword">print</span><span class="token punctuation">(</span>expensive_action<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>expensive_action<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : </span><span class="token comment" spellcheck="true"># not using cache</span><span class="token comment" spellcheck="true"># 4</span><span class="token comment" spellcheck="true"># using cache</span><span class="token comment" spellcheck="true"># 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来看一个有趣的例子</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"========="</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I am an ordinary function"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I am function returned by the decorator"</span><span class="token punctuation">)</span>        func<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper<span class="token keyword">def</span> <span class="token function">lazy_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"zzz"</span><span class="token punctuation">)</span>decorator_func <span class="token operator">=</span> my_decorator<span class="token punctuation">(</span>lazy_func<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># # output : I am an ordinary function, 因为没有调用Wrapper</span>@my_decorator<span class="token keyword">def</span> <span class="token function">lazy_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"zzzz"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># I am an ordinary function, 这句的解释, 函数定义是不会运行的, 但是我们使用了@语法, 因此他会去执行装饰器一次</span><span class="token comment" spellcheck="true"># my_decorator(func)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"1111111"</span><span class="token punctuation">)</span>my_decorator<span class="token punctuation">(</span>lazy_func<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : I am an ordinary function</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"||||||||"</span><span class="token punctuation">)</span>my_decorator<span class="token punctuation">(</span>lazy_func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : 这里相当于在多包装了一层</span><span class="token comment" spellcheck="true"># I am an ordinary function</span><span class="token comment" spellcheck="true"># I am function returned by the decorator</span><span class="token comment" spellcheck="true"># I am function returned by the decorator</span><span class="token comment" spellcheck="true"># zzzz</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"22222"</span><span class="token punctuation">)</span>lazy_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output : </span><span class="token comment" spellcheck="true"># I am function returned by the decorator</span><span class="token comment" spellcheck="true"># zzzz</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原文: It’s exactly the same. “my_decorator” is called. So when you @my_decorator, you are telling Python to call the function ‘labelled by the variable “my_decorator”‘.</p><p>我的理解: 在使用@语法时, 告诉python调用函数来标记func</p><p>下面, 带参数的装饰器</p><pre class="line-numbers language-python"><code class="language-python">c1 <span class="token operator">=</span> <span class="token string">"penc"</span>c2 <span class="token operator">=</span> <span class="token string">"lesi"</span><span class="token keyword">def</span> <span class="token function">decorator_make_with_arg</span><span class="token punctuation">(</span>decorator_arg1<span class="token punctuation">,</span> decorator_arg2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I accept arg:{0}, {1}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>decorator_arg1<span class="token punctuation">,</span> decorator_arg2<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">my_warpper</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"我是装饰器里面的包, 参数:{}, {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>decorator_arg1<span class="token punctuation">,</span> decorator_arg2<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>func_arg1<span class="token punctuation">,</span> func_arg2<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"我是my_Wrapper里面的,我想要装饰器的参数, 装饰器参数是:{}, {},我是最里面的参数, 参数:{}, {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>decorator_arg1<span class="token punctuation">,</span>decorator_arg2<span class="token punctuation">,</span>func_arg1<span class="token punctuation">,</span> func_arg2<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span>func_arg1<span class="token punctuation">,</span> func_arg2<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 这里为什么不加上参数呢, 因为装饰器的缘故, 要在外面加</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> my_warpper@decorator_make_with_arg<span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func1<span class="token punctuation">,</span> func2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"我是decorator函数, 参数是:{},{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>func1<span class="token punctuation">,</span> func2<span class="token punctuation">)</span><span class="token punctuation">)</span>decorator<span class="token punctuation">(</span><span class="token string">"ff"</span><span class="token punctuation">,</span> <span class="token string">"kk"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output :</span><span class="token comment" spellcheck="true"># I accept arg:penc, lesi</span><span class="token comment" spellcheck="true"># 我是装饰器里面的包, 参数:penc, lesi</span><span class="token comment" spellcheck="true"># 我是my_Wrapper里面的,我想要装饰器的参数, 装饰器参数是:penc, lesi,我是最里面的参数, 参数:ff, kk</span><span class="token comment" spellcheck="true"># 我是decorator函数, 参数是:ff,kk</span><span class="token comment" spellcheck="true"># 如果在import之后, 就不能动态设置参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我最后的答案</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> num2<span class="token punctuation">:</span>        <span class="token keyword">return</span> redis<span class="token punctuation">[</span>num1<span class="token punctuation">]</span><span class="token punctuation">,</span> redis<span class="token punctuation">[</span>num2<span class="token punctuation">]</span>    <span class="token keyword">return</span> redis<span class="token punctuation">[</span>num<span class="token punctuation">]</span>redis <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span> i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">cache</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> expires <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">my_warpper</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        redis_cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>fun1 <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> fun2 <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> key<span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>fun1<span class="token operator">=</span>fun1<span class="token punctuation">,</span> fun2<span class="token operator">=</span>fun2<span class="token punctuation">)</span><span class="token punctuation">)</span>            start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>            tmp <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">></span> <span class="token number">3600</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                <span class="token comment" spellcheck="true"># 这里应该写异步方法轮询取得结果</span>                <span class="token keyword">if</span> fun1 <span class="token keyword">in</span> redis_cache<span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"using cache"</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> redis_cache<span class="token punctuation">[</span>fun1<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"not using cache"</span><span class="token punctuation">)</span>                    redis_cache<span class="token punctuation">[</span>fun1<span class="token punctuation">]</span> <span class="token operator">=</span> fun1                    <span class="token keyword">return</span> func<span class="token punctuation">(</span>fun2<span class="token punctuation">)</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> my_warpper@cache<span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">"expensive_action:{fun1}{fun2}"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">expensive_action</span><span class="token punctuation">(</span>fun1<span class="token punctuation">,</span> fun2<span class="token punctuation">)</span><span class="token punctuation">:</span>    res <span class="token operator">=</span> doSomething<span class="token punctuation">(</span>fun1<span class="token punctuation">,</span>fun2<span class="token punctuation">)</span>    <span class="token keyword">return</span> resexpensive_action<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现Java中的比较器</title>
      <link href="/2020/02/09/python-shi-xian-java-zhong-de-bi-jiao-qi/"/>
      <url>/2020/02/09/python-shi-xian-java-zhong-de-bi-jiao-qi/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> cmp_to_key<span class="token keyword">def</span> <span class="token function">reverse_numeric</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x <span class="token operator">-</span> ysorted<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span>cmp_to_key<span class="token punctuation">(</span>reverse_numeric<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上为官方示例 <a href="https://docs.python.org/zh-cn/3/howto/sorting.html#the-old-way-using-the-cmp-parameter" target="_blank" rel="noopener">官方文档示例</a></p><p>个人实现的示例</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> x <span class="token operator">+</span> y <span class="token operator">></span> y <span class="token operator">+</span> x<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">elif</span> x <span class="token operator">+</span> y <span class="token operator">&lt;</span> y <span class="token operator">+</span> x<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>sorted<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"ba"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span>cmp_to_key<span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># res = ["ba", "b"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对象之间的比较</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> id<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>id <span class="token operator">=</span> id        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"name:{}, id:{}, age:{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span>self<span class="token punctuation">.</span>id<span class="token punctuation">,</span>self<span class="token punctuation">.</span>age<span class="token punctuation">)</span>s1 <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">"ajin"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span>s2 <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">"xialin"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">)</span>s3 <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">"xiaoxiao"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">)</span>s4 <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">"feng"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">sortBykey</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> item<span class="token punctuation">.</span>agel <span class="token operator">=</span> <span class="token punctuation">[</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>s3<span class="token punctuation">,</span>s4<span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span>l2 <span class="token operator">=</span> sorted<span class="token punctuation">(</span>l<span class="token punctuation">,</span> key<span class="token operator">=</span>sortBykey<span class="token punctuation">)</span>l3 <span class="token operator">=</span> sorted<span class="token punctuation">(</span>l<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>l3<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意点</p><ol><li><p>operator 模块有 itemgetter() 、 attrgetter() 和 methodcaller() 函数。使用这些可以少些函数</p></li><li><p>python中的排序是默认稳定的</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop小结</title>
      <link href="/2020/01/22/hadoop-xiao-jie/"/>
      <url>/2020/01/22/hadoop-xiao-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>namenode:存储文件元数据,文件名,文件目录结构,文件属性(生成时间,副本数,文件权限等)以及每个文件的块列表和块所在的datanode等</li><li>datanode:在本地文件系统存储文件块数据,以及块数据的校验和</li><li>secondary namenode:用来监控HDFS的状态的辅助后台程序,每隔一段时间获取HDFS元数据的快照</li></ol><h1 id="namenode故障处理"><a href="#namenode故障处理" class="headerlink" title="namenode故障处理"></a>namenode故障处理</h1><ol><li>将SecondaryNameNode中数据拷贝到NameNode存储数据的目录</li><li>使用-importCheckpoint选项启动NameNode守护进程，从而将SecondaryNameNode中数据拷贝到NameNode目录中。</li></ol><h1 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h1><ol><li>集群在启动namenode时会进入安全模式,加载fsimage和edits时不能进行写操作</li><li>在安全模式下datanode会向namenode上报块信息</li><li>安全模式会在满足最小副本条件,即99%的块副本数大于1</li><li>安全模式查看<code>bin/hdfs dfsadmin -safemode get</code></li></ol><h1 id="maptask并行度机制"><a href="#maptask并行度机制" class="headerlink" title="maptask并行度机制"></a>maptask并行度机制</h1><ol><li>一个job的并行度由客户端在提交job时的切片决定</li><li>每一个切片分配一个maptask处理</li><li>默认情况下切片大小等于blocksize</li><li>切片时不考虑整体,而是按照单个文件进行</li></ol><p>Filesplit获取切片信息(主要为文件名)</p><p>CombineTextInputFormat应用于小文件较多的场景下,可以将多个小文件逻辑划分为单个切片,在Driver直接设置(先设置InputFormat为本类)</p><h1 id="FileInputFormat实现类"><a href="#FileInputFormat实现类" class="headerlink" title="FileInputFormat实现类"></a>FileInputFormat实现类</h1><ol><li>TextInputFormat是默认的实现类,按行读取数据,key为偏移量,v为content</li><li>keyValueInputFormat,可以使用分隔符来进行区分</li><li>NLineInputformat,不按照块大小来切分,按照指定的行数来切分,输入文件的总行数/N=切片数，如果不整除，切片数=商+1</li></ol><h1 id="partition分区"><a href="#partition分区" class="headerlink" title="partition分区"></a>partition分区</h1><ol><li>分区的数量表示去往哪个reducetask,reducetask数量是手动设置的</li><li>分区和排序是两个过程,每个分区区内有序</li></ol><h1 id="排序实现在bean内"><a href="#排序实现在bean内" class="headerlink" title="排序实现在bean内"></a>排序实现在bean内</h1><p>CompareTO方法重写,继承自WritableComparable</p><h1 id="Combiner合并"><a href="#Combiner合并" class="headerlink" title="Combiner合并"></a>Combiner合并</h1><ol><li>Combiner的父类是reduce</li><li>Combiner在每个maptask结点运行</li><li>进行的是局部汇总,不能影响全局数据</li></ol><h1 id="GroupingComparator辅助排序"><a href="#GroupingComparator辅助排序" class="headerlink" title="GroupingComparator辅助排序"></a>GroupingComparator辅助排序</h1><ol><li>自定义继承自WritableComparator</li></ol><p><img src="/medias/image_upload/job%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B.png" alt="job提交流程"></p><p><img src="/medias/image_upload/yarn%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="yarn架构图"></p><p><img src="/medias/image_upload/yarn%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E5%9B%BE.png" alt="yarn工作机制图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mapreduce工作流程</title>
      <link href="/2020/01/22/mapreduce-gong-zuo-liu-cheng/"/>
      <url>/2020/01/22/mapreduce-gong-zuo-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p><img src="/medias/image_upload/mapreduce%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png" alt="mapreduce工作流程1"></p><p><img src="/medias/image_upload/mapreduce%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png" alt="mapreduce工作流程2"></p><h1 id="mapreduce工作流程"><a href="#mapreduce工作流程" class="headerlink" title="mapreduce工作流程"></a>mapreduce工作流程</h1><ol><li>客户端submit前会获取待处理数据的信息,根据这些参数会生成一个任务分配规划</li><li>客户端提交切片信息,程序jar包,任务配置</li><li>yarn计算需要启动的maptask的数量</li><li>maptask拿到切片后调用inputformat中的RecordReader将原始数据转换为KV形式</li><li>将kv值交给mapper</li><li>mapper逻辑处理完成后将数据交给outputcollector写入到环形缓冲区shuffle(80%后溢写,默认100M)</li><li>从shuffle阶段的数据做一次全排序,按照key有序</li><li>快速排序完成后溢写到文件</li><li>归并排序为一个文件</li><li>所有maptask任务完成后启动对应数量的reducetask任务</li><li>maptask产生的文件交给reduce</li><li>所有maptask的文件在发生一次归并排序</li><li>进行reduce逻辑</li><li>交给outputformat的recordWriter写入文件</li></ol><blockquote><p>shuffle的大小影响执行效率,原则上大一点会增加执行效率<br>环形缓冲区的优势,无头无尾,都可以写,一边存k,一边存v,方便排序,提高效率 </p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>datanode工作机制</title>
      <link href="/2020/01/22/datanode-gong-zuo-ji-zhi/"/>
      <url>/2020/01/22/datanode-gong-zuo-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="/medias/image_upload/datanode%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png" alt="datanode工作机制"></p><ol><li>datanode首次启动后向namenode注册</li><li>namenode返回注册成功应答</li><li>每周期向namenode上报所以块信息(每小时)</li><li>心跳消息3秒一次,心跳返回结果带有nn给datanode的命令</li><li>超过10分钟没有联系会自动任务不可用 (2*5min(重新检查心跳)+10心跳时间)</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>namenode工作机制</title>
      <link href="/2020/01/22/namenode-gong-zuo-ji-zhi/"/>
      <url>/2020/01/22/namenode-gong-zuo-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p><img src="/medias/image_upload/namenode%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png" alt="namenode工作机制"></p><ol><li>首次启动HDFS,首先加载fsimage,启动前有edits操作,加载完fsimage在执行edits操作, 加载完成后开始交给2nn合并</li><li>新来的增删改请求写给edits,先更新文件,在更新内存</li><li>一直写导致edits较大,2nn每隔一段时间检查是否需要合并(checkpoint),合并时机为距离上一次合并过去多长时间,edits数据已满</li><li>请求合并,将edits和fsimage交给2nn(改名并新建edits文件),2nn先加载fsimage,在执行edits,生成新的fsimage并发给namenode</li><li>edits永远不会删除,fsimage只保留最近的两个</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS读写数据流程</title>
      <link href="/2020/01/22/hdfs-du-xie-shu-ju-liu-cheng/"/>
      <url>/2020/01/22/hdfs-du-xie-shu-ju-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="开局一张图先"><a href="#开局一张图先" class="headerlink" title="开局一张图先"></a>开局一张图先</h1><h2 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h2><p><img src="/medias/image_upload/HDFS%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.png" alt="HDFS写数据流程"></p><ol><li>分布式文件系统是HDFS的一个抽象封装,先发出一个上传请求,namenode判断上传是否合法(文件存在性,上传权限等) </li><li>namenode响应上传,客户端将文件逻辑切分成块大小,开启流对拷</li><li>请求上传第一个block</li><li>namenode返回datanode list(副本数为准,第一个为离客户端最近的,剩下的以第一个为准)</li><li>向第一个datanode发起建立通道请求,收到请求后顺次向剩下的发起建立请求</li><li>最后一个datanode收到请求后顺次应答请求,第一个收到后向客户端应答成功</li><li>传输packet(64k),收到后边写边发向后面的datanode,顺次从后向前发送成功应答(队列发送)</li><li>客户端向HDFS发送完成消息</li><li>namenode加入元数据</li></ol><blockquote><p>建立通道失败,直接失败<br>传输packet失败,第一个失败就失败,其他的失败会触发自动备份<br>返回的datanode通过拓扑距离和机架感知计算</p></blockquote><h2 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h2><p><img src="/medias/image_upload/HDFS%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.png" alt="HDFS读数据流程"></p><p><a href="https://waltyou.github.io/Data-Wirte-Read-In-HDFS/" target="_blank" rel="noopener">个人认为写的好的文章</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统复习</title>
      <link href="/2020/01/07/cao-zuo-xi-tong-fu-xi/"/>
      <url>/2020/01/07/cao-zuo-xi-tong-fu-xi/</url>
      
        <content type="html"><![CDATA[<ol><li><p>操作系统的目标(方便些, 有效性, 可扩充性, 开放性)</p></li><li><p>未配置操作系统的计算机系统</p><ol><li>人工操作方式(用户独占全机, cpu等待人工操作), 人机矛盾, 人工操作方式严重降低了计算机资源的利用率</li><li>脱机输入输出(解决人机矛盾及CPU和IO设计之间速度不匹配的矛盾)(减少了cpu空闲时间,提高了IO速度)</li></ol></li><li><p>单批道处理系统(配置监督程序装入内存),(系统中的资源得不到充分的利用,内存仅有一道程序)</p></li><li><p>多批道处理系统(提交作业放入外存, 排成一个后备队列, 选择若干进入内存)</p><ol><li>资源利用率高, 系统吞吐量大, 平均周转时间长, 无交互能力</li><li>处理机争用问题(利用率), 内存分配与保护问题, IO设备分配问题, 文件组织和管理问题, 作业管理问题, 用户与系统接口问题</li></ol></li><li><p>分时系统</p><ol><li>人机交互(调试), 共享主机(价格)</li><li>等待时间长, 及时接受, 及时处理(作业直接进入内存, 采用轮转运行方式,时间片)</li><li>多路性, 独立性, 及时性, 交互性</li></ol></li><li><p>实时系统</p><ol><li>工业控制系统, 信息查询系统, 多媒体系统, 嵌入式系统</li><li>周期性实时任务(循环,截止时间), 硬实时任务和软实时任务</li></ol></li><li><p>实时分时比较,多路性, 独立性, 及时性, 交互性, 可靠性</p></li><li><p>操作系统基本特征,</p><ol><li>并行和并发(并行是同时, 并发是一段时间)</li><li>共享(资源复用, 互斥共享, 同时访问)</li><li>虚拟(时分复用或空分复用), 时分(虚拟机处理技术,虚拟设备技术), 空分(提高信道利用率)</li><li>异步</li></ol></li><li><p>前驱图和程序执行(有向无环图), 并发执行特征(间断性共享系统资源, 失去封闭性资源状态, 不可再现性)</p></li><li><p>进程的描述</p><ol><li>为使参与并发执行的每个程序都能独立运行, 配置专门的数据结构(进程控制块PCB)</li><li>进程是程序的一次执行</li><li>进程是一个程序机器数据在处理机上顺序执行时所发生的活动</li><li>进程是具有独立功能的程序在一个数据集合上运行的过程</li></ol></li><li><p>进程的特征(动态性(进程的实质就是进程实体的执行过程), 并发性(多个进程实体共存于内存中), 独立性(独立运行调度获得资源的基本单位), 异步性(进程各自独立))</p></li><li><p>进程的三种状态(创建,就绪, 执行, 阻塞, 挂起, 终止)</p></li><li><p>进程同步(是多个相关进程在执行次序上进行协调, 使并发执行的诸进程间按照一定规则共享系统资源), 临界资源(打印机等)</p></li><li><p>临界区,每个进程中访问临界资源的那段代码称为临界区, 互斥访问</p></li><li><p>同步机制遵循规则, 空闲让进, 忙则等待, 有限等待(保证优先时间内能进入自己的临界区), 让权等待(不能进入临界区应立即释放处理机)</p></li><li><p>信号量机制(表示资源)</p><ol><li>整型信号量(原子操作, PV, wait, signal)</li><li>记录型信号量(忙等)</li><li>AND信号量(死锁, 全分配)</li><li>信号量集(Swait(S,1,1))</li></ol></li><li><p>生产者消费者问题</p><ol><li>利用记录型信号量解决问题, 公用缓冲区具有n个缓冲区, 利用互斥信号量metex实现诸进程对缓冲池的互斥使用, 利用empty和full判断空满, 未满进入, 未空取出</li><li>利用AND信号量, Swait(empty, mutex)和Ssignal(mutex, full)</li><li>利用管程解决, 建立管程, put放入, get取出, cwait(condition)和csignal哦按段进程占用阻塞</li></ol></li><li><p>哲学家进餐问题</p><ol><li>记录型信号量, 筷子是临界资源, 对筷子进行互斥访问(死锁)</li><li>AND型信号量, 两只筷子是临界资源</li></ol></li><li><p>线程与进程之间的比较</p><ol><li>调度的基本单位, 进程是独立调度和分派的基本单位,能够独立运行,调度事需要进行上下文切换开销较大, 反之线程开销较小</li><li>并发性, 都具有</li><li>拥有资源, 进程拥有资源, 线程本身不拥有资源, 线程只拥有少量资源, 还允许多个线程共享进程的资源</li><li>独立性, 进程都拥有一个独立的地址空间和其他资源, 除了共享全局变量, 不允许其他进程访问, 线程共享进程的内存地址和资源</li><li>系统开销</li><li>支持多处理机系统, 单进程不管有多少处理机, 该进程只运行在一个处理机上, 对于多线程进程可以将多个线程分配到多个处理机上并发执行</li></ol></li><li><p>处理机调度的层次</p><ol><li>高级调度称为长程调度, 调度对象是作业, 根据某种算法决定将外存上处于后备队列的哪几个作业调入内存</li><li>低级调度称为进程调度, 调度对象是进程, 根据某种算法决定就绪队列中的哪几个进程获得处理机</li><li>中级调度称为内存调度, 提高内存利用率和系统吞吐量</li></ol></li><li><p>计算机死锁,竞争不可抢占性资源引起死锁,竞争可消耗资源引起死锁(等待资源),进程推进顺序不当引起死锁</p></li><li><p>死锁的必要条件和处理方法</p><ol><li>在一组进程发生死锁的情况下, 这组死锁每一个进程都在等待另一个死锁所占有的资源</li><li>互斥条件(资源只能被单个进程使用), 请求和保持条件(等待资源), 不可抢占条件(未用完不能被使用), 循环等待</li><li>预防死锁, 避免死锁, 检测死锁, 解除死锁(撤销进程, 回收资源)</li><li>银行家算法, 必须声明每种资源的最大数目(可利用资源向量, 最大需求矩阵, 分配矩阵, 需求矩阵)</li><li>资源分配图(不会)</li><li>死锁解除算法(抢占资源分配给死锁进程, 终止进程)</li><li>终止进程(全部终止, 逐个终止(按优先级, 进程执行时间还需多少时间, 资源使用数目还需多少资源, 进程是交互式还是批处理))</li></ol></li><li><p>多层结构的存储器系统(寄存器,高速缓存,主存储器,磁盘缓存,固定磁盘,可移动存储介质)</p></li><li><p>程序的链接(源程序经过编译后,可得到一组目标模块后. 链接程序的功能是将这组目标模块以及他们所需要的库函数装配成一个完整的装入模块)</p></li><li><p>静态链接方式,在程序运行之前,先将各目标模块以及他们所需的库函数链接成一个完整的装配模块不在拆开(对相对地址进行修改, 变换外部符号(将每个模块的外部符号也都变换为相对地址,这种先行链接所形成的完整模块又称为可执行文件))</p></li><li><p>装入时动态链接, 在装入一个目标模块时, 若发生一个外部模块调用时间,将引起程序去找出相应的外部目标模块,并装入内存(便于修改和更新,便于实现对目标模块的共享)</p></li><li><p>运行时动态链接, 对某些模块的链接推迟到程序执行时才进行</p></li><li><p>动态分区分配,根据进程的需要,动态的为之分配内存空间</p><ol><li>数据结构,(空闲分区表在系统中设置一张空闲分区表,用于记录每个空闲分区的状况,包括分区号,分区大小,分区地址),(空闲分区链,在每个分区的起始部分设置一些用于控制分区分配的信息以及用于链接各分区所用的前向指针和后向指针)</li><li>分区分配操作,查表,查大小,查多余(是否不可在分配),分配移出链</li><li>回收内存,查找表目,是否前一个相邻,后一个相邻,插入,返回</li><li>基于顺序搜索的动态分区分配算法(首次适应算法, 循环首次适应, 最佳适应, 最坏适应)</li><li>基于索引搜索的动态分区分配算法(快速适应算法, 伙伴系统, 哈希算法)</li></ol></li><li><p>动态重定位分区分配</p><ol><li>紧凑,一个系统或用户程序必须被转入一段连续的内存空间中</li><li>动态重定位,作业装入内存后的所有地址仍然是相对地址,而将相对地址转换为绝对地址的工作被推迟到程序指令要真正执行时进行</li></ol></li><li><p>分页存储管理方式, 离散分配(分页存储管理方式, 分段式存储管理方式,段页式管理方式)</p></li><li><p>虚拟存储器局部性原理(在一段时间内,程序的执行仅局限于某个部分,相应的,他所访问的存储空间也局限于某个区域),(1,程序大部分顺序执行,2,过程调用调用的深度在大多数情况下不超过5,3程序存在许多循环结构,程序中包括许多对数据结构的处理,4程序中对数据结构的处理在很小的范围内, 还有时间局限性(循环)和空间局限性(顺序))</p></li><li><p>虚拟存储器是具有请求调入和置换功能,能从逻辑上对内存容量加以扩充的一种存储器系统,(多次性(只需将当前要运行的那部分程序和数据装入内存即可运行),对换性(在进程运行期间,允许将那些暂不使用的代码和数据从内存调至外存的对换去),虚拟性(能在逻辑上扩冲内存容量))</p></li><li><p>虚拟存储器实现方法</p><ol><li>分页请求系统(在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统),(硬件支持(请求分页的页表机制,在纯分页的页表机制上增加若干项形成,作为请求的数据结构),缺页中断机构(访问页面未调入内存产生中断请求调入),地址变换机构)</li><li>请求分段系统,在分段系统的基础上,增加了请求分段及分段置换功能形成的段式虚拟存储系统</li></ol></li><li><p>内存分配策略</p><ol><li>固定分配局部置换,为每个进程分配一组固定数目的物理块,在进程运行期间不在改变,如果程序运行期间发现缺页,则只能从分配给该进程的n个页面选出一页换出在调入</li><li>可变分配全局置换,先分配一定数目物理块,适当增加减少,发现缺页将保留空闲物理块取出分配</li><li>可变局部局部置换,</li></ol></li><li><p>物理块分配算法</p><ol><li>平均分配算法</li><li>按比例分配算法 m=(页面数/总页面数)*物理块总数</li><li>考虑优先权的分配算法</li></ol></li><li><p>缺页率计算=访问页面失败/(访问页面成功+失败)</p><ol><li>页面大小(页面划分越大,缺页率越低)</li><li>进程所分配的物理块数目越多缺页绿越低</li><li>页面置换算法</li><li>程序固有特性</li><li>缺页中断处理时间 被置换页面被修改概率×缺页中断处理时间 + (1-被置换页面被修改概率)×被置换页面没有被修改的缺页中断时间</li></ol></li><li><p>页面置换算法(不会)</p><ol><li>最佳算法,选择淘汰的是未来很长时间不在使用的</li><li>先进先出,淘汰最老页面</li><li>最久未使用算法</li></ol></li><li><p>IO通道,建立独立的IO的操作不仅使数据的传送独立于CPU, 并且有关IO的组织管理尽量独立</p><ol><li>字节多路类型通道,按字节交叉方式工作的通道, 含有许多未分配子通道, 每个子通道连接一台IO设备,子通道按照时间片轮转方式共享主通道</li><li>数组选择通道, 只有一个,慢</li><li>数组多路通道分时并行</li></ol></li><li><p>中断和陷入</p><ol><li>中断是CPU对IO设备发来的中断信号的一种响应</li><li>陷入CPU内存事件引起的终端叫做陷入</li><li>中断向量表放置中断处理程序的入口地址</li><li>屏蔽中断,嵌套中断</li></ol></li><li><p>中断处理程序</p><ol><li>测定是否有未响应的中断信号</li><li>保护被中断进程的cpu环境</li><li>转入响应设备处理</li><li>中断处理</li><li>恢复cpu现场并退出中断</li></ol></li><li><p>直接存储器访问方式</p><ol><li>数据传输单位是数据块</li><li>传送的数据从块设备送入内存</li><li>仅在传送一个或多个数据块的开始和结束,才需要cpu干预</li></ol></li><li><p>DMA控制器组成(命令/状态控制器CR,内存地址控制器MAR,数据寄存器DR,数据计数器DC)</p></li><li><p>SPOOLing组成(输入井和输出井,输入输出缓冲区,输入输出进程,井管理程序)</p></li><li><p>SPOOLing的特点,提高了IO速度,将独占设备改造为共享设备,实现了虚拟设备功能</p></li><li><p>磁盘访问时间</p><ol><li>寻道时间T=磁盘驱动器速度*磁头移动n条磁道花费时间+启动磁臂时间</li><li>旋转延迟时间</li><li>传输时间T=每次读写字节数/(磁盘每秒转速*一条磁道上字节数)</li></ol></li><li><p>磁盘调度算法</p><ol><li>先来先服务</li><li>最短寻道时间优先</li></ol></li><li><p>文件目录(实现按名存取,提高对目录的检索程度,文件共享,允许文件重名)</p><ol><li>文件控制块是对系统中大量文件进行有效管理, 应包含基本信息(文件名,物理位置,逻辑结构,文件物理结构), 存取控制信息(存取权限)及使用信息</li><li>检索目录文件时只用到文件名,文件索引结点包括(文件主标识符,文件类型,文件存取权限,文件物理地址,文件长度,文件连接计数,文件存取时间),内存索引结点(索引结点编号,状态,访问计数,文件所属文件系统块设备号,链接指针)</li></ol></li><li><p>简单文件目录(逻辑结构和物理结构)</p></li><li><p>外村组织方式</p><ol><li>连续组织方式(顺序访问容易, 顺序访问速度快,容易产生外部碎片,必须事先知道文件长度)</li><li>链接组织方式(分配不连续的磁盘空间通过链接指针链接,消除了外部碎片,插入删除修改很容易,适应文件动态增长)</li><li>索引组织方式</li></ol></li><li><p>FAT技术,文件分配表技术来记录每个文件中给所有盘块之间的链接</p><ol><li>fat12是盘块做基本单位</li><li>fat12的文件簇,簇是一组相邻的扇区</li></ol></li><li><p>NTFS</p><ol><li>以簇为单位</li><li>4K对齐的意思是NTFS磁盘默认簇为4K</li></ol></li><li><p>RAID磁盘冗余阵列</p><ol><li>并行交叉读取</li><li>raid0,只有并行交叉存取,能实现高效传输,一个磁盘坏掉全坏</li><li>raid1,具有磁盘镜像功能,可靠性好, 利用率低</li><li>raid3具有并行传输功能和数据校验功能</li><li>raid5具有独立传送功能,各驱动器都有独立的数据通路,可以独立读写,无校验,纠错的校验信息以螺旋方式散步在所有数据盘</li><li>raid6/7,在6中设置专门的可快速访问的异步校验盘,具有独立的数据访问通路,7是对6的改进,所有磁盘都具有较高的传输速率和优异的性能,最高档次</li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis命令参考</title>
      <link href="/2019/12/29/redis-ming-ling-can-kao/"/>
      <url>/2019/12/29/redis-ming-ling-can-kao/</url>
      
        <content type="html"><![CDATA[<p><a href="http://redisdoc.com/sorted_set/zincrby.html" target="_blank" rel="noopener">redis命令参考</a><br><a href="https://redis-py.readthedocs.io/en/latest/" target="_blank" rel="noopener">redis-python命令参考</a></p><h1 id="redis提供的5中数据结构"><a href="#redis提供的5中数据结构" class="headerlink" title="redis提供的5中数据结构"></a>redis提供的5中数据结构</h1><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td>string</td><td>可以是字符串, 整数, 或者浮点数</td><td>对整个字符串或者字符串中的一部分进行执行操作, 对整数和浮点数执行自增或者自减操作</td></tr><tr><td>list</td><td>一个链表, 链表上的每个结点都包含一个字符串</td><td>从链表的两端推入或者弹出元素, 根据偏移量进行改变, 读取单个或者多个元素; 根据值查找或者移除元素</td></tr><tr><td>set</td><td>无需集合</td><td>添加, 获取, 移除单个元素, 检查是否存在, 计算交并补, 随机读</td></tr><tr><td>hash</td><td>包含键值对的无需散列表</td><td>添加, 获取, 移除单个键值对, 获取所有键值对</td></tr><tr><td>zset</td><td>字符串和浮点数的有序映射</td><td>添加, 获取, 删除单个元素, 根据范围来获取元素</td></tr></tbody></table><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><table><thead><tr><th>命令</th><th>动作</th></tr></thead><tbody><tr><td>get</td><td>获取特定key的值</td></tr><tr><td>set</td><td>设置特定key的值</td></tr><tr><td>del</td><td>删除特定key的值</td></tr></tbody></table><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><table><thead><tr><th>命令</th><th>动作</th></tr></thead><tbody><tr><td>rpush/lpush</td><td>将定值插入key某端</td></tr><tr><td>lrange</td><td>获取范围内的key</td></tr><tr><td>lindex</td><td>获取给定位置的value</td></tr><tr><td>lpop/rpop</td><td>从某端弹出一个value</td></tr><tr><td>lindex</td><td>返回偏移量的元素</td></tr><tr><td>ltrim</td><td>只保留start到end的元素</td></tr></tbody></table><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><table><thead><tr><th>命令</th><th>动作</th></tr></thead><tbody><tr><td>sadd</td><td>添加一个元素进入key, 1成功, 0存在</td></tr><tr><td>smember</td><td>显示所有的元素</td></tr><tr><td>sismember</td><td>是否存在与集合</td></tr><tr><td>srem</td><td>删除</td></tr></tbody></table><h2 id="hash散列表-字典"><a href="#hash散列表-字典" class="headerlink" title="hash散列表(字典)"></a>hash散列表(字典)</h2><table><thead><tr><th>命令</th><th>动作</th></tr></thead><tbody><tr><td>hset</td><td>设置键值对</td></tr><tr><td>hget</td><td>获取键的值</td></tr><tr><td>hgetall</td><td>获取所有键值对</td></tr><tr><td>hdel</td><td>删除键</td></tr></tbody></table><h2 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset(有序集合)"></a>zset(有序集合)</h2><table><thead><tr><th>命令</th><th>动作</th></tr></thead><tbody><tr><td>zadd</td><td>讲一个带有分支的成员添加到有序集合里面</td></tr><tr><td>zrange</td><td>根据元素所在位置获取多个元素</td></tr><tr><td>zrangebyscores</td><td>根据分值范围获取元素</td></tr><tr><td>zrem</td><td>如果存在则删除成员</td></tr></tbody></table><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> redisconn <span class="token operator">=</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span>host <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> port <span class="token operator">=</span> <span class="token number">6379</span><span class="token punctuation">,</span> db <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 阻塞操作, 在等待的时间内如果出现了才会继续操作, 没有数据会直接返回None</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>brpoplpush<span class="token punctuation">(</span><span class="token string">'list'</span><span class="token punctuation">,</span> <span class="token string">'list2'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>lrange<span class="token punctuation">(</span><span class="token string">'list'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>lrange<span class="token punctuation">(</span><span class="token string">'list2'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>sadd<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># set添加</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>smembers<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 返回集合所有成员</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>scard<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 返回集合 key 的基数(集合中元素的数量)。</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>sismember<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 是否存在与集合</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>srandmember<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 整数不重复， 负数会重复</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>srem<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 删除</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>smove<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">,</span> <span class="token string">"set-key2"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 移动</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>smove<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">,</span> <span class="token string">"set-key2"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>smembers<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>smembers<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>smembers<span class="token punctuation">(</span><span class="token string">"set-key2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>sdiff<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">,</span> <span class="token string">"set-key2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 差</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>sinter<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">,</span> <span class="token string">"set-key2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 交</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>sunion<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">,</span> <span class="token string">"set-key2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 并</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>sdiffstore<span class="token punctuation">(</span><span class="token string">"set-key2"</span><span class="token punctuation">,</span> <span class="token string">"set-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 结果放入新集合</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>smembers<span class="token punctuation">(</span><span class="token string">"set-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>smembers<span class="token punctuation">(</span><span class="token string">"set-key2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hset<span class="token punctuation">(</span><span class="token string">"hash-key"</span><span class="token punctuation">,</span><span class="token string">"k"</span><span class="token punctuation">,</span> <span class="token string">"v"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hget<span class="token punctuation">(</span><span class="token string">"hash-key"</span><span class="token punctuation">,</span> <span class="token string">"k"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hgetall<span class="token punctuation">(</span><span class="token string">"hash-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hmset<span class="token punctuation">(</span><span class="token string">"hash-key"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"k1"</span><span class="token punctuation">:</span><span class="token string">"v1"</span><span class="token punctuation">,</span> <span class="token string">"k2"</span><span class="token punctuation">:</span><span class="token string">"v2"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hmget<span class="token punctuation">(</span><span class="token string">"hash-key"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"k"</span><span class="token punctuation">,</span> <span class="token string">"k1"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hlen<span class="token punctuation">(</span><span class="token string">"hash-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hdel<span class="token punctuation">(</span><span class="token string">"hash-key"</span><span class="token punctuation">,</span> <span class="token string">"k"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hgetall<span class="token punctuation">(</span><span class="token string">"hash-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hexists<span class="token punctuation">(</span><span class="token string">"hash-key"</span><span class="token punctuation">,</span> <span class="token string">"k0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hkeys<span class="token punctuation">(</span><span class="token string">"hash-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hvals<span class="token punctuation">(</span><span class="token string">"hash-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span><span class="token string">"counter"</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 自增</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span><span class="token string">"counter"</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hget<span class="token punctuation">(</span><span class="token string">"counter"</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hdel<span class="token punctuation">(</span><span class="token string">"hash-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 添加</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zcard<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># 数量</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zincrby<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 自增</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zscore<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 分值</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zrank<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 排名</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zcount<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 分值范围的总和</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> withscores<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 从小到大排序</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zrevrange<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> withscores<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 返回区间的元素排名, 成员按照分值大到小排列</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zrevrank<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 不理解</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zrangebyscore<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"d"</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token string">"e"</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> withscores<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zremrangebyrank<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 按照分数排名从高到低删除</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span><span class="token string">"zset-key"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> withscores<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">"zset-1"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span>conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">"zset-2"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zunionstore<span class="token punctuation">(</span><span class="token string">"zset-0"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"zset-1"</span><span class="token punctuation">,</span> <span class="token string">"zset-2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span><span class="token string">"zset-0"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> withscores<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pythoner对象</title>
      <link href="/2019/12/27/pythoner-dui-xiang/"/>
      <url>/2019/12/27/pythoner-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h3 id="对象可拆包必须实现iter方法"><a href="#对象可拆包必须实现iter方法" class="headerlink" title="对象可拆包必须实现iter方法"></a>对象可拆包必须实现iter方法</h3><h3 id="self-是init里面定义的self值"><a href="#self-是init里面定义的self值" class="headerlink" title="self 是init里面定义的self值"></a>self 是init里面定义的self值</h3><h3 id="repr是给开发者看的-使用repr-object"><a href="#repr是给开发者看的-使用repr-object" class="headerlink" title="repr是给开发者看的, 使用repr(object)"></a>repr是给开发者看的, 使用repr(object)</h3><h3 id="eq是类实例的等于"><a href="#eq是类实例的等于" class="headerlink" title="eq是类实例的等于"></a>eq是类实例的等于</h3><h2 id="classmethod和staticmethod"><a href="#classmethod和staticmethod" class="headerlink" title="classmethod和staticmethod"></a>classmethod和staticmethod</h2><p>classmethod定义操作类, 而不是操作示例的方法, 改变了调用方法的方式, 传入的第一个参数是类本身, 而不是实例, staticmethod就是普通函数</p><h2 id="获得属性使用-property-类似与obj-x"><a href="#获得属性使用-property-类似与obj-x" class="headerlink" title="获得属性使用@property, 类似与obj.x"></a>获得属性使用@property, 类似与obj.x</h2><h2 id="实现hash可使对象变成可散列的"><a href="#实现hash可使对象变成可散列的" class="headerlink" title="实现hash可使对象变成可散列的"></a>实现hash可使对象变成可散列的</h2><h2 id="名称改写来实现私有变量"><a href="#名称改写来实现私有变量" class="headerlink" title="名称改写来实现私有变量"></a>名称改写来实现私有变量</h2><p>在使用两个下划线命名的属性, 会把属性名存入dict属性中, 并且是<code>_obj__mode</code>这样存储, 但是如果是单个下划线不会做处理</p><h2 id="使用-slots-节省空间"><a href="#使用-slots-节省空间" class="headerlink" title="使用__slots__节省空间"></a>使用<code>__slots__</code>节省空间</h2><ol><li>dict是占用空间的, 但是将属性放入slots后会节省大量空间</li><li>定义slots属性后, 示例不能再由其他名称属性</li><li>如果需要弱引用, 那么就要把<code>__weakref__</code>填入slots</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> array <span class="token keyword">import</span> array<span class="token keyword">import</span> math<span class="token keyword">class</span> <span class="token class-name">Vector2d</span><span class="token punctuation">:</span>    typecode <span class="token operator">=</span> <span class="token string">'d'</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__x <span class="token operator">=</span> float<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>__y <span class="token operator">=</span> float<span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 可迭代, 可拆包</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 这里必须返回的是可迭代的</span>    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        class_name <span class="token operator">=</span> type<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>__name__        <span class="token keyword">return</span> <span class="token string">"{} ({!r}, {!r})"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>class_name<span class="token punctuation">,</span> <span class="token operator">*</span>self<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取分量的提供给format</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 这里显示给用户看的</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token operator">*</span>self<span class="token punctuation">)</span>        <span class="token keyword">return</span> str<span class="token punctuation">(</span>tuple<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__bytes__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">(</span><span class="token punctuation">[</span>ord<span class="token punctuation">(</span>self<span class="token punctuation">.</span>typecode<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token operator">+</span> bytes<span class="token punctuation">(</span>array<span class="token punctuation">(</span>self<span class="token punctuation">.</span>typecode<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> tuple<span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">==</span> tuple<span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__abs__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> math<span class="token punctuation">.</span>hypot<span class="token punctuation">(</span>self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__bool__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> bool<span class="token punctuation">(</span>abs<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__format__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> format_spec <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        compontents <span class="token operator">=</span> <span class="token punctuation">(</span>format<span class="token punctuation">(</span>c<span class="token punctuation">,</span> format_spec<span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> self<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">"({},{})"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token operator">*</span>compontents<span class="token punctuation">)</span>    @property    <span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__x    @property    <span class="token keyword">def</span> <span class="token function">y</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__y    <span class="token keyword">def</span> <span class="token function">__hash__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> hash<span class="token punctuation">(</span>self<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">^</span> hash<span class="token punctuation">(</span>self<span class="token punctuation">.</span>y<span class="token punctuation">)</span>v1 <span class="token operator">=</span> Vector2d<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span>v2 <span class="token operator">=</span> Vector2d<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>v1 <span class="token operator">==</span> v2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>format<span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>set<span class="token punctuation">(</span><span class="token punctuation">[</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象引用</title>
      <link href="/2019/12/27/dui-xiang-yin-yong/"/>
      <url>/2019/12/27/dui-xiang-yin-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="变量不是盒子-是引用"><a href="#变量不是盒子-是引用" class="headerlink" title="变量不是盒子, 是引用"></a>变量不是盒子, 是引用</h1><h1 id="每个变量都有标识-类型和值-对象一旦创建-他的标识绝不会变"><a href="#每个变量都有标识-类型和值-对象一旦创建-他的标识绝不会变" class="headerlink" title="每个变量都有标识, 类型和值, 对象一旦创建, 他的标识绝不会变"></a>每个变量都有标识, 类型和值, 对象一旦创建, 他的标识绝不会变</h1><h1 id="is比较的是变量的标识-id-比较的是值-x-is-not-None"><a href="#is比较的是变量的标识-id-比较的是值-x-is-not-None" class="headerlink" title="is比较的是变量的标识(id), ==比较的是值, x is not None"></a>is比较的是变量的标识(id), ==比较的是值, <code>x is not None</code></h1><h1 id="一般的复制是浅复制-复制的是对象的引用-使用copy-deepcopy才是深复制"><a href="#一般的复制是浅复制-复制的是对象的引用-使用copy-deepcopy才是深复制" class="headerlink" title="一般的复制是浅复制(复制的是对象的引用), 使用copy.deepcopy才是深复制"></a>一般的复制是浅复制(复制的是对象的引用), 使用copy.deepcopy才是深复制</h1><h1 id="当函数的参数作为引用"><a href="#当函数的参数作为引用" class="headerlink" title="当函数的参数作为引用"></a>当函数的参数作为引用</h1><p>参数传递是共享传参, 函数的各个形式参数获的是惨的各个引用的副本, 函数内部的形参是实参的别名, 函数可能会修改作为参数参数传入的可变对象</p><h1 id="避免使用可变的对象作为参数的默认值"><a href="#避免使用可变的对象作为参数的默认值" class="headerlink" title="避免使用可变的对象作为参数的默认值"></a>避免使用可变的对象作为参数的默认值</h1><p>当使用默认的可变参数, 共享传参使用的默认参数, 而且修改了其值, 后续的函数调用会受到影响, 通常使用None来接受可变参数的默认值</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Bus</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> passenger <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>passenger <span class="token operator">=</span> passenger    <span class="token keyword">def</span> <span class="token function">pick</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>passenger<span class="token punctuation">.</span>append<span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">drop</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>passenger<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>name<span class="token punctuation">)</span>bus <span class="token operator">=</span> Bus<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"ajin"</span><span class="token punctuation">,</span> <span class="token string">"xialin"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>bus<span class="token punctuation">.</span>passenger<span class="token punctuation">)</span>bus<span class="token punctuation">.</span>pick<span class="token punctuation">(</span><span class="token string">"xx"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>bus<span class="token punctuation">.</span>passenger<span class="token punctuation">)</span>bus2 <span class="token operator">=</span> Bus<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>bus2<span class="token punctuation">.</span>passenger<span class="token punctuation">)</span>bus2<span class="token punctuation">.</span>pick<span class="token punctuation">(</span><span class="token string">"yy"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>bus2<span class="token punctuation">.</span>passenger<span class="token punctuation">)</span>bus3 <span class="token operator">=</span> Bus<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>bus3<span class="token punctuation">.</span>passenger<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ['ajin', 'xialin']</span><span class="token comment" spellcheck="true"># ['ajin', 'xialin', 'xx']</span><span class="token comment" spellcheck="true"># []</span><span class="token comment" spellcheck="true"># ['yy']</span><span class="token comment" spellcheck="true"># ['yy']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="del和垃圾回收"><a href="#del和垃圾回收" class="headerlink" title="del和垃圾回收"></a>del和垃圾回收</h1><p>del删除的是名称, 不是对象, del可能会导致对象被当做垃圾回收(最后一个变量或者无法得到对象的时候)</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> weakrefs1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>s2 <span class="token operator">=</span> s1<span class="token keyword">def</span> <span class="token function">bye</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span>ender <span class="token operator">=</span> weakref<span class="token punctuation">.</span>finalize<span class="token punctuation">(</span>s1<span class="token punctuation">,</span> bye<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 要有回调函数</span><span class="token keyword">print</span><span class="token punctuation">(</span>ender<span class="token punctuation">.</span>alive<span class="token punctuation">)</span><span class="token keyword">del</span> s1<span class="token keyword">print</span><span class="token punctuation">(</span>ender<span class="token punctuation">.</span>alive<span class="token punctuation">)</span>s2 <span class="token operator">=</span> <span class="token string">"dsf"</span><span class="token keyword">print</span><span class="token punctuation">(</span>ender<span class="token punctuation">.</span>alive<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>弱引用会在改变后立即死亡(书上说还要等一个回合)</p><h1 id="弱引用的局限-tuple返回的也是一个对象的引用-使用字面量创建的是新对象-但是字符串字面量是引用-共享字符串是一种优化措施-称为驻留"><a href="#弱引用的局限-tuple返回的也是一个对象的引用-使用字面量创建的是新对象-但是字符串字面量是引用-共享字符串是一种优化措施-称为驻留" class="headerlink" title="弱引用的局限, tuple返回的也是一个对象的引用, 使用字面量创建的是新对象, 但是字符串字面量是引用, 共享字符串是一种优化措施, 称为驻留"></a>弱引用的局限, tuple返回的也是一个对象的引用, 使用字面量创建的是新对象, 但是字符串字面量是引用, 共享字符串是一种优化措施, 称为驻留</h1><pre class="line-numbers language-python"><code class="language-python">t1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> tuple<span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>t1 <span class="token keyword">is</span> t2<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># True</span>t3 <span class="token operator">=</span> t1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>t1 <span class="token keyword">is</span> t3<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># True</span>s1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>s2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s1 <span class="token keyword">is</span> s2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># True</span>w1 <span class="token operator">=</span> <span class="token string">"ABC"</span>w2 <span class="token operator">=</span> <span class="token string">"ABC"</span><span class="token keyword">print</span><span class="token punctuation">(</span>w1 <span class="token keyword">is</span> w2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数装饰器和闭包</title>
      <link href="/2019/12/27/han-shu-zhuang-shi-qi-he-bi-bao/"/>
      <url>/2019/12/27/han-shu-zhuang-shi-qi-he-bi-bao/</url>
      
        <content type="html"><![CDATA[<h1 id="装饰器基本知识"><a href="#装饰器基本知识" class="headerlink" title="装饰器基本知识"></a>装饰器基本知识</h1><p>装饰器是可调用的对象, 参数是另一个函数(被装饰的函数), 可以将函数返回或者替换</p><h1 id="装饰器调用时机"><a href="#装饰器调用时机" class="headerlink" title="装饰器调用时机"></a>装饰器调用时机</h1><p>在函数定义后就直接运行(加载时即开始运行)</p><p>装饰器返回的函数与通过参数传入的相同</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    series <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">make_average</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 1</span>        series<span class="token punctuation">.</span>append<span class="token punctuation">(</span>new_value<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 2</span>        <span class="token keyword">return</span> sum<span class="token punctuation">(</span>series<span class="token punctuation">)</span> <span class="token operator">/</span> len<span class="token punctuation">(</span>series<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 3</span>    <span class="token keyword">return</span> make_average                     <span class="token comment" spellcheck="true"># 4</span>avg <span class="token operator">=</span> average<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>avg<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 运行顺序 4->1->2->3</span><span class="token keyword">print</span><span class="token punctuation">(</span>avg<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Series变量是一个自由变量, 意思是未在本地作用域绑定的变量(python的变量命名法和作用域), 不可变类型不可以改变其内容, 例如数字, 可变类型可以改变, 如果进行不可变变量更新结果, 会隐式创建一个局部变量</p><h1 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h1><p>nonlocal声明作用是把变量标记为自由变量, 即使在函数中赋予了新值, 也会变成自由变量</p><h1 id="标准库中的装饰器"><a href="#标准库中的装饰器" class="headerlink" title="标准库中的装饰器"></a>标准库中的装饰器</h1><ol><li>functools.wraps(func)装饰器可以处理关键词参数, 并且会将被装饰的name和doc参数复制到里层函数</li><li>functools.lru_cache(maxsize, typed), 这个装饰器可以缓存之前的结果, 用来优化递归等, maxsize指定保存多少个结果, 并且需要是2的幂, typed为True, 会将不同类型的结果分开保存, 使用字段存储结果, 所以被装饰的函数的所有参数也应该是可散列的(原子不可变类型(str, 数值, bytes)都是可散列类型)</li><li>singledispatch装饰器可以实现类似于重载的效果, 具体查文档</li></ol><h1 id="叠加装饰器执行顺序是从内到外"><a href="#叠加装饰器执行顺序是从内到外" class="headerlink" title="叠加装饰器执行顺序是从内到外"></a>叠加装饰器执行顺序是从内到外</h1><h1 id="参数化装饰器"><a href="#参数化装饰器" class="headerlink" title="参数化装饰器"></a>参数化装饰器</h1><p>参数化装饰器后, 装饰器必须作为函数调用(@register())</p><p>如果不适用<code>@</code>语法, 则调用方式为</p><pre class="line-numbers language-python"><code class="language-python">registry <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">register</span><span class="token punctuation">(</span>active <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decorate</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"running register(active=%s) ->decorate(%s)"</span> <span class="token operator">%</span><span class="token punctuation">(</span>active<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> active<span class="token punctuation">:</span>            registry<span class="token punctuation">.</span>add<span class="token punctuation">(</span>func<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            registry<span class="token punctuation">.</span>discard<span class="token punctuation">(</span>func<span class="token punctuation">)</span>        <span class="token keyword">return</span> func    <span class="token keyword">return</span> decorate@register<span class="token punctuation">(</span>active<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"running f1"</span><span class="token punctuation">)</span>@register<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"running f2"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"running f3"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>register<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>f3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>register<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="装饰器金字塔是多包一个外层函数-将实际函数放在中间层-最外层是参数-最里层是函数参数"><a href="#装饰器金字塔是多包一个外层函数-将实际函数放在中间层-最外层是参数-最里层是函数参数" class="headerlink" title="装饰器金字塔是多包一个外层函数, 将实际函数放在中间层, 最外层是参数, 最里层是函数参数"></a>装饰器金字塔是多包一个外层函数, 将实际函数放在中间层, 最外层是参数, 最里层是函数参数</h1><pre class="line-numbers language-python"><code class="language-python">default_fmt <span class="token operator">=</span> <span class="token string">"[{elapsed:0.8f}s] {name}({args}) -> {result}"</span><span class="token keyword">def</span> <span class="token function">clock</span><span class="token punctuation">(</span>fmt <span class="token operator">=</span> default_fmt<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decorate</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">clocked</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            t0 <span class="token operator">=</span> time<span class="token punctuation">.</span>perf_counter<span class="token punctuation">(</span><span class="token punctuation">)</span>            result <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>            elapsed <span class="token operator">=</span> time<span class="token punctuation">.</span>perf_counter<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> t0            name <span class="token operator">=</span> func<span class="token punctuation">.</span>__name__            arg_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> args<span class="token punctuation">:</span>                arg_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>str<span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token keyword">for</span> arg <span class="token keyword">in</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> kwargs<span class="token punctuation">:</span>                pairs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"%s=%r"</span> <span class="token operator">%</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> w<span class="token punctuation">)</span> <span class="token keyword">for</span> k<span class="token punctuation">,</span> w <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>kwargs<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>                arg_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>pairs<span class="token punctuation">)</span><span class="token punctuation">)</span>            arg_str <span class="token operator">=</span> <span class="token string">", "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>arg_list<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token operator">**</span>locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> result        <span class="token keyword">return</span> clocked    <span class="token keyword">return</span> decorate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一等函数</title>
      <link href="/2019/12/21/yi-deng-han-shu/"/>
      <url>/2019/12/21/yi-deng-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="sorted使用"><a href="#sorted使用" class="headerlink" title="sorted使用"></a>sorted使用</h1><ol><li>sorted是没有返回值的</li><li>sorted的key是一个函数, 定义后使用, 例如使用sorted排序列表<code>sorted(s.items(), key=lambda x:x[1])</code></li></ol><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><ol><li>map迭代操作,传入函数和迭代序列, 注意函数必须是输入参数要和迭代序列数量相同,例如<code>list(map(lambda x, y: {x : y}, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))</code>实现zip</li><li>zip <code>dict(zip([1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))</code></li><li>使用map实现<code>{key:value for i in list(map(lambda x, y: {x : y}, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])) for key,value in i.items()}</code></li><li>filter过滤<code>list(filter(lambda x:x%2, range(10)))</code></li><li>reduce规约函数<code>reduce(lambda x,y:x + y, range(100))</code></li></ol><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>lambda 需要的是可调用的函数, 或者自己写, 只需要实现call方法</p><h1 id="号和-号展开"><a href="#号和-号展开" class="headerlink" title="号和*号展开"></a><em>号和*</em>号展开</h1><ol><li>单*号是将多个未命名参数转换成元组传入</li><li>双*号是将字典展开</li></ol><h1 id="提取函数参数"><a href="#提取函数参数" class="headerlink" title="提取函数参数"></a>提取函数参数</h1><ol><li><p>function的<code>__code__.co_varnames</code>属性可以获得所有的变量, 参数在前面</p></li><li><p>function的<code>__code__argcount</code>计算的参数数量</p></li><li><p>使用inspect中的signature来提取函数签名</p></li><li><p>产生signature示例, str后就是参数</p></li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>test2<span class="token punctuation">.</span>__defaults__<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test2<span class="token punctuation">.</span>__code__<span class="token punctuation">.</span>co_varnames<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test2<span class="token punctuation">.</span>__code__<span class="token punctuation">.</span>co_argcount<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>__annotations__<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 提取带有注解的参数</span><span class="token keyword">from</span> inspect <span class="token keyword">import</span> signaturesig <span class="token operator">=</span> signature<span class="token punctuation">(</span>test2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">(</span>sig<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> name<span class="token punctuation">,</span> param <span class="token keyword">in</span> sig<span class="token punctuation">.</span>parameters<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span>kind<span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token string">"="</span><span class="token punctuation">,</span> param<span class="token punctuation">.</span>default<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h1><ol><li>itemgetter, attrgetter, methodcaller都会自行创建函数</li><li>函数冻结, 第一个参数是一个可调用对象, 后面跟着任意个要绑定的定位参数和关键字参数</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> partial<span class="token keyword">from</span> operator <span class="token keyword">import</span> mulpartial <span class="token operator">=</span> partial<span class="token punctuation">(</span>mul<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>partial<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>partial<span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主机规划</title>
      <link href="/2019/12/16/zhu-ji-gui-hua/"/>
      <url>/2019/12/16/zhu-ji-gui-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘链接方式与装置名的关系"><a href="#磁盘链接方式与装置名的关系" class="headerlink" title="磁盘链接方式与装置名的关系"></a>磁盘链接方式与装置名的关系</h1><p>磁盘安装在不同的插槽, 会被自动识别为/dev/sd[a-p]</p><p>在早期的磁盘中, 第一扇区是储存重要信息, MBR格式, 但是大于2T以上的磁盘分区无法让某些操作系统读取, 因此新一种分区格式为GPT</p><h1 id="分区表格式与限制-MBR"><a href="#分区表格式与限制-MBR" class="headerlink" title="分区表格式与限制(MBR)"></a>分区表格式与限制(MBR)</h1><p><del>分区表是将大表的数据分成许多小的子集, 是将分区信息保存在磁盘的第一扇区的64/128字节中, 每个分区占用16个字节, 存有活动状态表示, 文件系统标识, 起止柱面号, 扇区号, 隐含扇区数目(4字节), 分区总扇区数目(4字节)等内容, 这也是MBR分区不能草果4个的原因</del></p><p>MBR(master Boot Record主要开机记录区)来处理开机管理程序与分区表, 通常放在第一扇区(512bytes)</p><ol><li>主要启动记录区:446bytes</li><li>分区表: 记录磁盘分区状态, 64bytes</li></ol><p>如果有四个分区, 则会被识别为sba[1-4]</p><ol><li>分区只是针对64bytes的分区表设定</li><li>磁盘默认分区表仅能写入四组分区信息</li><li>四组分区信息通常称为主分区或扩展分区</li><li>分区槽的最小单位为磁盘柱面</li></ol><p>分区考虑</p><ol><li>数据安全性</li><li>系统效率, 柱面搜索范围</li></ol><p>实际上可以将一个硬盘分区成10个以上的分区槽, 使用扩展分区(利用额外的扇区来记录更多的分区信息)</p><p>实际上扩展分区并不是只占一个区块, 而是会分布在每个分区槽最前面的几个扇区来记在分区信息</p><p>扩展分区的目的是使用额外的分区来记录分区信息, 扩展分区本身不能用来格式化, 我们可以使用扩展分区指向的区块来继续做分区记录, 由扩展分区切出来的分区槽称为逻辑分区</p><ol><li>扩展分区只能有一个</li><li>主分区和扩展分区最多只有四个</li><li>逻辑分区是被扩展分区切割出来的分区槽</li><li>扩展分区无法格式化</li><li>linux中sata硬盘可以突破63个以上的分区限制</li></ol><h1 id="GPT分区表"><a href="#GPT分区表" class="headerlink" title="GPT分区表"></a>GPT分区表</h1><p>在扇区的定义上使用逻辑区块地址(LBA)来处理, 所有区块都以此来规划(预设512bytes), 从0开始</p><ol><li>LBA0(MBR相容区块)<br>与MBR相似的是与之前使用446bytes来储存第一阶段的开机信息, 而在原本的分区表记录区内放入一段特殊标记分区表示GPT格式之意</li><li>GPT分区没有主, 扩展, 逻辑分区的区别</li></ol><h1 id="linux中开机流程的BIOS和uefi开机检测程序"><a href="#linux中开机流程的BIOS和uefi开机检测程序" class="headerlink" title="linux中开机流程的BIOS和uefi开机检测程序"></a>linux中开机流程的BIOS和uefi开机检测程序</h1><p>CMOS是记录各项硬件参数且嵌入到主板上面的存储器, BIOS是写入到硬件的一个软件程序, 是开机执行的第一个程序</p><p>接下来BIOS会寻找能够能够开机的硬盘, 并且到该硬盘去读取第一个扇区的MBR位置, 放有最基本的开机管理程序(如果分区表为GPT, BIOS也能从LBA0的MBR兼容区块读取第一阶段的开机管理程序代码)</p><p>UEFI是由C语言编写, 对于硬件是直接使用驱动程序, 支持多平台, 可编程</p><p>安全启动是uefi加入的, 有些时刻需要关闭才能开机</p><h1 id="恢复linux引导"><a href="#恢复linux引导" class="headerlink" title="恢复linux引导"></a>恢复linux引导</h1><p>找到sysimage,让后<code>chroot /mnt/sysimage  grub2-install /dev/sd?</code></p><h1 id="开启X-Window"><a href="#开启X-Window" class="headerlink" title="开启X-Window"></a>开启X-Window</h1><p><code>startx</code></p><h1 id="系统语言设置"><a href="#系统语言设置" class="headerlink" title="系统语言设置"></a>系统语言设置</h1><pre class="line-numbers language-bash"><code class="language-bash">LANG<span class="token operator">=</span>en_US.utf8<span class="token function">export</span> LC_ALL<span class="token operator">=</span>en_US.utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="分区规划-去参考arch-wiki"><a href="#分区规划-去参考arch-wiki" class="headerlink" title="分区规划(去参考arch wiki)"></a>分区规划(去参考arch wiki)</h1><p>/boot 2GB</p><p>/</p><p>/home</p><p>swap 2G</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机系统/linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统/linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker网络配置</title>
      <link href="/2019/12/10/docker-wang-luo-pei-zhi/"/>
      <url>/2019/12/10/docker-wang-luo-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h1><p>docker网络有六种设备, 对于不同的情景使用最优的设备是最好的选择</p><ol><li>bridge: 桥接网络, 是容器的默认网络, 桥接网络是经常使用在独立容器应用中, 用来通信的网络</li><li>host: 对于独立的容器, 去掉容器和主机之间的网络隔离, 使用主机网络转发, host网络仅可以使用在高于17.06的swarm服务中</li><li>overlay: overlay网络连接不同的docker daemon守护进程, 并且开启swarm服务在每一个docker daemon中通信, 能够使用overlay网络在不同的swarm服务和不同或者相同独立的容器中进行通信, 这个技术消除了操作系统级别的网络需求</li><li>macvlan: 虚拟地址网络允许给容器设置mac地址, 使其作为网络上的物理设备来使用, docker daemon将根据容器的mac地址将流量路由转发到容器</li><li>none: 对于这个容器, 禁用网络, 通常与自定义网络一起使用</li><li>网络插件: 查看dockerhub或者第三方提供商</li></ol><h1 id="网络选择"><a href="#网络选择" class="headerlink" title="网络选择"></a>网络选择</h1><ol><li>桥接网络在同一个主机上的不同容器间进行通信中使用</li><li>主机网路在需要不适用docker网络, 但是需要使用容器时使用(直接使用内网或者公网使用)</li><li>overlay网路在不同的docker主机中进行通信, 或者不同网络应用网络均使用swarm服务</li><li>macvlan网络在迁移容器到其他物理主机使用,使用唯一的mac地址</li><li>第三方网络</li></ol><h1 id="docker-EE-features"><a href="#docker-EE-features" class="headerlink" title="docker EE features"></a>docker EE features</h1><ol><li>相同网络上使用不同的服务, 根据客户机的需求, UCP路由转发到合适的服务上</li><li>对于需要有状态会话的应用程序，会话粘性允许您在HTTP标头中指定UCP用于将后续请求路由到相同服务任务的信息。(机翻)</li></ol><h1 id="使用桥接网络"><a href="#使用桥接网络" class="headerlink" title="使用桥接网络"></a>使用桥接网络</h1><p>桥接网络是链路层设备, 在不同的网络段中转发流量, docker允许连接同一个桥接网络的容器进行通信, 同时隔离没有与桥接网络连接的容器</p><h1 id="用户自定义网桥和默认网桥的区别"><a href="#用户自定义网桥和默认网桥的区别" class="headerlink" title="用户自定义网桥和默认网桥的区别"></a>用户自定义网桥和默认网桥的区别</h1><ol><li>用户自定义的网路在不同的容器间提供了更好的隔离性与互操作性</li></ol><p>容器连接一个桥接网络自动暴露所有的端口对于连接同一个桥接网络, 所有的端口都不暴露出去, 这样使得容器很容易进行通信</p><ol start="2"><li>用户自定义网桥提供了在不同容器间自动dns解析</li></ol><p>容器使用的默认桥接网络只能使用ip地址访问, 除非使用<code>--link</code> 选项, 在用户自定义网络中, 容器可使用别名进行互相解析, 对于很多的容器会增加复杂性, 或者使用hosts也会带来不可以预估的错误</p><ol start="3"><li>可以动态在用户自定义网段中删除或者添加容器</li><li>每一个自定义网段都可以创建配置</li></ol><p>对于使用默认网桥来说, 所有的容器使用一套配置, 重新配置后需要重启docker, 但是用自定义网桥, 可以创建不同的网络配置来满足需求</p><ol start="5"><li>连接默认容器来共享环境变量</li></ol><p>起初只有使用了<code>--like</code>连接了不同容器才能共享环境变量, 但是还有其他方案</p><ol><li>不同容器挂载同一个文件或者目录</li><li>使用docker-compose</li><li>swarm</li></ol><h1 id="管理用户自定义网络"><a href="#管理用户自定义网络" class="headerlink" title="管理用户自定义网络"></a>管理用户自定义网络</h1><p>docker create network –help</p><h2 id="正在运行中的容器进行网络切换"><a href="#正在运行中的容器进行网络切换" class="headerlink" title="正在运行中的容器进行网络切换"></a>正在运行中的容器进行网络切换</h2><pre class="line-numbers language-docker"><code class="language-docker">docker network connect mybr0 my<span class="token punctuation">-</span>nginxdocker network disconnect my<span class="token punctuation">-</span>net my<span class="token punctuation">-</span>nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="ipv6支持"><a href="#ipv6支持" class="headerlink" title="ipv6支持"></a>ipv6支持</h2><p>需要手动开启,创建是加上<code>--ipv6</code>来开启, 但是不能选择在支持ipv6的网桥上禁用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker构建一次性镜像以及缓存问题</title>
      <link href="/2019/12/10/docker-gou-jian-yi-ci-xing-jing-xiang-yi-ji-huan-cun-wen-ti/"/>
      <url>/2019/12/10/docker-gou-jian-yi-ci-xing-jing-xiang-yi-ji-huan-cun-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="通过管道传递dockerfile"><a href="#通过管道传递dockerfile" class="headerlink" title="通过管道传递dockerfile"></a>通过管道传递dockerfile</h1><p>管道中的dockerfile通过stdin可以执行一次性构建在无需在磁盘上构建</p><pre class="line-numbers language-docker"><code class="language-docker">echo <span class="token punctuation">-</span>e <span class="token string">'FROM busybox\nRUN echo "hello world"'</span> <span class="token punctuation">|</span> docker build <span class="token punctuation">-</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-docker"><code class="language-docker">docker build <span class="token punctuation">-</span>&lt;&lt;EOF<span class="token keyword">FROM</span> busybox<span class="token keyword">RUN</span> echo <span class="token string">"hello world"</span>EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="来自stdin构建的的镜像无需发送上下文-其中的连字符用来占据PATH位置-但是如果需要复制文件-这样就会无法找到path"><a href="#来自stdin构建的的镜像无需发送上下文-其中的连字符用来占据PATH位置-但是如果需要复制文件-这样就会无法找到path" class="headerlink" title="来自stdin构建的的镜像无需发送上下文, 其中的连字符用来占据PATH位置, 但是如果需要复制文件, 这样就会无法找到path"></a>来自stdin构建的的镜像无需发送上下文, 其中的连字符用来占据PATH位置, 但是如果需要复制文件, 这样就会无法找到path</h2><h2 id="如果需要复制文件应当使用-f-参数"><a href="#如果需要复制文件应当使用-f-参数" class="headerlink" title="如果需要复制文件应当使用-f-参数"></a>如果需要复制文件应当使用<code>-f-</code>参数</h2><pre class="line-numbers language-docker"><code class="language-docker">docker build <span class="token punctuation">-</span>t myimage<span class="token punctuation">:</span>latest <span class="token punctuation">-</span>f<span class="token punctuation">-</span> . &lt;&lt;EOF<span class="token keyword">FROM</span> busybox<span class="token keyword">COPY</span> somefile.txt .<span class="token keyword">RUN</span> cat /somefile.txtEOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不使用本地文件, 他可以从github拉取文件</p><h1 id="利用缓存构建镜像"><a href="#利用缓存构建镜像" class="headerlink" title="利用缓存构建镜像"></a>利用缓存构建镜像</h1><p>在构建镜像时, docker将顺序执行指令, 在检查每一条指令时, docker会在缓存中查找可重用的镜像, 这符合docker的分层理念.</p><p>如果不想使用缓存时, 可以在构建时加上<code>--no-cache=true</code>来强制构建新镜像, docker匹配遵守下列规则</p><ol><li>从已缓存的父镜像开始, 将下一条指令从基本镜像进行比较, 查看是否是完全相同的命令产生的指令构建</li><li>对于ADD和COPY指令, 将检查镜像中的内容, 并检查文件计算校验和, 不考虑最后修改时间和最后访问时间, 如果文件内容发生了更改, 缓存失效</li><li>除了ADD和COPY以外, 缓存不会检查容器中的更新的文件以确定是否存在缓存, 仅使用命令字符串本身来查找匹配内容</li></ol><p>一旦缓存失效, 所有后续命令都会生成新镜像, 并且不适用缓存</p><h1 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h1><p>安装工具必须首先更新缓存, 安装完成后建议删除缓存rm -rf /var/lib/apt/lists/*</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本与字符序列</title>
      <link href="/2019/12/02/wen-ben-yu-zi-fu-xu-lie/"/>
      <url>/2019/12/02/wen-ben-yu-zi-fu-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="字符问题"><a href="#字符问题" class="headerlink" title="字符问题"></a>字符问题</h1><p>对于字节序列, 可以理解为机器转储, Unicode字符是人类可读的文本</p><p>python3的str类型基本相当于python2的Unicode类型</p><h1 id="字节概要"><a href="#字节概要" class="headerlink" title="字节概要"></a>字节概要</h1><p>python3内置两种基本的二进制序列类型: python3引入的不可变bytes类型和python2.6添加的可变bytearray类型(python2.6的bytes类型是str的别名, 与python3不同)</p><p>bytes及bytesarray对象切片后还是bytes或者bytesarray对象</p><p>bytes也拥有str对象(除了几个)的方法</p><p>解决单个有符号整数<code>int.from_bytes(b'\xfe\xff', 'little', signed=True)</code></p><h1 id="结构体和内存视图"><a href="#结构体和内存视图" class="headerlink" title="结构体和内存视图"></a>结构体和内存视图</h1><p>bytes的解码方式</p><pre class="line-numbers language-python"><code class="language-python">struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">"&lt;hhhhh"</span><span class="token punctuation">,</span>bytes<span class="token punctuation">(</span>b<span class="token string">"\xfe\xff\xff\xff\x00\x00\x01\x00\x02\x00"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他format地址<a href="https://docs.python.org/zh-cn/3/library/struct.html#byte-order-size-and-alignment" target="_blank" rel="noopener">struct</a></p><h1 id="基本的编解码器"><a href="#基本的编解码器" class="headerlink" title="基本的编解码器"></a>基本的编解码器</h1><ol><li>Latin1(即iso8859_1)一种重要的编码, 是其他编码的基础, 例如cp1512和Unicode</li><li>cp1512是微软的latin1超集</li><li>cp437是最初的IBM最初的字符集, 与Latin1不兼容</li><li>gb2312用于编码简体中文的陈旧标准</li><li>utf-8是常见的8位编码, 与ascii兼容</li><li>字节使用decode解码</li><li>字符使用encode编码</li></ol><h1 id="了解编解码问题"><a href="#了解编解码问题" class="headerlink" title="了解编解码问题"></a>了解编解码问题</h1><ol><li>对字符编码时, 可以采用errors=”ignore”或者”replace”来忽略或者替换错误</li><li>cp1252可以解码拉丁文, 他是Latin1的有效超集</li><li>一个检查字符头的哭chardet, 使用chardetect filiname来判断或者在code里面<code>chardet.detect(f.read())</code></li><li>字节序标记即BOM头</li><li>需要在多台设备或者不同平台下运行代码必须要指明编码格式</li><li>除非是进行编码判断, 尽量不要使用二进制打开文本文件</li></ol><h1 id="规范Unicode字符串"><a href="#规范Unicode字符串" class="headerlink" title="规范Unicode字符串"></a>规范Unicode字符串</h1><p>使用unicodedata.normalize函数进行规范化中, NFC, NFD, NFKC, NFKD都可以使用</p><ol><li>NFC使用最少的码位构成等价的字符串, 而NFD是把组合字符分解成基字符和单独的组合字符</li><li>NFKC或者NFKD规范时会导致数据损失</li><li>在大小写折叠中casefold与lower是相同的, 但是<code>μ</code>和<code>β</code>是不同的</li><li>使用nfc对比时是最好的规范化形式, 规范中不区分大小写是应该使用cafeflod</li><li>极端规范化可以将变音符号去掉</li></ol><h1 id="Unicode文本排序"><a href="#Unicode文本排序" class="headerlink" title="Unicode文本排序"></a>Unicode文本排序</h1><ol><li>非ascii文本排序使用的是locale.strxfrm作为key, 但是要这样做必须要设置区域, 不建议这样使用</li><li>使用pyuca可以直接进行排序</li></ol><h1 id="本章代码"><a href="#本章代码" class="headerlink" title="本章代码"></a>本章代码</h1><pre class="line-numbers language-python"><code class="language-python">s <span class="token operator">=</span> <span class="token string">"Café"</span> <span class="token comment" spellcheck="true"># 是四个Unicode字符</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 转换为字节(bytes)对象</span>b <span class="token operator">=</span> s<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 转换为str对象</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span>cafe <span class="token operator">=</span> bytes<span class="token punctuation">(</span><span class="token string">"café"</span><span class="token punctuation">,</span> encoding <span class="token operator">=</span> <span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cafe<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cafe<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 是range(256)以内的整数</span><span class="token comment" spellcheck="true"># print(cafe[-1]) # 还是bytes类型</span><span class="token keyword">print</span><span class="token punctuation">(</span>cafe<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>cafe_arr <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>cafe<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cafe_arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cafe_arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cafe_arr<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">import</span> arraynum <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 有符号整数</span><span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>bytes<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> chardetcity <span class="token operator">=</span> <span class="token string">"São Paulo"</span><span class="token keyword">print</span><span class="token punctuation">(</span>city<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>city<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-16"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>city<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"iso8859_1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>city<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"cp437"</span><span class="token punctuation">,</span> errors <span class="token operator">=</span> <span class="token string">"ignore"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>city<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"cp437"</span><span class="token punctuation">,</span> errors <span class="token operator">=</span> <span class="token string">"replace"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>octes <span class="token operator">=</span> b<span class="token string">"Montr\xe9al"</span><span class="token keyword">print</span><span class="token punctuation">(</span>octes<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"cp1252"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>octes<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"iso8859_7"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>octes<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"koi8_r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"/home/ajin_w/github/record-for-ajin_w/流畅的python/文本和字节序列/编码.py"</span><span class="token punctuation">,</span><span class="token string">"rb"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>chardet<span class="token punctuation">.</span>detect<span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>chardet<span class="token punctuation">.</span>detect<span class="token punctuation">(</span>b<span class="token string">"Montr\xe9al"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> unicodedata <span class="token keyword">import</span> normalizes2 <span class="token operator">=</span> <span class="token string">"cafe\u0301"</span>s1 <span class="token operator">=</span> <span class="token string">"café"</span><span class="token keyword">print</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>normalize<span class="token punctuation">(</span><span class="token string">"NFC"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>normalize<span class="token punctuation">(</span><span class="token string">"NFC"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>normalize<span class="token punctuation">(</span><span class="token string">"NFD"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>normalize<span class="token punctuation">(</span><span class="token string">"NFD"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>normalize<span class="token punctuation">(</span><span class="token string">"NFD"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> len<span class="token punctuation">(</span>normalize<span class="token punctuation">(</span><span class="token string">"NFD"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>micro <span class="token operator">=</span> <span class="token string">"μ"</span><span class="token keyword">from</span> unicodedata <span class="token keyword">import</span> name<span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">(</span>micro<span class="token punctuation">)</span><span class="token punctuation">)</span>micro_cf <span class="token operator">=</span> micro<span class="token punctuation">.</span>casefold<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">(</span>micro_cf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>micro <span class="token operator">==</span> micro_cf<span class="token punctuation">)</span><span class="token keyword">import</span> unicodedata<span class="token keyword">def</span> <span class="token function">shave_marks</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">:</span>    norm_txt <span class="token operator">=</span> normalize<span class="token punctuation">(</span><span class="token string">"NFD"</span><span class="token punctuation">,</span> txt<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 分解基字符和组合记号</span>    shaved <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>c <span class="token keyword">for</span> c <span class="token keyword">in</span> norm_txt <span class="token keyword">if</span> <span class="token operator">not</span> unicodedata<span class="token punctuation">.</span>combining<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 去掉组合记号</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>shaved<span class="token punctuation">)</span>    <span class="token keyword">return</span> normalize<span class="token punctuation">(</span><span class="token string">"NFC"</span><span class="token punctuation">,</span> shaved<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 重新规范化</span><span class="token keyword">print</span><span class="token punctuation">(</span>shave_marks<span class="token punctuation">(</span><span class="token string">"café"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">import</span> localel <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"éac"</span><span class="token punctuation">,</span><span class="token string">"eac"</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>l<span class="token punctuation">,</span> key <span class="token operator">=</span> locale<span class="token punctuation">.</span>strxfrm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">import</span> pyucacoll <span class="token operator">=</span> pyuca<span class="token punctuation">.</span>Collator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>l<span class="token punctuation">,</span> key<span class="token operator">=</span>coll<span class="token punctuation">.</span>sort_key<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文本与字符序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络复习概要</title>
      <link href="/2019/11/28/ji-suan-ji-wang-luo-fu-xi-gai-yao/"/>
      <url>/2019/11/28/ji-suan-ji-wang-luo-fu-xi-gai-yao/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>互联网的核心部分起特殊作用的是路由器. 路由器实现分组交换的关键构件, 其任务是转发收到的分组</p><ol><li><p>电路交换的三个步骤:</p><ol><li>建立连接</li><li>通话</li><li>释放连接;在通话的全部时间内, 通话的两个用户始终占用全部端到端的通信资源</li></ol></li><li><p>分组交换技术的主要特点:</p><ol><li>采用存储转发技术, 我们要发送的整块数据称为一个报文, 发送报文时将报文划分成登场数据段, 加上必要的首部就成了一个分组/包</li><li>位于网络边缘的主机和位于网络核心部分的路由器都是计算机, 主机为用户进行信息处理, 路由器用来转发分组</li><li>路由器收到分组, 暂时存储, 检查其首部, 查找转发表, 检查首部目的地址, 从合适的接口转发出去, 将分组交给下一个路由器</li></ol></li><li><p>分组交换的主要有点</p><ol><li>高效, 在分组传输中动态分配传输贷款, 对通信链路逐段占用</li><li>灵活, 为每一个分组独立的选择最合适的转发路由</li><li>迅速, 以分组为单位, 可以不先建立连接就能向其他主机发送分组</li><li>可靠, 保证可靠性的网络协议, 分布式多路由的分组交换网</li></ol></li><li><p>几种不同的计算机网络</p><p> 作用范围:</p><ol><li><p>广域网(WAN)</p></li><li><p>城域网(MAN), 覆盖范围5-50km, 采用以太网技术</p></li><li><p>局域网(LAN), 范围1km</p></li><li><p>个人区域网(PAN)和无线个人区域网(WPAN)</p><p>按照使用中分类</p></li><li><p>公用网</p></li><li><p>专用网</p></li></ol></li><li><p>计算机网络的性能</p><p> 计算机网络的性能指标</p><ol><li><p>速率: 指数据的传送速率, 也称为数据率或比特率</p></li><li><p>带宽: 在频域中是信号具有的频带宽度, 在时域中网络通道内传送数据的能力</p></li><li><p>吞吐量: 单位时间内通过某个网络的实际数据量</p></li><li><p>时延是指数据(一个报文或者分组)从网络(链路)的一端传送带另一端所需的时间</p><ol><li><p>发送时延: 是主机或路由器发送数据帧所需要的时间, 也叫传输时延, 发送时延=(数据帧长度)/(发送速率)</p></li><li><p>传播时延: 是电磁波在信道中传播一定的距离需要花费的时间, 传播时延=信道长度/电磁波在信道上的传播速率</p><p>电磁波在自由空间的传播速率是光速3<em>10^5Km/s, 在铜线电缆中的传播速率为2.3</em>10^5Km/s, 在光纤中的传播速率为2*10^5Km/s</p><p>发送时延是只在网络适配器内部转发分组的时延, 传播时延在链路中的发送时延</p></li><li><p>处理时延: 是主机或者路由器收到分组是花费一定的时间进行处理(分析首部等)</p></li><li><p>排队时延: 是分组经过网络传输是经过路由器后要先在输入队列中排队等待处理的时延</p></li><li><p>时延带宽积: 是传播时延和带宽相乘, 时延带宽积是指链路的容纳量</p></li><li><p>往返时间RTT, 发送时间=数据长度/发送速率, 有效数据率=数据长度/(发送时间+RTT)</p></li><li><p>利用率有信道利用率和网络利用率, 网络当前时延=网络空闲时的时延/(1 - 利用率)</p></li></ol></li></ol></li><li><p>计算机网络</p><ol><li><p>协议与划分层次</p><p>  网络协议是为进行网络中的数据交换而建立规则,标准或约定</p><ol><li>语法, 即数据与控制信息的结构或格式</li><li>语义, 即需要发出何种控制信息, 完成何种动作以及做出何种响应</li><li>同步, 即事件实现顺序的详细说明</li></ol></li><li><p>网络层次</p><ol><li><p>各层是独立的. 不需要知道他的下一层是如何实现的, 只需要通过层间的接口提供服务</p></li><li><p>灵活性好, 当某一层发生变化时, 只要层间接口关系不便, 各层均不受影响</p></li><li><p>结构上可分割开, 各层采用最适合的技术来实现</p></li><li><p>易于实现和维护, 能够实现和调试一个庞大而又复杂的系统变得易于处理</p></li><li><p>能促进标准化工作</p><p>通常各层需要完成的功能</p><ol><li>差错控制</li><li>流量控制</li><li>分段和重装</li><li>复用和分用</li><li>连接建立和释放</li></ol></li></ol></li><li><p>具有五层协议的体系结构</p><p>  OSI参考模型具有七层体系结构, 物理层, 数据链路层, 数据链路层, 网路层, 传输层, 会话层, 表示层, 应用层<a href="https://zh.wikipedia.org/zh-hans/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI参考模型</a></p><p>  TCP/IP参考模型, 链路层, 网络层, 传输层, 应用层</p><p>  五层参考模型</p><ol><li><p>应用层, 通过应用进程间的交互来完成特定网络应用, 交互数据单元称为报文</p></li><li><p>运输层, 负责向两台主机中的进程之间的通信提供数据传输服务, 并不指定某个特定层网络应用, 多种应用都可以使用同一个运输层服务, 因此有复用和分用的功能, 复用是指多个应用同时使用运输层服务, 分用是运输层收到的信息分别交付到应用层中的相应进程</p><ol><li>transmission Control protocol协议—-提供面向连接的, 可靠的数据传输服务, 数据传输单位是报文段</li><li>User Datagram protocol协议—-提供无连接的,尽力的数据传输服务, 数据传输单位是用户数据报</li></ol></li><li><p>网络层, 为分组交换网上的不同主机提供通信服务, 将运输层产生的报文段或用户数据报封装成分组或包进行传送, 分组也称IP数据报, 另一个任务是将源主机运输层传下来的分组通过网络中的路由器找到目的主机</p></li><li><p>数据链路层, 数据链路层将网络层交下来的网络IP数据报组装成帧, 在相邻结点链路上传送帧, 每一帧包括数据和必要的控制信息(如同步信息等)</p></li><li><p>物理层, 光纤等</p><p>人们经常提到的TCP/IP并不一定是指这两个具体协议, 往往是整个TCP/IP协议族</p></li></ol></li><li><p>实体, 协议, 服务和服务访问点</p><p>  协议是控制两个对等实体(或多个)进行通信的规则的集合</p><p>  在协议的控制下, 两个对等实体间的通信是的本层能够向上一层提供服务, 要实现本层协议还需要实现下面一层所提供的服务</p><p>  协议是水平的, 服务是垂直的, 上层使用下层提供的服务必须通过与下一层交换命令(服务原语)</p><p>  TCP/IP协议可以为各式各样的应用提供服务, 同时TCP/IP协议也允许IP协议在各式各样的网络构成的互联网上运行</p></li></ol></li></ol><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>物理层在计算机内部多采用并行传输方式, 但数据在通信线路上采用串行传输</p><p>一个数据通信系统可以划分为源系统, 传输系统, 目的系统</p><ol><li>源系统<ol><li>源点, 信号源</li><li>发送器, 通常源点生成的数字比特流要通过发送器编码后才能在传输系统进行传输, 典型的发送器是调制器, 很多计算机使用内置的调制解调器</li><li>接收器, 解调器</li><li>终点, 屏幕等</li></ol></li><li>信号<ol><li>模拟信号, 或连续信号, 调制解调器到电话局之间的用户线</li><li>数字信号, 或离散信号, 计算机到调制解调器</li></ol></li></ol><h2 id="信道基本概念"><a href="#信道基本概念" class="headerlink" title="信道基本概念"></a>信道基本概念</h2><ol><li>单向通信, 单工通信</li><li>双向交替通信, 半双工通信</li><li>双向同时通信, 全双工通信</li></ol><blockquote><p>来自信源的信号称为基带信号, 计算机输出的代表各种文字或图像文件的数据信号都属于基带信号, 基带信号中往往包含较多的低频成分, 甚至有直流成分, 因此需要对基带信号进行调制解调</p></blockquote><blockquote><p>调制可分为两类, 一种是仅对基带信号的波形进行变换, 使他能与信道特性相适应, 变换后的信号还是基带信号, 这类调制称为<code>基带调制</code>, 另一类调制需要使用载波进行调制, 把基带信号的频率范围搬移到较高的频段, bin转换为模拟信号, 进过载波的信号称为<code>带通信号调制</code></p></blockquote><ol><li><p>常用编码方式</p><ol><li>不归零值, 正电平为1, 负电平为0</li><li>归零制, 正脉冲为代表1, 负脉冲为0</li><li>曼彻斯特编码, 周期内向上跳的代表0, 向下跳代表1</li><li>差分曼彻斯特编码, 在每一位中心处始终有跳变, 位开始边界有跳变代表0，而位开始边界没有跳变代表1。</li></ol></li><li><p>基本的带通调制方法</p><ol><li>调幅(AM) 载波的振幅随基带数字信号而变化</li><li>调频(FM) 载波的频率随基带数字信号而变化</li><li>调相(PM) 载波的初始相位随基带数字信号而变化</li></ol></li><li><p>信噪比 = 10 log 10(s/n)</p></li></ol><p>香农公式: 信道的极限信息传输速率是 C = W log2(1 + s/N)(bit/s), w是信道的带宽(以hz为单位), S为信道内所传信号的平均功率, N为信道内部的高斯噪声功率</p><p>信道的带宽或信道中的信噪比越大, 信息的极限传输速率就越高, 用编码的方法让每一个码元携带更多比特的信息量</p><h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><ol><li>导引型媒体<ol><li>双绞线</li><li>同轴电缆</li><li>光缆, 传输损耗小, 中继距离长, 抗干扰强, 保密性好, 体积轻</li></ol></li></ol><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ol><li>频分复用, 时分复用和统计时分复用<ol><li>频分复用是所有用户在同样的时间占用不同的带宽(频率带宽)资源</li><li>时分复用的所有用户在不同的时间占用相同的频带宽度, 时分复用则有利于数字信号的传输</li></ol></li><li>波分复用是光的频分复用</li><li>码分复用: 每一个用户可以在同样的时间使用同样的频带进行通信, 由于各用户使用不同码型, 因此各用户之间不会造成干扰, 其频谱类似与白噪声, 不易被发现</li></ol><h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><ol><li>ADSL技术, 非对称数字用户线, 是用数字技术对现有的模拟电话用户线进行改造, 是他能承载宽带数字业务</li><li>光纤同轴混合网(HFC网)</li><li>FTTx技术, 光纤到户技术</li></ol><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>数据链路层属于计算机网络的低层</p><ol><li>点对点通道, 这种通道使用一对一的点对点通信方式</li><li>广播信道, 这种信道使用一对多的广播通信方式</li></ol><h2 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h2><ol><li>数据链路和帧<ol><li>链路就是一个结点到相邻结点的一段物理线路(有线或无线)</li><li>数据链路是另一个概念, 在一条线路上传送数据时, 除了一条必须的物理链路外, 还需要包括必要的通信协议来控制这些数据的传输才构成了数据链路, 现在最常用的方法是使用网络适配器来实现这些协议, 一般的适配器都包括了数据链路层和物理层这两层功能</li></ol></li><li>帧<ol><li>数据链路层将网络层交下来的数据构成帧发送到链路上, 以及把收到的帧中的数据取出在上交到网络层, 网络层协议数据单元是IP数据报</li></ol></li><li>三个基本问题<ol><li>封装成帧是在一段数据的前后加上首部和尾部, 首部和尾部的一个重要作用是帧定界, 为了提高数据传输速率, 帧的数据部分长度应尽可能的大于首部和尾部的长度, 每一种链路层协议所能传送的帧的数据部分长度上线为最大传送单元MTU</li><li>透明传输, 由于帧的开始就结束的标记使用专门的控制字符, 因此所传输任何8比特组合总一定不允许和用作帧定界的控制字符比特编码相同, 在数据链路层透明传输表示无论什么样的比特组合的数据都能够原样无差错的通过数据链路层, 因此, 对于所传送的数据来说, 这些数据就看不见数据链路层有什么妨碍数据传输的东西(转义字符)</li><li>差错检测, 传输错误的比特总数站所传输比特总数的比率称为误码率, 信噪比越高误码率越小(循环冗余校验)<ol><li>循环冗余检验, 帧检验序列FCS是帧检验序列, 一般使用冗余检验法是模二运算, 异或运算, 发送的FCS是M + FCS(余数)</li><li>如果帧无差错, 将每一帧都除以除数, 余数为0</li><li>凡是被接收端数据链路层接受的帧均无差错</li><li>数据链路层没有提供可靠传输服务</li><li>在CRC上加上了帧编号, 确认和重传机制, 对于质量较好的有线传输线路, 不适用确认和重传机制</li></ol></li></ol></li></ol><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><p>PPP协议满足的需求</p><ol><li>简单, 只进行封装校验</li><li>封装成帧</li><li>透明性</li><li>多种网络协议</li><li>多种类型链路</li><li>差错检测</li><li>检测连接状态</li><li>最大传送单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ol><p>只支持点对点链路通信, 只支持全双工链路</p><p>协议的组成</p><ol><li>将IP数据报封装到串行链路的方法, PPP既支持异步链路(无奇偶校验的8比特数据), 也支持面向比特的同步链路</li><li>一个用来建立配置和测试数据链路连接的链路控制协议LCP</li><li>一套网络控制协议NCP, 其中每一个协议支持不同的网络层协议</li></ol><p>PPP协议帧格式<br><img src="https://img-blog.csdn.net/20160204105742700" alt="PPP协议帧格式"></p><ol><li>首部的第一个字段和尾部第二字段都是标志字段, 字段A和C没有携带帧信息,第四个字段是协议字段, 当协议字段是0x0021时, ppp帧信息字段是IP数据报, 若为0xC021是ppp链路协议的LCP数据, 0x8021是控制数据</li><li>字节填充<ol><li>将信息字段中的每一个0x7E 字节转变为2字节序列(0x7D, 0x5E)</li><li>若信息中出现了一个0x7D字节, 转变为(0x7D,0x5D)</li><li>若信息字段中出现小于0x20字符, 则在字符前加入一个0x7D字节, 同时改变编码</li></ol></li><li>零比特填充, 在使用SONET/SDH链路使用同步传输时, 只要发现连续5个一,则立即加入一个0</li></ol><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><ol><li><p>局域网的数据链路层</p><p>网络为一个单位所有, 且地理范围和站点数目均有限</p><ol><li>具有广播功能</li><li>便于系统的扩展和逐渐演变, 各设备的位置可灵活调整和改变</li><li>提高了系统的可靠性, 可用性, 生存性</li></ol></li></ol><p>分类,星形网, 总线网, 环形网, 总线网中以太网最为出名</p><ol start="2"><li><p>以太网标准<br>数据链路层被拆分为两层, 逻辑链路控制层LLC, 媒体接入控制MAC</p></li><li><p>适配器作用: 进行数据串行传输和并行传输的转换</p></li><li><p>CSMA/CD, 载波监听多点接入/碰撞检测</p><ol><li>采用无连接的方式, 尽最大努力交付, 重传也当做新的数据帧</li><li>曼彻斯特编码</li><li>载波监听是检测信道, 每个站都必须不停检测信道</li><li>碰撞检测也就是边发边听</li><li>一个站不可能同时进行发送和接收</li><li>争用期是值以太网在发送数据帧后至多经过两个时间, 又称碰撞窗口, 经过争用期还没有检测到碰撞才能肯定这次发送没有发生碰撞</li><li>以太网使用截断二进制指数退避算法, 发生碰撞后不是等待信道空闲后立即重发, 而是推迟一个最忌时间, 若连续多次发生冲突, 使用此算法可以使重传需要推迟的平均时间随重传次数二增大(动态退避)</li></ol></li><li><p>使用集线器的星形拓扑</p><ol><li>使用集线器的以太网逻辑上仍是总线网, 使用的还是CSMA/CD协议</li><li>一个集线器有许多接口</li><li>集线器工作在物理层, 每个接口仅简单转发比特不进行检测</li></ol></li><li><p>以太网的MAC层</p></li><li><p>硬件地址又称MAC地址, 固化在适配器ROM中的地址</p></li></ol><p>mac帧由五个字段组成, 前两段分别为6字节长的目的地址和原地址地址, 第三个字段是类型字段</p><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><p>最初是网桥, 对收到的帧进行转发和过滤, 交换式集线器称为以太网交换机</p><ol><li>实质是多接口网桥, 每个接口都直接与单台主机或另一个以太网交换机相连, 还具有并行性, 链接多个主机同时通信</li><li>相互通信的主机都是独占传输媒体, 无碰撞的传输数据</li></ol><h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>100BASE-T 以太网, 使用IEEE802.3CSMA/CD协议, IEE802.3u<br>吉比特以太网IEE802.3z<br>10吉比特以太网和更快地以太网IEE802.3an</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>##　网络层提供的两种服务<br>网络层向上只提供简单灵活的，无连接的尽最大努力交付的数据报服务</p><p>虚电路服务和数据报服务的对比<br>对比的方面 | 虚电路服务 | 数据报服务<br>— | — | —-<br>思路|可靠通信应当由网络来保证|可靠通信应该由用户主机来保证<br>连接的建立 | 必须有 | 不需要<br>终点的地址 | 仅在连接建立阶段使用, 每个分组使用短的虚电路好 | 每个端点都有终点的完整地址<br>分组的转发 | 属于同一虚电路的分组按照同意路由转发 | 每个分组独立选择路由进行转发<br>结点故障 | 均失败 | 丢失分组<br>分组顺序 | 按序到达 | 无序<br>差错控制流量控制 | 由网络或者用户主机负责 | 由用户主机负责</p><h2 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h2><p>与IP协议配套的协议还有三个协议</p><ol><li>地址解析协议ARP, 反向的RARP逆地址解析协议</li><li>网际控制报文协议ICMP</li><li>网际组管理协议IGMP</li></ol><h3 id="虚电路互连网络"><a href="#虚电路互连网络" class="headerlink" title="虚电路互连网络"></a>虚电路互连网络</h3><p>将网络互连起来的设备要使用一些中间设备</p><ol><li>物理层使用的中间设备叫做转发器</li><li>数据链路层使用的中间设备叫做网桥</li><li>网络层使用的中间设备叫做路由器</li><li>在网络层以上使用的中间设备叫做网关, 用网关连接两个不兼容的系统需要在高层进行协议的转换</li></ol><p>当中间设备是装阿奇或网桥, 这仅仅是扩大一个网络, 这仍然是一个网络, 并不是网络互连</p><p>互联网可以由多种易购网络互连组成</p><h3 id="分类ip地址"><a href="#分类ip地址" class="headerlink" title="分类ip地址"></a>分类ip地址</h3><p>IP地址由两个长度的字段组成, 第一个字段是网络号, 标志主机(或路由器)所连接到的网络, 一个网络号在整个互联网范围内是必须是唯一的, 第二个字段是主机号, 标志主机</p><p>A类B类C类地址的网络号字段分别为一个, 两个, 三个字节长<br>D类地址(前四位1110)用于多播<br>E类地址(前四位1111)保留以后用</p><p>A类地址网络号占一个字节,只有7位可供使用, 可使用的网络好为(2^7 - 2), 一个是全0地址, 代表网络本身. 一个是127保留作为本地软件环回测试主机间进程使用</p><p>A类地址主机号占三个字节, 每一个A类网络最大主机数为(2^24 -2): 全0的表示表示网络地址, 全1的表示网络上的所有主机</p><p>B类地址可指派的网络数为2^14 -1个, 最大主机数为2^16 - 2个</p><h3 id="ip地址与硬件地址"><a href="#ip地址与硬件地址" class="headerlink" title="ip地址与硬件地址"></a>ip地址与硬件地址</h3><p>物理地址是数据链路层和物理层使用的地址, IP地址是网络层和以上各层使用的地址, 是一种逻辑地址</p><p>IP地址放在IP数据报的首部, 硬件地址放在mac帧的首部, 在网络层和网络层以上使用的是ip地址, 数据链路层及一下使用的是链路地址</p><ol><li>在ip抽象的互联网上只能看见IP数据报</li><li>路由器只根据目的站的ip地址的网络号进行路由选择</li><li>在局域网的链路层, 只能看见mac帧</li><li>隐藏细节</li></ol><h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><p>ARP是在主机ARP高速缓存中存放一个IP地址到硬件地址的映射表, 并且实时更新</p><p>广播请求分组</p><h2 id="ip数据报格式"><a href="#ip数据报格式" class="headerlink" title="ip数据报格式"></a>ip数据报格式</h2><ol><li><p>固定首部</p><ol><li><p>版本号4位, 协议版本ipv?</p></li><li><p>首部长度4位, 表示最大十进制数值为15字节, 最常用的首部长度为20字节(即0101)</p></li><li><p>区分服务8位, 一般不使用</p></li><li><p>总长度值首部和数据数据之和的长度, 单位为字节, 总长度为16位, 数据报最大长度为2^16 - 1字节</p><blockquote><p>IP协议规定, 所有的主机路由必须能够接受长度不超过576字节的数据报, 超过时需要分片</p></blockquote></li><li><p>标识16位, 作为计数器, 产生一个数据报就加1, ip作为无连接服务不存在按序接收,用来重组数据报, 在分片时这个标识字段复制给所有的数据报标识字段</p></li><li><p>标志3位, 只有两位有意义</p><ol><li>最低位字段为MF,MF=1 标识后面还有分片的数据报,MF=0 标识是若干数据报片中的最后一个</li><li>中间一位为DF, 标识不能分片, 当DF=0才允许分片</li></ol></li><li><p>片偏移13位, 分片后在原分组的相对位置</p></li><li><p>生存时间8位, 防止无法转发的, 每经过一个路由器就把TTL减去数据报在路由器消耗的时间, 小于一就减一,现在是跳数限制</p></li><li><p>协议8位,例如ICMP</p></li><li><p>首部校验和16位, 只校验数据报的首部, 先把IP数据报首部划分为16字节的序列, 校验和字段设为0, 算数运算想加所有的, 写入到检验和字段, 接收方收到后把所有的16字节使用运算相加后取反码, 未发生变化结果为0</p></li><li><p>源地址</p></li><li><p>目的地址</p></li></ol></li></ol><h2 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h2><ol><li><p>划分子网</p><ol><li>ip地址空间利用率不合理</li><li>给每一个物理网络分配一个网络号会使路由表变的太大, 互联网中的网络越多, 路由器中的路由表项目数越多, 也会导致路由器成本变高</li><li>两级IP地址不灵活</li></ol></li><li><p>划分子网的思路与</p><ol><li>一个拥有许多物理网络的单位, 可将所属的网络划分成若干子网, 划分子网是单位内部的, 单位以外的看不见, 只表现一个物理网络</li><li>从主机网络号借用若干位做子网号</li></ol></li><li><p>子网掩码, 用来确定网络划分</p><ol><li>把三级ip地址和收到的数据报目的地址按位与就能得出子网的网络地址</li></ol></li><li><p>使用子网时分组的转发</p><ol><li>路由表必须包含: 目的网络地址, 子网掩码, 下一跳地址</li><li>相与之后的结果如果不在路由表, 继续将结果再次相与</li></ol></li><li><p>无分类编址CIDR(构造超网)</p><ol><li>消除了传统A类等划分子网的概念</li><li>将32位IP地址分为前后两部分, 前面部分是网络前缀,后面部分指主机</li><li>使用斜线记法,IP地址后面加上斜线,然后协商网络前缀所占的位数</li><li>CIDR使用32为的地址掩码,也可称为子网掩码,斜线表示1的个数</li><li>最长前缀匹配</li></ol></li></ol><h2 id="网际控制报文协议"><a href="#网际控制报文协议" class="headerlink" title="网际控制报文协议"></a>网际控制报文协议</h2><p>允许主机或路由器报告差错</p><ol><li>种类<ol><li>ICMP差错报告报文</li><li>ICMP询问报文</li></ol></li></ol><p>统一三个字段: 类型, 代码和校验和</p><table><thead><tr><th>ICMP报文种类</th><th>类型值</th><th>ICMP报文类型</th></tr></thead><tbody><tr><td>差错报告报文</td><td>3</td><td>终点不可达</td></tr><tr><td>–</td><td>11</td><td>时间超过</td></tr><tr><td>–</td><td>12</td><td>参数问题</td></tr><tr><td>–</td><td>5</td><td>改变路由</td></tr><tr><td>询问报文</td><td>8/0</td><td>回送请求或应答</td></tr><tr><td>–</td><td>13/14</td><td>时间戳请求或回答</td></tr></tbody></table><p>应用在ping/tracerout</p><h2 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h2><ol><li><p>理想的路由算法</p><ol><li>算法完整</li><li>计算简单</li><li>适应变化</li><li>具有稳定性</li><li>公平的</li><li>最佳的</li></ol></li><li><p>分层次路由选择协议</p><ol><li>自治系统</li><li>内部网关协议IGP, 处在相同同的自治系统中, 如RIP和OSPF协议</li><li>外部网关EGP协议</li></ol></li><li><p>内部网关RIP是一种分布式的基于距离向量的路由网关协议, 距离也称跳数, RIP允许一条路劲最多15个路由器, 只适用于小型互联网</p><ol><li>仅仅和邻路由器交换信息</li><li>交换的信息是路由表</li><li>按固定时间间隔交换信息</li></ol></li></ol><p>RIP协议首部4字节, 每个路由信息20字节, 最多包含25个路由</p><ol start="4"><li><p>内部网关协议OSPF</p></li><li><p>开放最短路径优先, 是分布式的链路状态协议</p><ol><li>洪泛法向本自治系统所有路由器发送信息</li><li>发送的是与本路由器相邻的所有路由器链路状态</li><li>只有当链路状态发生变化后才向路由器发送信息</li></ol></li><li><p>外部网关协议BGP</p><ol><li>互联网规模太大, 自治系统之间路由选择困难</li><li>自治系统之间的路由选择必须考虑油管策略</li></ol></li></ol><h2 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h2><ol><li><p>IPv6基本首部</p><ol><li>更大的地址空间</li><li>扩展的地址层次结构</li><li>灵活的首部格式</li><li>允许协议的继续扩充</li><li>支持资源的预分配</li><li>首部8字节对其</li></ol></li><li><p>IPv6的改变</p><ol><li>取消了首部长度字段, 固定40字节</li><li>取消服务类型字段, 优先级和流标号实现了功能</li><li>取消了总长度字段改为有效载荷长度字段</li><li>取消了标识,标志, 片偏移字段, 包含在分片扩展首部</li><li>取消了协议字段, 改用下一个首部字段</li><li>取消了检验和字段</li><li>取消了选项字段, 用扩展来实现功能</li></ol></li><li><p>首部格式</p><ol><li>版本4位</li><li>通信量8位,区分数据报类别或优先级</li><li>流标号20位,流是互联网上从特定源点到特定终点(单播或多播)的一些了数据报(视频等), 流经过的路径上都保证指明服务质量</li><li>有效载荷长度16位, 除基本首部以外的字节数, 最大值为64kB</li><li>下一个首部8位,相当于ipv4协议字段或可选字段</li><li>跳数限制,TTL</li><li>源地址128位</li><li>目的地址128位</li></ol></li><li><p>ipv6的地址</p><ol><li>单播:点对点通信</li><li>多播:一点对多点的通信</li><li>任播:终点是一组计算机</li></ol></li></ol><p>IPv4到IPv6的转变</p><ol><li>双协议栈值一部分主机装有双协议站,v4和v6,双向通信,若DNS返回的是ipv4的地址,双协议栈主机就是用v4, 在v4向v6转发的时候转换后再发, 但是有些数据没法恢复, 例如流标号</li><li>隧道技术, 在ipv6进入v4网络时, 将ipv6数据报封装为v4数据部分,整个v6数据报变成了v4数据报数据部分</li><li>ip多播</li></ol><h2 id="vpn和网络地址转换NAT"><a href="#vpn和网络地址转换NAT" class="headerlink" title="vpn和网络地址转换NAT"></a>vpn和网络地址转换NAT</h2><p>vpn在对路由器中的所有路由器, 对目的地址是专用地址的数据报一律不进行转发,也称专用互联网</p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h2><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><p>运输层向它上面的应用层提供通信服务, 是面向通信部分的最高层, 也是用户功能的最低层</p><p>运输层为相互通信的应用进程提供了端到端的逻辑通信</p><p>IP层真正通信的实体是主机中的进程</p><h3 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h3><ol><li>用户数据报协议UDP</li><li>传输控制协议TCP</li></ol><h3 id="运输层端口"><a href="#运输层端口" class="headerlink" title="运输层端口"></a>运输层端口</h3><p>运输层所有的应用进程都可以通过运输层传送到IP层,这就是复用, 运输层从IP层收到发送给各应用进程的数据够分别交付给应用进程, 这就是分用</p><p>通信的终点虽然是应用进程, 单报文交付的是目的主机端口</p><h2 id="晕乎数据协议UDP"><a href="#晕乎数据协议UDP" class="headerlink" title="晕乎数据协议UDP"></a>晕乎数据协议UDP</h2><ol><li>udp是无连接的</li><li>尽最大努力交付</li><li>UDP是面向报文的, 一次性交付一个完整的报文</li><li>没有拥塞控制</li><li>UDP支持一对一, 一对多, 多对多的交互通信</li><li>UDP首部开销小</li></ol><h3 id="UDP首部格式-首部字段只有8个字节"><a href="#UDP首部格式-首部字段只有8个字节" class="headerlink" title="UDP首部格式, 首部字段只有8个字节"></a>UDP首部格式, 首部字段只有8个字节</h3><ol><li>源端口, 不需要可全为0</li><li>目的端口</li><li>长度, 最小值为8</li><li>检验和, 判断是够有误</li></ol><p>计算校验和时, 需要在头部加上一个伪首部(源IP地址, 目的IP地址, 0, 17, UDP长度), 仅用作计算检验和</p><h2 id="传输控制TCP"><a href="#传输控制TCP" class="headerlink" title="传输控制TCP"></a>传输控制TCP</h2><ol><li>面向连接</li><li>每条连接有两个TCP</li><li>TCP提供全双工通信</li><li>面向字节流, 指流入到进程或从进程流出的字节序列</li></ol><h3 id="tcp的链接"><a href="#tcp的链接" class="headerlink" title="tcp的链接"></a>tcp的链接</h3><p>TCP连接的端点是套接字,套接字是IP拼接端口</p><h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><p>TCP下面的网络提供的都是不可靠的传输, 不可靠的传输信道能够实现可靠传输</p><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p>停等就是每发送一个分组就停止发送等到确认</p><ol><li>无差错情况</li><li>出现差错后重传, 设置重传等待时间</li><li>确认丢失和确认迟到</li></ol><p>信道利用率= 发送分组时间/(发送分组时间 + RTT + 确认分组所需时间)</p><p>为了提高传输速率, 使用流水线传输</p><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>滑动窗口协议, 每收到一个确认, 发送窗口就向前滑动一个分组位置,接受方采用累计确认的方式</p><h2 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h2><ol><li>源端口和目的端口, 各占2个字节</li><li>序号,占四个字节, 报文段序号</li><li>确认号, 占四字节, 期望收到对方下一个报文段的第一个数据字节的序号, 确认号表示序号前的所有数据都已正确收到</li><li>数据偏移, 占4位, 指出TCP报文段的数据起始处距离TCP报文段的起始出有多远</li><li>保留文6位</li><li>控制位6位, URG=1紧急字段</li><li>ACK=1是确认号字段才有效</li><li>推送PSH=1是立即创建一个报文段发送过去, 接收方收到后立即交付</li><li>复位RST=1表示需要释放链接,然后重新建立链接</li><li>同步SYN=1而ACK=0是表示这是一个请求连接报文段, 若同意连接, 响应报文段syn=1,ACK=1</li><li>终止FIN用来释放连接</li><li>窗口站两字节</li><li>检验和占两字节, 同UDP一样都要加上伪首部, 第四个字段应改为6</li><li>紧急指针,2字节在URG=1才有效,指出本报文段中的紧急数据字节数</li><li>选项, 长度可变, 最长20字节</li></ol><h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>流量控制是让发送方的发送速率不要太快, 要让接收方来得及接收,设置持续计时器防止丢失后形成死锁</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>拥塞控制是防止过多的数据注入到网络中, 这样可以使用网络中的路由器或链路不会过载</p><p>流量控制是点对点通信量的控制, 是一个端到端的问题, 抑制发送方的数据发送速率</p><h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p>慢开始, 拥塞避免, 快重传, 快恢复</p><ol><li>慢开始和拥塞避免</li></ol><p>基于窗口的拥塞控制, 发送方维持一个拥塞窗口的状态变量, 窗口的大小取决于网络的拥塞程度, 发送方让自己的发送窗口等于拥塞窗口</p><p>判断出现网络拥塞的依据是出现了超时</p><p>慢开始是由小到大逐渐增大拥塞窗口数值,每经过一个传输轮次就加倍</p><p>防止拥塞窗口增长过大引起拥塞,设置慢开始门限</p><p>拥塞避免算法就是让拥塞串口慢慢增大, 每经过一个往返时间RTT就加1</p><p>快重传是不等待自己发送数据是才确认,而是立即发送确认</p><h2 id="TCP运输链接管理"><a href="#TCP运输链接管理" class="headerlink" title="TCP运输链接管理"></a>TCP运输链接管理</h2><p>三次握手<br>四次挥手</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>不同的网络应用的应用进程之间, 需要不同通信规则</p><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p>域名到IP的解析是有分布在互联网的域名服务器程序完成</p><p>域名不区分大小写, 完整域名不超过255个字符</p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>一个服务器所负责管辖的范围叫区, 一个区的所有节点必须是能够连通的, DNS服务器的范围不是以域作为单位, 而是区作为单位, 区小于等于域</p><ol><li>根域名服务器是最高层次的域名服务器, 所有根域名服务器都知道所有的顶级域名服务器</li><li>顶级域名服务器, 这些域名管理所有二级域名</li><li>权限域名服务器, 一个区的域名服务器</li><li>本地域名服务器<ol><li>主机向本地域名服务器的查询一般采用递归查询</li><li>本地域名服务器向根域名服务器查询使用迭代查询</li></ol></li><li>维护有高速缓存</li></ol><h2 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h2><p>FTP客户与服务器建立两个连接, “控制连接”和”数据传送连接”</p><h3 id="简单文件传送协议TFTP"><a href="#简单文件传送协议TFTP" class="headerlink" title="简单文件传送协议TFTP"></a>简单文件传送协议TFTP</h3><ol><li>每次传送512字节数据</li><li>数据报文按序编号,从1开始</li><li>支持ASCII码或二进制传送</li><li>可以对文件读写</li><li>使用简单的首部</li></ol><h2 id="远程终端协议TELNET"><a href="#远程终端协议TELNET" class="headerlink" title="远程终端协议TELNET"></a>远程终端协议TELNET</h2><h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><h3 id="统一资源定位符url"><a href="#统一资源定位符url" class="headerlink" title="统一资源定位符url"></a>统一资源定位符url</h3><h3 id="超文本传送协议HTTP"><a href="#超文本传送协议HTTP" class="headerlink" title="超文本传送协议HTTP"></a>超文本传送协议HTTP</h3><p>http1.1 使用的持续连接</p><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><ol><li>请求代理服务器</li><li>若存在就返回</li><li>否则代理服务器与互联网上的源点服务器建立TCP连接,并发送http报文</li><li>源点服务器吧请求的对象放在http响应报文返回代理服务器</li><li>代理服务器收到后复制到自己本地存储器中, 在吧这个对象放在http响应报文总通过已建立的链接返回请求该对象的浏览器</li></ol><h3 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构"></a>http报文结构</h3><ol><li>开始行, 区分请求报文和响应报文, 在开始行的三个字段之间用空格分隔开</li><li>首部行, 说明浏览器服务器或报文主体的一些信息,每一行的结束位置都要有回车和换行, 整个首部结束时, 还要空一行隔开</li><li>实体主题</li></ol><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>简单邮件传送协议SMTP, 通用互联网邮件扩充(附件),邮件读取协议pop3</p><ol><li>连接建立250, 不可用421</li><li>邮件传送, 出错451, 452空间不够, 500命令无法识别</li><li>连接释放221</li></ol><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><h2 id="简单网络管理协议SNMP"><a href="#简单网络管理协议SNMP" class="headerlink" title="简单网络管理协议SNMP"></a>简单网络管理协议SNMP</h2><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><p>被动攻击是从网络上窃听他人通信内容</p><p>主动攻击</p><ol><li>篡改, 更改报文流</li><li>恶意程序<ol><li>计算机病毒</li><li>计算机蠕虫</li><li>特洛伊木马</li><li>逻辑炸弹</li><li>后门入侵</li><li>流氓软件</li></ol></li><li>拒绝服务</li></ol><h3 id="安全的计算机网络"><a href="#安全的计算机网络" class="headerlink" title="安全的计算机网络"></a>安全的计算机网络</h3><ol><li>保密性</li><li>端点鉴别</li><li>信息完整性</li><li>运行完全性</li></ol><h2 id="两类密码体制"><a href="#两类密码体制" class="headerlink" title="两类密码体制"></a>两类密码体制</h2><ol><li>对称密码密码体制,DES属于对称秘钥密码体制, 保密性取决于对秘钥的保密, 算法是公开的</li><li>公钥密码体制使用不同的加密秘钥和解密秘钥,基于大数分解的RSA体制</li><li>数字签名<ol><li>接受者能够核实发送至对报文的签名</li><li>接受者确认收到的数据没有被篡改过</li><li>发送者不可抵赖</li></ol></li><li>鉴别<ol><li>报文鉴别<ol><li>密码散列函数</li><li>MD5和SHA-1,SHA</li><li>报文鉴别码</li></ol></li></ol></li></ol><h2 id="运输层安全协议"><a href="#运输层安全协议" class="headerlink" title="运输层安全协议"></a>运输层安全协议</h2><ol><li>安全套接字层SSL</li><li>运输层安全TLS</li></ol><h2 id="应用层安全协议PGP"><a href="#应用层安全协议PGP" class="headerlink" title="应用层安全协议PGP"></a>应用层安全协议PGP</h2><h2 id="系统安全防火墙"><a href="#系统安全防火墙" class="headerlink" title="系统安全防火墙"></a>系统安全防火墙</h2><p>防火墙是一种访问控制技术,严格控制网络边界的分组禁止任何不必要的通信</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker高级</title>
      <link href="/2019/11/21/docker-gao-ji/"/>
      <url>/2019/11/21/docker-gao-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ol><li>docker隔离的东西(linux namespace+chroot)<ul><li>UTS(主机名和域名)</li><li>User(用户)</li><li>Mount挂载点(文件系统)</li><li>IPC(信号量, 消息队列, 共享队列)</li><li>Pid(进程编号)</li><li>Network(网络)</li></ul></li><li>Control Groups(控制组)</li><li>LinuX Container(LXC)的增强版是docker</li><li>镜像:静态=&gt;进程</li><li>容器:生命周期=&gt;程序  </li></ol><h1 id="docker挂载机制"><a href="#docker挂载机制" class="headerlink" title="docker挂载机制"></a>docker挂载机制</h1><ol><li>采用分层挂载机制, 最底层为bootfs, 其次为rootfs<ol><li>bootfs:用于系统引导的文件系统, 包括bootloader和kernel, 容器启动后会被卸载以节约内存资源</li><li>rootfs:位于bootfs之上, 表现为容器的根文件系统<ol><li>传统模式中, 系统启动之时.内核会挂载rootfs时会首先将其挂载为只读模式, 完整性自检完成后将其重新挂载为读写模式</li><li>docker中, rootfs有内核挂载为只读模式, 而后通过联合挂载技术额外挂载一个可写层</li></ol></li><li><blockquote><p>联合挂载的意思是自下往上依次挂载</p></blockquote></li><li><blockquote><p>每一个功能都是一个image(镜像)</p></blockquote></li><li>位于最下层的镜像称为父镜像, 最底层的称为基础镜像</li><li>最上层的为可写层, 其下的均为只读层</li></ol></li></ol><h1 id="docker-虚拟网络"><a href="#docker-虚拟网络" class="headerlink" title="docker 虚拟网络"></a>docker 虚拟网络</h1><ol><li>在宿主机上建立一个桥接网卡docker0, brctl show显示桥接网卡绑定方式</li><li>将docker0的网卡作为一条网线,一般在宿主机docker0上,一般在docker容器中</li><li>docker0是一个nat桥,iptables -t nat -vnL, 可以看见postrouting规则, 所有进入的流量, 只要不是从docker0桥出去的流量, 原地址来自172.17.0.0/16,无论到达任何主机, 都要进行地址伪装</li><li>docker四种网络模式<ol><li>none, 批处理文件所用, 挂载本地卷, docker run -it –name b1 –network none –rm busybox</li><li>bridge网络, nat桥接docker0,default模式, docker run -it –name b1 –network bridge –rm busybox</li><li>共享同一个网络, IPC, pid模式, 网络对于多个容器可见</li><li>桥接物理网卡</li></ol></li><li>创建网络命名空间并实现网卡互联<ol><li>ip netns add r1创建一个网络名称空间r1</li><li>ip netns list 列出名称空间的网卡</li><li>ip netns exec r1 ifconfig -a进入名称空间r1执行ifconfig命令</li><li>ip link add name veth1.1 type veth peer name veth1.2添加一块类型为veth的虚拟网卡veth1.1,另一半网卡名veth1.2</li><li>ip link show 显示两块网卡连接状态</li><li>ip link set dev veth1.2 netns r1,将veth1.2网卡迁移到r1名称空间</li><li>ip netns exec r1 ip link set dev veth1.2 name eth0进入r1名称空间,并设置设备veth1.2的网卡名为eth0</li><li>ip netns exec r1 ifconfig eth0 10.1.0.1/24 up,将eth0网卡开启并设置ip为10.1.0.1,24位掩码</li><li>ip link set dev veth1.1 netns r2,将veth1.1网卡迁移到r2名称空间</li><li>ip netns exec r2 ip link set dev veth1.1 name eth0,设置网卡名称</li><li>ip netns exec r2 ifconfig eth0 10.1.0.2/24 up, 设置ip并开启网卡</li><li>ip netns exec r1 ping 10.1.0.2测试网络连通性</li></ol></li></ol><h1 id="docker容器注入"><a href="#docker容器注入" class="headerlink" title="docker容器注入"></a>docker容器注入</h1><ol><li>注入容器中主机名, docker run -it –name b1 –network bridge -h test –rm busybox</li><li>注入dns服务器, docker run -it –name b1 –network bridge -h test –dns 114.114.114.114 –rm busybox</li><li>注入host, docker run -it –name b1 –network bridge -h test –dns 114.114.114.114 –add-host <a href="http://www.baidu.com:192.168.0.148" target="_blank" rel="noopener">www.baidu.com:192.168.0.148</a> –rm busybox</li></ol><h1 id="docker-端口映射"><a href="#docker-端口映射" class="headerlink" title="docker 端口映射"></a>docker 端口映射</h1><ol><li>docker run -d –name b1 –rm -p 80 ajinwu/httpd:v1.1</li><li>docker run -d –name b1 –rm -p 192.168.0.148::80 ajinwu/httpd:v1.1</li><li>docker run -d –name b1 –rm -p 192.168.0.148:80:80 ajinwu/httpd:v1.1</li><li>docker run -d –name b1 –rm -p 80:80 ajinwu/httpd:v1.1</li><li>自动暴露使用大写的p</li></ol><h1 id="联盟式容器"><a href="#联盟式容器" class="headerlink" title="联盟式容器"></a>联盟式容器</h1><ol><li>docker run -it –name b2 –network container:b1 –rm busybox, 共享b1的网络名称空间, 但是文件系统也是隔离的</li><li>docker run -it –name b1 –network host –rm busybox, 共享主机的网络</li><li>docker远程连接机器控制docker, 按照官方文档, 修改docker.service文件可行, ubuntu19.04修改daemon.json文件无效, 原因未知</li></ol><h1 id="自己创建网络"><a href="#自己创建网络" class="headerlink" title="自己创建网络"></a>自己创建网络</h1><ol><li>docker network create -d bridge –subnet “172.26.0.0/16” –gateway “172.26.0.1” mybr0, 创建网络mybr0,方式为桥接,子网为172.26.0.0, 网关如上</li></ol><h1 id="数据卷的必要性"><a href="#数据卷的必要性" class="headerlink" title="数据卷的必要性"></a>数据卷的必要性</h1><ol><li>关闭并重启容器, 其数据不受影响, 但是删除docker容器, 其更改会消失</li><li>存在的问题<ol><li>存储在联合文件系统中, 不易于宿主机访问</li><li>容器间数据共享不方便</li><li>删除数据数据会丢失</li></ol></li><li>解决方案:卷<ol><li>卷是容器上的一个或多个目录, 此类目录会绕过联合文件系统, 与宿主机上的某目录绑定关联</li></ol></li><li>docker run –name b1 -it -v /data busybox, docker自己管理的绑定卷, 使用inspect可以查看挂载地址</li><li>docker run –name b1 -it -v /home/ajin_w/docker/volumes:/data –rm busybox, 挂载本地卷存放数据, 不存在会默认创建, 双向创建</li><li>容器间共享数据:使用挂载卷, 两个容器使用同一个挂载卷</li><li>复制一个容器已存在的卷<ol><li>docker run –name infracon -it -v /home/ajin_w/docker/volumes/infracon:/data/web/html busybox, 创建一个基础容器, 可以不用交互式, 也可以不用启动, 但是不能删除, 只提供给其他容器复制</li><li>docker run –name nginx –network container:infracon –volumes-from infracon -it –rm busybox, 创建一个nginx容器, 继承infracon容器的网络, 存储卷也使用infracon相同的配置</li></ol></li></ol><h1 id="docker信息查询"><a href="#docker信息查询" class="headerlink" title="docker信息查询"></a>docker信息查询</h1><ol><li>docker inspect b1 -f , 使用json层级读取数据</li></ol><h1 id="dockerfile制作"><a href="#dockerfile制作" class="headerlink" title="dockerfile制作"></a>dockerfile制作</h1><ol><li>指令格式format<ol><li>comment, 注释信息</li><li>指令和指令参数</li></ol></li><li>指令本身不区分字符大小写, 约定俗称使用大写</li><li>docker运行自上而下</li><li>第一个非注释行一定是以from开头</li><li>dockerfile文件首字母一定要大写</li><li>打包文件一定要在本目录以及本目录之下</li><li>FROM格式, FROM <repository>[:tag] 或者FROM <repository>@<digest> digest为哈希码, 不会被冒名顶替</digest></repository></repository></li><li>COPY, 将本机的文件复制到镜像, 源文件一般为相对与dockerfile文件目录, 目标文件一般为镜像中的绝对路径<ol><li>复制目录目录本身不会被复制, 只会递归复制目录下的文件</li><li>必须以/结尾</li></ol></li><li>ADD, 语法和COPY相同, 可以加上url, 会自动下载文件, 本地打包文件会自动解压</li><li>WORKDIR, 制定工作目录</li><li>VOLUME, 指定挂载卷, 只能指定容器内的, 容器外只能使用默认的</li><li>EXPOSE, 为容器打开指定要监听的端口与外部通信, 在dockerfile中写入只是会作为待暴露的端口, 而不是直接暴露, 加上P会暴露</li><li>ENV <key>=<value> …value中含有空白字符等需要使用反斜杠转义, 或者引号转义, 反斜线也可以进行续行</value></key></li><li>RUN, 正常写linux操作命令, 必须是基础镜像有的命令, 在docker build的时候执行<ol><li>作为shell的子进程来运行, 以”/bin/bash -c”来运行, 此进程pid不为1, 不能接受unix信号, 因此, docker stop无法停止容器</li><li>RUN [“<executable>“, “param”]格式的命令不以”bash”运行, 因此shell常见操作不会进行(通配符))</executable></li><li>依赖shell特性可RUN[“bin/bash”, “-c”, “executable”, “param”]信号也不是1</li></ol></li><li>CMD, 类似与RUN指令, 定义一个镜像文件启动为容器时默认要运行的程序, 只能出现一个CMD, CMD指令可以被dockerfile命令选项覆盖<ol><li>CMD <commend> pid不为1,可以使用shell命令</commend></li><li>CMD[“executable”,”param”]创建的是pid为1的进程, 这里不能默认启动shell, 可以手动运行为shell子进程</li><li>CMD [“param”]结合entrypoint来运行</li></ol></li><li>ENTRYPOINT命令不会被覆盖, 也不允许被覆盖, 多余输入的命令会被当做参数传入, 可以在启动容器时修改entrypoint命令<ol><li>如果CMD和ENTRYPOINT同时使用, 则CMD的命令会被当做参数传入ENTRYPOINT</li></ol></li><li>docker参数-e, 设置环境变量</li><li>shell命令, exec顶替上一个进程, “$@”, 后面任意长度字段的作为参数, exec “$@”, 顶替当前进程, 然后将后面的命令传入当做下一个程序执行</li><li>HEALTHCHECK健康监测<ol><li>HEALTHCHECK –interval=duration(default:30s), 检测周期</li><li>–timeout=duration(default:30s)超时时间</li><li>–start-period=duration(default:0s), 容器启动多少秒开始检测</li><li>–retries=N (default:3), 检测次数</li><li>example===&gt; HEALTHCHECK –interval=5m –timeout=3s CMD curl -f <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> || exit 1</li></ol></li><li>ONBUILD触发器命令, 在别人使用你的镜像时会执行这个命令, 后门</li></ol><h1 id="docker-仓库"><a href="#docker-仓库" class="headerlink" title="docker 仓库"></a>docker 仓库</h1><ol><li>apt install docker-registry</li><li>insecure-registries</li><li>vmrare harbor</li></ol><h1 id="docker-资源限制"><a href="#docker-资源限制" class="headerlink" title="docker 资源限制"></a>docker 资源限制</h1><ol><li>linux 通过内核来管理资源调度, 使用内存计算算法来管理, oom-score最高的会被最先杀死, 重要应用应使用oom_obj来分配权重</li><li>内存限制<ol><li>–momery内存不应该大于主机内存</li><li>–momery-swap为交换空间, 不设置memory则无法设置此选项<ol><li>-m-s为正数S, m为正数M, 容器总空间为S, 其中ram为M, swap为(S-M), 如S=M, 则无可用swap资源</li><li>0, M, 相当于未设置swap(unset)</li><li>unset, M, 若主机弃用了swap, 容器可用swap为2*M</li><li>-1, M, 若主机弃用了swap, 容器可使用最大主机swap资源</li></ol></li><li>–oom-kill-disable, 禁止kill</li></ol></li><li>cpu限制<ol><li>默认可使用所有的cpu</li><li>cpu可压缩, 共享式cpu-shares共享, 按照比例切分, 不用的时候cpu可以尽可能共享给他人, 使用的时候按比例给他最大的, 然后检查其他进程cpu资源是否空闲, 空闲可继续使用</li><li>–cpus=1.5, 显示cpu最多使用几核, 可使用小数</li><li>–cpuset-cpus, 限制使用的cpu是哪几个, 不建议使用</li></ol></li><li>docker run –name stress -it –rm -m 256m lorel/docker-stress-ng stress –vm 2, 验证memory限制, docker stats显示详细信息</li><li>docker run –name stress -it –rm –cpus 2 lorel/docker-stress-ng stress –cpu 8, cpu压测</li><li>docker run –name stress -it –rm –cpu-shares 1024 lorel/docker-stress-ng stress –cpu 8, 共享式分配, 首先会占用完cpu, 然后再来一个容器会互相分配</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker初级</title>
      <link href="/2019/11/21/docker-chu-ji/"/>
      <url>/2019/11/21/docker-chu-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="获取docker镜像"><a href="#获取docker镜像" class="headerlink" title="获取docker镜像"></a>获取docker镜像</h1><ul><li>获取镜像<ul><li>docker pull ubuntu:18.10  下载镜像<ul><li>默认不填版本号会选最新版本的，即latest，默认使用官方镜像</li><li>非官方镜像下载 <blockquote><p>docker pull hub.c.163.com/public/centos:6.5</p></blockquote></li><li>pull 参数<ul><li>-a，    –all表示获取所有镜像，默认为否</li></ul></li></ul></li></ul></li></ul><pre><code>- 查看镜像    - docker images列出镜像        - images参数            - -a，    列出所有镜像            - -f ，   列出过滤的镜像，例如列出没有被使用的镜像                &gt;docker images -f dangling=true    - docker tag ubuntu:latest ajinwu:test给镜像起别名，类似于软链接    - docker inspect web列出web这个容器的详细信息(注意，并不是镜像名)        - -f参数            &gt;docker inspect -f {{".Networks"}} web  显示web容器的网络信息    - docker history ajinwu:test列出镜像的创建过程        &gt;docker history --no-trunc ajinwu:test  显示截断的信息- 搜寻镜像    - docker search [option] keyword        - -f    过滤输出内容            &gt; docker search -f=is-official=true nginx   查找镜像，官方给出的带有nginx的镜像        - --limit int 限制输出内容            &gt; docker search --limit=3 nginx         显示前三条结果- 清理镜像    - docker rmi ubuntu:18.10       删除镜像标签为18.10的ubuntu镜像    - -f强制删除，即使有容器依赖    - docker ps -a  列出本机用过的所有容器    - 先删除容器在删除镜像        &gt; docker rm [CONTAINER ID]  删除镜像        &gt; docker rmi -f ajinwu/commit_test1:latest  强制删除镜像        &gt; docker images prune -f 自动清除遗留文件层- 创建镜像    - docker commit -m "add a new file" -a "docker ajin" c57 ajinwu/commit_test     制作一个新镜像，信息为add  file，作者信息为docker  ajin，容器id为c57开头,仓库名为ajinwu/,镜像名为commit_test 的新镜像    - 还可以添加-p暂停容器的运行    - 可以使用openVZ提供的模板来创建镜像        - cat ubuntu-18.04-x86_64.tar.gz | docker import - ubuntu:18.04    - dockerfile构建镜像        - docker build -t="ajinwu/dockerfile" .     -t参数为镜像名，后面加上dockerfile的目录- 存出镜像和载入镜像    - 存出镜像 docker save -o ubuntu_commit.tar ajinwu/commit_test    - 载入镜像  docker load &lt; ubuntu_commit.tar    - 上传镜像        - 先修改标签，格式为用户ID/镜像名docker tag test:test ajinwu/test        - 上传  docker push ajinwu/test</code></pre><ul><li><p>操作容器</p><ul><li><p>创建容器</p><ul><li><p>docker create -it ajinwu:test创建一个容器不运行</p></li><li><p>docker run -it ajinwu:test /bin/bash 使用ajinwu:test镜像创建一个容器并开启交互式终端使用/bin/bash</p></li><li><p>docker run -p 8111:80 –name nginx -i -t ubuntu /bin/bash     创建一个容器名为nginx的容器，将本地的8111端口映射到容器的80端口，可使用容器的地址直接访问</p></li><li><p>常用参数说明</p><ul><li>-i    保持标准输入输出打开</li><li>-t    分配伪终端</li><li>-d    是否后台运行，默认为否</li><li>–net=”bridge”    开启桥接网络</li><li>–expose      暴露端口</li><li>-p映射端口 -p</li></ul></li><li><p>开启容器docker start 042  注意，只能使用id</p></li><li><p>docker run ubuntu /bin/echo “hello wolrd”</p><ul><li>检查本地是否有ubuntu镜像</li><li>利用镜像创建一个容器，并启动该容器</li><li>分配一个文件系统给容器，并在只读镜像层外面挂载一层可读写层</li><li>从宿主主机的配置的网桥接口中桥接一个虚拟接口到容器</li><li>从网桥的地址池配置一个ip给容器</li><li>执行用户指定的应用程序</li><li>执行完命令容器被自动终止</li></ul></li><li><p>查看容器输出</p><ul><li><blockquote><p>docker logs  -f -t  –tail 10 test       查看最后10条并持续输出显示时间</p></blockquote></li></ul></li></ul></li><li><p>停止容器</p><ul><li>docker run –name=ajin2 -it –rm ubuntu bash运行一个容器，命名为ajin2，交互式伪终端运行bash，运行结束后删除该容器</li><li>Ctrl +p    Ctrl+q 后台运行容器，不停止容器的退出</li><li>docker pause ajin2 暂停容器ajin2</li><li>docker stop ajin2 终止容器ajin2</li><li>docker ps 查看容器<ul><li>-l    查看正在运行的容器</li><li>-a    查看所有容器</li><li>-qa   只查看所有容器的id</li></ul></li><li>docker restart 042    重启容器</li></ul></li><li><p>进入容器</p><ul><li>docker attach 042  进入后台容器</li><li>docker exec -it 042 bash  推荐这种方式，在不影响运行应用的情况下开启一个新的bash</li></ul></li><li><p>docker rm -f 042      强行删除容器（不建议）</p></li><li><p>导入和导出容器</p><ul><li>导出容器<ul><li>docker export -o test_export.tar 4ac</li></ul></li><li>导入容器<ul><li>docker import test_export.tar - test/ubuntu:v11这命令我不知道为啥错了</li></ul></li></ul></li><li><p>查看容器</p><ul><li>docker top 4ac       查看运行中的容器进程</li><li>docker stats 4ac  类似与htop命令</li><li>docker inspect 4ac    查看容器信息</li></ul></li><li><p>其他容器命令</p><ul><li>复制文件docker cp dp_2.py 4ac:/tmp，复制本机的文件到容器的tmp下</li><li>反向赋值docker cp 4ac:/test.txt .</li><li>docker  diff 4ac     查看容器数据修改</li><li>docker container port d8  查看端口映射<h1 id="访问docker仓库"><a href="#访问docker仓库" class="headerlink" title="访问docker仓库"></a>访问docker仓库</h1></li></ul></li></ul></li><li><p>各大镜像仓库</p><ul><li>阿里云，网易云，腾讯云docker pull  url</li></ul></li><li><p>搭建本地私有仓库，大家自行学习</p></li></ul><h1 id="docker数据管理"><a href="#docker数据管理" class="headerlink" title="docker数据管理"></a>docker数据管理</h1><ul><li><p>数据卷</p><ul><li>docker volume create -d local test 会在宿主机/var/lib/docker/volumes下创建一个test数据卷</li><li>绑定数据卷<br>  docker run -it -p 80 –name=blog -v /home/ajin_w/blogbak:/home/ajin_w/blog ubuntu /bin/bash     此命令为开启一个名为blog的容器，-v参数为映射本地文件夹blogbak目录到容器blog下，映射目录相当于一个网络驱动器，容器内外的修改均会生效，可在映射结束的位置添加读写权限，例如ro</li></ul></li><li><p>数据容器</p><ul><li><p>数据容器的创建使得挂载该数据容器的容器间可以很方便的进行数据交换</p></li><li><p>创建数据容器</p><ul><li>docker run -it -v /dbdata –name dbdata ubuntu</li></ul></li><li><p>挂载数据容器</p><ul><li>docker run -it –volumes-from dbdata –name db1 ubuntu</li></ul></li><li><p>数据容器不需要保持在运行状态</p></li><li><p>删除数据卷必须在最后一个挂载他的容器显式使用docker rm -v命令来指定同时删除关联的容器</p></li><li><p>数据迁移</p><ul><li>docker run –volumes-from dbdata -v $(pwd):/backup –name worker ubuntu tar -cvf /backup/backup.tar /dbdata</li><li>以上命令解释：创建一个worker容器，挂载dbdata数据卷，使用-v参数挂载本地当前目录到worker的容器的backup目录，容器启动后，打包dbdata为容器的/backup/backup.tar，即宿主机的当前目录下的backup.tar      意思就是挂载两个数据卷，一个本地目录，一个数据卷或者数据容器，将容器内的数据卷打包到容器的backup目录，因为直接挂载数据卷在/目录下，在挂载一个目录，将/目录下的数据卷打包进backup就好，本地目录变成了backup</li></ul></li><li><p>数据恢复</p><ul><li>docker run -v /dbdata –name dbdata2 ubuntu /bin/bash </li><li>创建一个容器挂载dbdata数据卷，名为dbdata2</li><li>docker run –volumes-from dbdata2 -v $(pwd):/backup ubuntu tar xvf /backup/backup.tar </li><li>创建另一份容器挂载dbdata2和当前目录到/backup目录，将本地的目录解压</li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典和集合</title>
      <link href="/2019/11/12/zi-dian-he-ji-he/"/>
      <url>/2019/11/12/zi-dian-he-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="泛映射类型"><a href="#泛映射类型" class="headerlink" title="泛映射类型"></a>泛映射类型</h1><p>collection.abc 模块中有mapping和mutaleMapping这两个抽象基类, 往往为dict和其他类似的类型定义形式接口</p><p>非抽象映射类型一般不会直接继承抽象基类, 会直接对dict或者collection.userdict进行扩展</p><p>标准库里的所有映射类型都是利用dict来实现的, 因此只有可散列的数据类型才能用作这些键(只有键有要求, 值并无要求)</p><blockquote><p>可散列数据类型在这个对象的生命周期内, 其散列值不会改变, 同时还需要实现<strong>hash</strong>和<strong>eq</strong>方法才可进行比较</p></blockquote><blockquote><p>原子不可变类型(str, 数值, bytes)都是可散列类型, frozenset只能存放可散列类型, 因此他也是可散列类型, 元组中所有的元素都是可散列的, 元组才是可散列的</p></blockquote><h1 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h1><pre><code>{key: value for key, value in count.items}</code></pre><h1 id="键的映射方法"><a href="#键的映射方法" class="headerlink" title="键的映射方法"></a>键的映射方法</h1><p>要使用setdeafult来处理找不到的键r.setdeafult(key,[]), 这一句的意思是<code>if key is not in dict: dict[key] = []</code></p><h1 id="映射的弹性查询方法"><a href="#映射的弹性查询方法" class="headerlink" title="映射的弹性查询方法"></a>映射的弹性查询方法</h1><p>在某个键不存在时, 我们也想通过这个键读取一个默认值, 这样有两个方法, 1是使用defaultdict, 2是自己定义一个dict的子类实现<strong>missing</strong>方法</p><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>在设置默认值时, 要使用一个数据类型的构造方法,如<em>list</em>, 如果查找不到对应的记录, 会使用default_factory方法来设定一个值</p><h2 id="特殊的missing方法"><a href="#特殊的missing方法" class="headerlink" title="特殊的missing方法"></a>特殊的<strong>missing</strong>方法</h2><p>所有映射类型找不到键都会调用这个方法, 但是只对getitem有效, 对get和in没有影响</p><pre class="line-numbers language-python"><code class="language-python">l<span class="token punctuation">.</span>__getitem__<span class="token punctuation">(</span>key<span class="token punctuation">)</span>l<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">,</span>default<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种处理是不一样的, 第一种会报错, 第二中会是默认值或者返回为None</p><p>在找不到键的时候使用<strong>missing</strong>方法, 可以做一些特殊的操作</p><p>如果要使用key in dict方法, 就必须要实现<strong>contains</strong>方法, 因为找不到也会到<strong>missing</strong>里面寻找, 产生无限递归, 而使用in操作时, 会产生一个视图, 这种操作查找元素很快</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">strkey</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 再找不到键的时候会在这里进行字符装换</span>    <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>key<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> KeyError<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">[</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> default <span class="token operator">=</span> None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">[</span>key<span class="token punctuation">]</span>        <span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>            <span class="token keyword">return</span> default    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">or</span> str<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>d <span class="token operator">=</span> strkey<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">"2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"None"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 只对get有效而不对__getitem__无效</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h1><p>有序字典collections.OrderedDict 排序</p><pre class="line-numbers language-python"><code class="language-python">d <span class="token operator">=</span> collections<span class="token punctuation">.</span>OrderedDict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> s<span class="token punctuation">:</span>    <span class="token keyword">if</span> i <span class="token keyword">in</span> d<span class="token punctuation">:</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>d <span class="token operator">=</span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token keyword">lambda</span> d<span class="token punctuation">:</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> reverse <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">## 返回列表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>collections.chainMap()做模板之用, 适合嵌套数据</p><p>UserDict并不是dict的一个子类, 继承于dict更推荐使用UserDict, 前者会在有些实现上走一些捷径, 有些方法必须要重写</p><p>UserDict由一个data属性, 实际上是存储的dict里面的属性</p><p>UserDict 继承的是mutableMapping</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> UserDict<span class="token keyword">class</span> <span class="token class-name">user_dict</span><span class="token punctuation">(</span>UserDict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>key<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> KeyError<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">[</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> str<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>data <span class="token comment" spellcheck="true"># data是一个dict实例</span>    <span class="token keyword">def</span> <span class="token function">__setitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> itemd <span class="token operator">=</span> user_dict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">"2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"None"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h1><p>types模块中由一个封装类名叫做MapingProxyType, 使用此类包装的数据是动态的, 无法做改变, 需要修改原数据才可以改变包装后的数据</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> types <span class="token keyword">import</span> MappingProxyTyped <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token string">"A"</span><span class="token punctuation">}</span>d_proxy <span class="token operator">=</span> MappingProxyType<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"x"</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>d_proxy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"b"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合内的元素必须是可散列的, set本身是不可散列的, 但是frozenset可以散列</p><h2 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h2><p>a = {1}</p><blockquote><p>如果是空集, 必须使用无参构造方法<br>对于a = set([1,2]) 和a = {1, 2}来说, 后者的速度会更快一些</p></blockquote><p>frozenset没有特殊字面量说法, 只能采用构造方法</p><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>&amp; 交集</p><p>| 并集</p><p>- 差集</p><p>^ 对称差集 (A U B) - (A n B)</p><blockquote><p>在集合方法discard是移除元素, 不存在不会报错</p></blockquote><h1 id="dict和set的背后"><a href="#dict和set的背后" class="headerlink" title="dict和set的背后"></a>dict和set的背后</h1><p>dict和set搜索都比list快, 是由于list背后没有散列表来支持in运算, 因此每次都会扫描整个列表</p><h2 id="字典中的散列表"><a href="#字典中的散列表" class="headerlink" title="字典中的散列表"></a>字典中的散列表</h2><p>散列表是一个稀疏数组, 在dict的散列表中, 每个键值对都占有表元, 一个是键的引用, 一个是值得引用, 因为所有的表元的大小一致, 所以可以通过偏移量来读取, python会保证1/3是空的, 超过会自动复制到更大的空间</p><p>在插入新值时, python会按照散列表的拥堵程度来决定是否重新分配内存, 为了减小散列冲突, 散列值位数和索引位数也会增加</p><h2 id="dict的实现和后果"><a href="#dict的实现和后果" class="headerlink" title="dict的实现和后果"></a>dict的实现和后果</h2><p>散列需要满足的要求</p><ol><li>支持hash函数, 并且hash计算不变</li><li>支持<strong>eq</strong>来判等</li><li>若a==b, 则hash(a) == hash(b)</li></ol><p>所有用户自定义的对象都是可散列的, 因为散列值是id()来获取</p><blockquote><p>如果实现了<strong>eq</strong>方法, 并且希望是可散列的, 就必须实现<strong>hash</strong>方法, 并保证相等</p></blockquote><p>字典在内存上的开销巨大</p><p>字典的键查询很快, 空间换时间</p><p>键的次序取决于添加顺序</p><p>往字典添加新键可能会改变已有的顺序, 因为每一次添加新键都有可能使字典扩容, 造成散列冲突, 导致打乱原有的顺序</p><blockquote><p>keys, items, values返回的都是字典视图</p></blockquote><h2 id="set的实现以及后果"><a href="#set的实现以及后果" class="headerlink" title="set的实现以及后果"></a>set的实现以及后果</h2><ol><li>集合元素必须是可散列的</li><li>集合很消耗内存</li><li>in很高效</li><li>元素的次序决定于添加的次序</li><li>添加可能会改变次序</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>dict, defaultdict, userdict, orderedDict, ChainMap, Counter, UserDict</p><p>setdefault</p><p><strong>missing</strong></p><p>MappingProxyType</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列构成的数组</title>
      <link href="/2019/11/12/xu-lie-gou-cheng-de-shu-zu/"/>
      <url>/2019/11/12/xu-lie-gou-cheng-de-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="内置序列类型"><a href="#内置序列类型" class="headerlink" title="内置序列类型"></a>内置序列类型</h1><ol><li><p>python标准库使用c实现了丰富的序列类型</p><ol><li>容器序列:list, tuple, collection.deque这些序列能存放不同类型的数据</li><li>扁平序列:str, bytes, bytesarray, memoryview和array.array, 这种序列只能容纳一种类型<blockquote><p>容器序列存放的是他们所包含的对象的引用, 扁平序列存放的是值, 换句话来说, 扁平序列是一段连续的内存空间</p></blockquote></li><li>可变序列:list, bytesarray, array.array, collections.deque, memoryview</li><li>不可变序列: tuple, str和bytes</li></ol></li><li><p>列表推导和生成器表达式</p><ol><li>列表推导式并不一定比map慢</li><li>在初始化序列类型时, 使用生成器表达式是更好的选择, 生成器表达式遵守了迭代器协议, 可以逐个产生元素, 列表推导式是先建立一个完整的列表, 然后再把这个列表传递到某个构造函数里面, 不够节省内存.</li><li>生成器表达式每次for循环才会生成一个组合, 所以会省掉笛卡尔积的for循环开销</li></ol></li><li><p>元组不仅仅是不可变的列表</p><ol><li>元组和记录: 元组其实是对数据的记录, 元组的每个元素都存放了一个字段的数据, for循环可以自动拆包元组, 迭代过程中, print可以接受一个元组作为参数输入, 拆包让元组当做记录来使用.</li><li>元组拆包可以应用到任何可迭代对象上, 但是可迭代对象的元素必须要跟接受这些元素的元组的空挡数已知</li><li>拆包中对于不定长参数使用*获取, 可以应用与任何位置, 自动对应长度</li><li>python3中函数参数不接受元组型(不接受所有迭代序列, 例如(a, b), [a, b])</li></ol></li><li><p>具名元组</p><ol><li>创建一个具名元组需要两个参数, 一个是类名, 另一个是类的各个字段的名字, 后者可以由数个字符串组成的可迭代对象, 或者是有空格分割开的字段名组成的字符串</li><li>存放在对应字段里的数据要以一串参数的形式传入到构造函数中, 元组的构造函数只接受单一的可迭代对象</li><li>可以通过字段名获取对应位置的字段信息</li><li>具名元组里面可以叠加具名元组, 实现高级数据结构</li><li>具名元组相当于一个类</li><li>重复拼接方法<strong>mul</strong>(n), 生成一个新的对象</li></ol></li><li><p>切片</p><ol><li>切片和区间操作会忽略最后一个元素, 符合以0为开始的风格</li><li>python的内置序列类型都是一维的, 他们只支持单一索引</li><li>如果把切片放在赋值语句的左边, 或者把他作为del操作的对象, 我们就可以对序列进行嫁接, 切除, 或者就地修改等操作</li><li>如果赋值的对象是一个切片, 那么右值必须是一个可迭代序列</li></ol></li><li><p>对序列使用+*</p><ol><li>序列支持+*, 在拼接的过程中, 两个被操作的序列都不回被修改, python会新建一个包含同类型的序列作为拼接的结果</li><li>不要使用[[“_”]] * 3这种语法</li><li>序列增量赋值要实现<strong>iadd</strong>方法, 如果没有实现, 解释器会自动转向<strong>add</strong>方法</li><li>在元组中, 有可变序列时, 需要append而不是直接+=</li></ol></li><li><p>list.sort和内置函数sorted</p><ol><li>list.sort()方法会原地赋值, 返回值为None, 并不会产生新的对象</li><li>sorted可以接受任何可迭代的对象作为参数, 甚至不可变序列或生成器</li><li>reverse和key作为可选关键字, key用于序列中的每一个元素, 作为排序的对比关键字, 比如key=len, 进行基于字符串长度的排序</li></ol></li><li><p>用bisect来管理已排序的序列</p><ol><li>bisect.insort(list, item), 讲一个新的item放入list, 保持有序的同时插入, 函数有返回值, 返回值为在新序列中的位置</li><li>bisect中的方法都有left和right可选, 区别在于放在左边还是右边</li></ol></li><li><p>当列表不是首选时</p><ol><li>数组<ol><li>数组支持所有跟可变序列有关的操作, 还提供从文件读取和存入文件更快的方法, frombytes和tofile方法</li><li>数组只能存放限定类型的数据</li></ol></li><li>内存视图, 看不懂</li><li>双向队列<ol><li>maxlen是可选参数, 固定后不可改变</li><li>对满队列添加元素时会自动删除左端或者右端元素</li><li>deque原子操作, 是线程安全的</li></ol></li></ol></li><li><p>总结</p><ol><li>序列类型分为可变序列和不可变序列, 或者说是扁平序列和容器序列, 扁平序列只能保存原子操作, 容器序列可以保存其他序列, 容器:有些对象包含其他对象的引用.</li><li>对于重复拼接在遇到不可变序列时, 会产生新的序列, 如果遇到可变的会就地修改</li><li>元组存放没有关系的数据</li><li>sorted和list.sort背后的算法是timsort自适应算法, 会根据原始数据的特点交替使用插入排序和归并排序</li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机概论</title>
      <link href="/2019/11/11/ji-suan-ji-gai-lun/"/>
      <url>/2019/11/11/ji-suan-ji-gai-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="数据表示方式"><a href="#数据表示方式" class="headerlink" title="数据表示方式"></a>数据表示方式</h1><h2 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h2><p>在计算机中, 所有的数据都是二进制</p><h2 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h2><p>常用的英文编码都是ascii, 每个符号(英文, 数字, 或符号等)都会占用一个bytes, 总共会有2^8中变化, 目前所使用的Unicode编码系统解决了这个问题</p><h1 id="软件程序运作"><a href="#软件程序运作" class="headerlink" title="软件程序运作"></a>软件程序运作</h1><p>目前计算机都将软件分为两大类, 系统软件和应用程序</p><h2 id="机器程序与编译程序"><a href="#机器程序与编译程序" class="headerlink" title="机器程序与编译程序"></a>机器程序与编译程序</h2><p>cpu具有微指令集, 让cpu帮忙工作必须要参考微指令集, 这个流程包括一下方面</p><ol><li>需要了解机器语言</li><li>需要了解所有硬件的相关功能函数</li><li>程序具有不可移植性, 每个cpu都有独特的微指令集, 同样, 每个硬件都有相关功能函数</li><li>程序具有专一性, 要面对相关硬件来编写</li></ol><p>编译程序做了将高级语言转化为机器语言的功能来完成程序的运行</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统也是一组程序, 这组程序主要来管理计算机以及相关硬件</p><p>操作系统放置在内存中的受保护区域, 开机后一直常驻与内存</p><h2 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h2><p>操作系统除了核心程序之外, 通常会提供开发接口, 就是sc, 开发工程师只需要遵循sc参数开发软件</p><ol><li>操作系统的核心层直接参看硬件规格, 所以同一个操作系统不能再不同硬件平台运作</li><li>操作系统只管理硬件资源, 包括cpu, 内存, 输入输出装置及文件系统文件</li><li>应用程序开发参考操作系统提供开发接口</li></ol><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li>system call interface</li><li>程序管理, 内核控制分配cpu资源   </li><li>内存管理</li><li>文件系统管理</li><li>硬件驱动</li></ol><h2 id="操作系统与驱动程序"><a href="#操作系统与驱动程序" class="headerlink" title="操作系统与驱动程序"></a>操作系统与驱动程序</h2><p>操作系统会提供开发接口给硬件开发商, 根据接口设计驱动程序</p><ol><li>操作系统必须能够驱动硬件, 应用程序才能使用该硬件</li><li>一般来说, 操作系统会提供开发接口</li><li>使用新硬件, 必须安装驱动程序</li><li>驱动程序由开发者提供, 与操作系统开发者无关</li></ol><h1 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h1><p>应用程序是参考操作系统开发接口开发的软件, 达到某些计算机功能</p><p>应用程序与操作系统有关系</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>计算机定义: 接受用户输入指令与数据, 经过中央处理器的算逻单元运算后, 产生或存储有用的信息</li><li>计算机五大单元: 输入输出单元, 控制单元, 算逻单元, 记忆单元, cpu占有控制, 算逻单元, 记忆单元又包含主存储器与辅助内存</li><li>数据搂入流出是cpu发出的控制指令, cpu处理的数据来着主存储器</li><li>cpu设计理念分为: 精简指令集与复杂指令集</li><li>新的cpu设计中已经将北桥的内存控制芯片整合到cpu中, 而cpu与主存储器, 显示适配器沟通的总线是系统总线, 南桥是I/O总线</li><li>cpu每次能够处理的数据量称为字组大小, 目前有32/64位区分</li><li>一个byte=8bits</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机系统/linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统/linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据模型</title>
      <link href="/2019/11/09/python-shu-ju-mo-xing/"/>
      <url>/2019/11/09/python-shu-ju-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="python-风格"><a href="#python-风格" class="headerlink" title="python 风格"></a>python 风格</h1><ol><li><p>特殊风格</p><ol><li><strong>getitem</strong>方法是实现列表进行选取的方法, 并且还支持切片语法, 并且只要实现了这个方法, 这个对象就变成了可迭代的对象, 实现方式, 返回一个本对象的一个结点</li><li>in运算符是contains方法实现的, 如果没有实现这个方法, 那么in运算符就是按顺序进行一次迭代搜索</li></ol></li><li><p>如何使用特殊风格<br><br>特殊方法的存在是为了被解释器调用的, 不需要自己调用, 也就是你需要len(object)而不是object.len(), 如果是py内置的类型, 如list, str等, cpython的<strong>len</strong>会直接返回pyvarobject中的ob_size属性, pyvarobject是表示内存中长度可变的内置对象的C语言结构体. 速度会快很多.<br>很多时候, 特殊方法的调用是隐式的, 例如for i in xx, 背后使用的是iter(xx)函数, 而iter实现是xx.<strong>iter</strong>()方法, 通过内置的函数, 如len, str来使用特殊方法是最好的选择, 这些内置函数会调用特殊方法, 且对于内置类来说, 他们的速度会更快.</p><ol><li><p>模拟数值类型</p><ol><li>如果一个对象可以获取 obj 的字符串表示, 他需要实现<strong>repr</strong>或者<strong>str</strong>方法, + 为<strong>add</strong>方法, * 为<strong>mul</strong>方法</li></ol></li><li><p>字符串表示形式<br></p><ol><li><strong>repr</strong> 用于生成正式的表示。可以认为是将对象序列化的方法，原则上要能反序列化回对象。</li><li><strong>str</strong> 用于生成非正式的表示。format 或 print 会调用它来为用户生成“友好的”显示。<blockquote><p>str 与repr对比, repr 并不强制生成的字符串可以反序列化</p></blockquote></li></ol><blockquote><p>1.repr 生成的字符串一般用于 debug，所以一般生成的字符串一般要包含尽可能多的信息，信息要尽可能明确(如默认实现里用 ID 区分开两个不同的对象)。</p></blockquote><blockquote><p>2.不要使用 repr 和 eval 来做序列化/反序列化，用 pickle 或 json。<br>3.obj.<strong>str</strong>() 方法会在 print(obj) 或 ‘{}’.format(obj) 时被调用，一般是为了给用户提供 “友好的” 显示，所以 <strong>str</strong> 不像<strong>repr</strong> 那样原则上对返回值有约定，想怎么搞都行。</p></blockquote><blockquote><p>4.另外，<strong>str</strong> 的默认实现是直接调用了 <strong>repr</strong> 方法。因此如果覆盖了 <strong>repr</strong> 方法，<strong>str</strong> 的结果也会随之改变。</p></blockquote><blockquote><p>5.如果只想实现其中的一个方法, <strong>repr</strong>是最好的选择, 如果一个对象没有str方法而需要使用时, 会使用repr代替</p><ol start="3"><li>自定义的布尔值</li><li>默认情况下, 我们自定义的类总是被认为是真的, 除非是对<strong>bool</strong> 或者<strong>len</strong>做了实现, 如果不存在<strong>bool</strong>, 则会调用<strong>len</strong>方法</li></ol></blockquote></li><li><p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html" target="_blank" rel="noopener">特殊方法对照表</a></p></li></ol></li></ol><p>本章代码<br><a href="/file/getitem_len.py">getitem_len</a><br><a href="/file/vector.py">vector</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秦九韶算法详解</title>
      <link href="/2019/11/09/qin-jiu-shao-suan-fa-xiang-jie/"/>
      <url>/2019/11/09/qin-jiu-shao-suan-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>#秦九韶算法<br>秦九韶算法是将一元n次多项式的求值问题转化为n个一次式的算法，比普通计算方式提高了一个数量级<br>普通算式</p><pre><code>a*x^i</code></pre><p>因为多次求幂，消耗了大量的计算时间</p><p>我们来分析一下秦九韶算法<br>例如：</p><pre><code>求1+x+2x^2+3x^3当x=2时的值</code></pre><p>首先我们将系数按照从大到小的方式提出来排列<br>如图所示，我们需要将系数这样排列计算<br>除了第一个值以外，其他的处置我们都在循环内取得，首先我们需要得到第一个值（注明，从第二个循环开始即使用sum结果进行乘积）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">*</span> x <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从第一个数开始每次乘了加上下一个值，然后继续使用结果乘以x加下一个值<br>#下面附上源码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> MAX 10  </span><span class="token comment" spellcheck="true">//只建议十项</span><span class="token keyword">int</span> <span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token keyword">double</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> sum<span class="token punctuation">;</span>    sum <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">*</span> x <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> sum<span class="token punctuation">;</span>    <span class="token keyword">double</span> arr<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入项数(注明,项数为最高项的幂+1):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入从小到大的系数，以空格隔开，没有的用0代替:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//必须反向存</span>        <span class="token punctuation">{</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入乘数x:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.9lf"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
