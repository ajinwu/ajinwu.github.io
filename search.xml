<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker高级</title>
      <link href="/2019/11/21/docker-gao-ji/"/>
      <url>/2019/11/21/docker-gao-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ol><li>docker隔离的东西(linux namespace+chroot)<ul><li>UTS(主机名和域名)</li><li>User(用户)</li><li>Mount挂载点(文件系统)</li><li>IPC(信号量, 消息队列, 共享队列)</li><li>Pid(进程编号)</li><li>Network(网络)</li></ul></li><li>Control Groups(控制组)</li><li>LinuX Container(LXC)的增强版是docker</li><li>镜像:静态=&gt;进程</li><li>容器:生命周期=&gt;程序  </li></ol><h1 id="docker挂载机制"><a href="#docker挂载机制" class="headerlink" title="docker挂载机制"></a>docker挂载机制</h1><ol><li>采用分层挂载机制, 最底层为bootfs, 其次为rootfs<ol><li>bootfs:用于系统引导的文件系统, 包括bootloader和kernel, 容器启动后会被卸载以节约内存资源</li><li>rootfs:位于bootfs之上, 表现为容器的根文件系统<ol><li>传统模式中, 系统启动之时.内核会挂载rootfs时会首先将其挂载为只读模式, 完整性自检完成后将其重新挂载为读写模式</li><li>docker中, rootfs有内核挂载为只读模式, 而后通过联合挂载技术额外挂载一个可写层</li></ol></li><li><blockquote><p>联合挂载的意思是自下往上依次挂载</p></blockquote></li><li><blockquote><p>每一个功能都是一个image(镜像)</p></blockquote></li><li>位于最下层的镜像称为父镜像, 最底层的称为基础镜像</li><li>最上层的为可写层, 其下的均为只读层</li></ol></li></ol><h1 id="docker-虚拟网络"><a href="#docker-虚拟网络" class="headerlink" title="docker 虚拟网络"></a>docker 虚拟网络</h1><ol><li>在宿主机上建立一个桥接网卡docker0, brctl show显示桥接网卡绑定方式</li><li>将docker0的网卡作为一条网线,一般在宿主机docker0上,一般在docker容器中</li><li>docker0是一个nat桥,iptables -t nat -vnL, 可以看见postrouting规则, 所有进入的流量, 只要不是从docker0桥出去的流量, 原地址来自172.17.0.0/16,无论到达任何主机, 都要进行地址伪装</li><li>docker四种网络模式<ol><li>none, 批处理文件所用, 挂载本地卷, docker run -it –name b1 –network none –rm busybox</li><li>bridge网络, nat桥接docker0,default模式, docker run -it –name b1 –network bridge –rm busybox</li><li>共享同一个网络, IPC, pid模式, 网络对于多个容器可见</li><li>桥接物理网卡</li></ol></li><li>创建网络命名空间并实现网卡互联<ol><li>ip netns add r1创建一个网络名称空间r1</li><li>ip netns list 列出名称空间的网卡</li><li>ip netns exec r1 ifconfig -a进入名称空间r1执行ifconfig命令</li><li>ip link add name veth1.1 type veth peer name veth1.2添加一块类型为veth的虚拟网卡veth1.1,另一半网卡名veth1.2</li><li>ip link show 显示两块网卡连接状态</li><li>ip link set dev veth1.2 netns r1,将veth1.2网卡迁移到r1名称空间</li><li>ip netns exec r1 ip link set dev veth1.2 name eth0进入r1名称空间,并设置设备veth1.2的网卡名为eth0</li><li>ip netns exec r1 ifconfig eth0 10.1.0.1/24 up,将eth0网卡开启并设置ip为10.1.0.1,24位掩码</li><li>ip link set dev veth1.1 netns r2,将veth1.1网卡迁移到r2名称空间</li><li>ip netns exec r2 ip link set dev veth1.1 name eth0,设置网卡名称</li><li>ip netns exec r2 ifconfig eth0 10.1.0.2/24 up, 设置ip并开启网卡</li><li>ip netns exec r1 ping 10.1.0.2测试网络连通性</li></ol></li></ol><h1 id="docker容器注入"><a href="#docker容器注入" class="headerlink" title="docker容器注入"></a>docker容器注入</h1><ol><li>注入容器中主机名, docker run -it –name b1 –network bridge -h test –rm busybox</li><li>注入dns服务器, docker run -it –name b1 –network bridge -h test –dns 114.114.114.114 –rm busybox</li><li>注入host, docker run -it –name b1 –network bridge -h test –dns 114.114.114.114 –add-host <a href="http://www.baidu.com:192.168.0.148" target="_blank" rel="noopener">www.baidu.com:192.168.0.148</a> –rm busybox</li></ol><h1 id="docker-端口映射"><a href="#docker-端口映射" class="headerlink" title="docker 端口映射"></a>docker 端口映射</h1><ol><li>docker run -d –name b1 –rm -p 80 ajinwu/httpd:v1.1</li><li>docker run -d –name b1 –rm -p 192.168.0.148::80 ajinwu/httpd:v1.1</li><li>docker run -d –name b1 –rm -p 192.168.0.148:80:80 ajinwu/httpd:v1.1</li><li>docker run -d –name b1 –rm -p 80:80 ajinwu/httpd:v1.1</li><li>自动暴露使用大写的p</li></ol><h1 id="联盟式容器"><a href="#联盟式容器" class="headerlink" title="联盟式容器"></a>联盟式容器</h1><ol><li>docker run -it –name b2 –network container:b1 –rm busybox, 共享b1的网络名称空间, 但是文件系统也是隔离的</li><li>docker run -it –name b1 –network host –rm busybox, 共享主机的网络</li><li>docker远程连接机器控制docker, 按照官方文档, 修改docker.service文件可行, ubuntu19.04修改daemon.json文件无效, 原因未知</li></ol><h1 id="自己创建网络"><a href="#自己创建网络" class="headerlink" title="自己创建网络"></a>自己创建网络</h1><ol><li>docker network create -d bridge –subnet “172.26.0.0/16” –gateway “172.26.0.1” mybr0, 创建网络mybr0,方式为桥接,子网为172.26.0.0, 网关如上</li></ol><h1 id="数据卷的必要性"><a href="#数据卷的必要性" class="headerlink" title="数据卷的必要性"></a>数据卷的必要性</h1><ol><li>关闭并重启容器, 其数据不受影响, 但是删除docker容器, 其更改会消失</li><li>存在的问题<ol><li>存储在联合文件系统中, 不易于宿主机访问</li><li>容器间数据共享不方便</li><li>删除数据数据会丢失</li></ol></li><li>解决方案:卷<ol><li>卷是容器上的一个或多个目录, 此类目录会绕过联合文件系统, 与宿主机上的某目录绑定关联</li></ol></li><li>docker run –name b1 -it -v /data busybox, docker自己管理的绑定卷, 使用inspect可以查看挂载地址</li><li>docker run –name b1 -it -v /home/ajin_w/docker/volumes:/data –rm busybox, 挂载本地卷存放数据, 不存在会默认创建, 双向创建</li><li>容器间共享数据:使用挂载卷, 两个容器使用同一个挂载卷</li><li>复制一个容器已存在的卷<ol><li>docker run –name infracon -it -v /home/ajin_w/docker/volumes/infracon:/data/web/html busybox, 创建一个基础容器, 可以不用交互式, 也可以不用启动, 但是不能删除, 只提供给其他容器复制</li><li>docker run –name nginx –network container:infracon –volumes-from infracon -it –rm busybox, 创建一个nginx容器, 继承infracon容器的网络, 存储卷也使用infracon相同的配置</li></ol></li></ol><h1 id="docker信息查询"><a href="#docker信息查询" class="headerlink" title="docker信息查询"></a>docker信息查询</h1><ol><li>docker inspect b1 -f , 使用json层级读取数据</li></ol><h1 id="dockerfile制作"><a href="#dockerfile制作" class="headerlink" title="dockerfile制作"></a>dockerfile制作</h1><ol><li>指令格式format<ol><li>comment, 注释信息</li><li>指令和指令参数</li></ol></li><li>指令本身不区分字符大小写, 约定俗称使用大写</li><li>docker运行自上而下</li><li>第一个非注释行一定是以from开头</li><li>dockerfile文件首字母一定要大写</li><li>打包文件一定要在本目录以及本目录之下</li><li>FROM格式, FROM <repository>[:tag] 或者FROM <repository>@<digest> digest为哈希码, 不会被冒名顶替</digest></repository></repository></li><li>COPY, 将本机的文件复制到镜像, 源文件一般为相对与dockerfile文件目录, 目标文件一般为镜像中的绝对路径<ol><li>复制目录目录本身不会被复制, 只会递归复制目录下的文件</li><li>必须以/结尾</li></ol></li><li>ADD, 语法和COPY相同, 可以加上url, 会自动下载文件, 本地打包文件会自动解压</li><li>WORKDIR, 制定工作目录</li><li>VOLUME, 指定挂载卷, 只能指定容器内的, 容器外只能使用默认的</li><li>EXPOSE, 为容器打开指定要监听的端口与外部通信, 在dockerfile中写入只是会作为待暴露的端口, 而不是直接暴露, 加上P会暴露</li><li>ENV <key>=<value> …value中含有空白字符等需要使用反斜杠转义, 或者引号转义, 反斜线也可以进行续行</value></key></li><li>RUN, 正常写linux操作命令, 必须是基础镜像有的命令, 在docker build的时候执行<ol><li>作为shell的子进程来运行, 以”/bin/bash -c”来运行, 此进程pid不为1, 不能接受unix信号, 因此, docker stop无法停止容器</li><li>RUN [“<executable>“, “param”]格式的命令不以”bash”运行, 因此shell常见操作不会进行(通配符))</executable></li><li>依赖shell特性可RUN[“bin/bash”, “-c”, “executable”, “param”]信号也不是1</li></ol></li><li>CMD, 类似与RUN指令, 定义一个镜像文件启动为容器时默认要运行的程序, 只能出现一个CMD, CMD指令可以被dockerfile命令选项覆盖<ol><li>CMD <commend> pid不为1,可以使用shell命令</commend></li><li>CMD[“executable”,”param”]创建的是pid为1的进程, 这里不能默认启动shell, 可以手动运行为shell子进程</li><li>CMD [“param”]结合entrypoint来运行</li></ol></li><li>ENTRYPOINT命令不会被覆盖, 也不允许被覆盖, 多余输入的命令会被当做参数传入, 可以在启动容器时修改entrypoint命令<ol><li>如果CMD和ENTRYPOINT同时使用, 则CMD的命令会被当做参数传入ENTRYPOINT</li></ol></li><li>docker参数-e, 设置环境变量</li><li>shell命令, exec顶替上一个进程, “$@”, 后面任意长度字段的作为参数, exec “$@”, 顶替当前进程, 然后将后面的命令传入当做下一个程序执行</li><li>HEALTHCHECK健康监测<ol><li>HEALTHCHECK –interval=duration(default:30s), 检测周期</li><li>–timeout=duration(default:30s)超时时间</li><li>–start-period=duration(default:0s), 容器启动多少秒开始检测</li><li>–retries=N (default:3), 检测次数</li><li>example===&gt; HEALTHCHECK –interval=5m –timeout=3s CMD curl -f <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> || exit 1</li></ol></li><li>ONBUILD触发器命令, 在别人使用你的镜像时会执行这个命令, 后门</li></ol><h1 id="docker-仓库"><a href="#docker-仓库" class="headerlink" title="docker 仓库"></a>docker 仓库</h1><ol><li>apt install docker-registry</li><li>insecure-registries</li><li>vmrare harbor</li></ol><h1 id="docker-资源限制"><a href="#docker-资源限制" class="headerlink" title="docker 资源限制"></a>docker 资源限制</h1><ol><li>linux 通过内核来管理资源调度, 使用内存计算算法来管理, oom-score最高的会被最先杀死, 重要应用应使用oom_obj来分配权重</li><li>内存限制<ol><li>–momery内存不应该大于主机内存</li><li>–momery-swap为交换空间, 不设置memory则无法设置此选项<ol><li>-m-s为正数S, m为正数M, 容器总空间为S, 其中ram为M, swap为(S-M), 如S=M, 则无可用swap资源</li><li>0, M, 相当于未设置swap(unset)</li><li>unset, M, 若主机弃用了swap, 容器可用swap为2*M</li><li>-1, M, 若主机弃用了swap, 容器可使用最大主机swap资源</li></ol></li><li>–oom-kill-disable, 禁止kill</li></ol></li><li>cpu限制<ol><li>默认可使用所有的cpu</li><li>cpu可压缩, 共享式cpu-shares共享, 按照比例切分, 不用的时候cpu可以尽可能共享给他人, 使用的时候按比例给他最大的, 然后检查其他进程cpu资源是否空闲, 空闲可继续使用</li><li>–cpus=1.5, 显示cpu最多使用几核, 可使用小数</li><li>–cpuset-cpus, 限制使用的cpu是哪几个, 不建议使用</li></ol></li><li>docker run –name stress -it –rm -m 256m lorel/docker-stress-ng stress –vm 2, 验证memory限制, docker stats显示详细信息</li><li>docker run –name stress -it –rm –cpus 2 lorel/docker-stress-ng stress –cpu 8, cpu压测</li><li>docker run –name stress -it –rm –cpu-shares 1024 lorel/docker-stress-ng stress –cpu 8, 共享式分配, 首先会占用完cpu, 然后再来一个容器会互相分配</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker初级</title>
      <link href="/2019/11/21/docker-chu-ji/"/>
      <url>/2019/11/21/docker-chu-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="获取docker镜像"><a href="#获取docker镜像" class="headerlink" title="获取docker镜像"></a>获取docker镜像</h1><ul><li>获取镜像<ul><li>docker pull ubuntu:18.10  下载镜像<ul><li>默认不填版本号会选最新版本的，即latest，默认使用官方镜像</li><li>非官方镜像下载 <blockquote><p>docker pull hub.c.163.com/public/centos:6.5</p></blockquote></li><li>pull 参数<ul><li>-a，    –all表示获取所有镜像，默认为否</li></ul></li></ul></li></ul></li></ul><pre><code>- 查看镜像    - docker images列出镜像        - images参数            - -a，    列出所有镜像            - -f ，   列出过滤的镜像，例如列出没有被使用的镜像                &gt;docker images -f dangling=true    - docker tag ubuntu:latest ajinwu:test给镜像起别名，类似于软链接    - docker inspect web列出web这个容器的详细信息(注意，并不是镜像名)        - -f参数            &gt;docker inspect -f {{".Networks"}} web  显示web容器的网络信息    - docker history ajinwu:test列出镜像的创建过程        &gt;docker history --no-trunc ajinwu:test  显示截断的信息- 搜寻镜像    - docker search [option] keyword        - -f    过滤输出内容            &gt; docker search -f=is-official=true nginx   查找镜像，官方给出的带有nginx的镜像        - --limit int 限制输出内容            &gt; docker search --limit=3 nginx         显示前三条结果- 清理镜像    - docker rmi ubuntu:18.10       删除镜像标签为18.10的ubuntu镜像    - -f强制删除，即使有容器依赖    - docker ps -a  列出本机用过的所有容器    - 先删除容器在删除镜像        &gt; docker rm [CONTAINER ID]  删除镜像        &gt; docker rmi -f ajinwu/commit_test1:latest  强制删除镜像        &gt; docker images prune -f 自动清除遗留文件层- 创建镜像    - docker commit -m "add a new file" -a "docker ajin" c57 ajinwu/commit_test     制作一个新镜像，信息为add  file，作者信息为docker  ajin，容器id为c57开头,仓库名为ajinwu/,镜像名为commit_test 的新镜像    - 还可以添加-p暂停容器的运行    - 可以使用openVZ提供的模板来创建镜像        - cat ubuntu-18.04-x86_64.tar.gz | docker import - ubuntu:18.04    - dockerfile构建镜像        - docker build -t="ajinwu/dockerfile" .     -t参数为镜像名，后面加上dockerfile的目录- 存出镜像和载入镜像    - 存出镜像 docker save -o ubuntu_commit.tar ajinwu/commit_test    - 载入镜像  docker load &lt; ubuntu_commit.tar    - 上传镜像        - 先修改标签，格式为用户ID/镜像名docker tag test:test ajinwu/test        - 上传  docker push ajinwu/test</code></pre><ul><li><p>操作容器</p><ul><li><p>创建容器</p><ul><li><p>docker create -it ajinwu:test创建一个容器不运行</p></li><li><p>docker run -it ajinwu:test /bin/bash 使用ajinwu:test镜像创建一个容器并开启交互式终端使用/bin/bash</p></li><li><p>docker run -p 8111:80 –name nginx -i -t ubuntu /bin/bash     创建一个容器名为nginx的容器，将本地的8111端口映射到容器的80端口，可使用容器的地址直接访问</p></li><li><p>常用参数说明</p><ul><li>-i    保持标准输入输出打开</li><li>-t    分配伪终端</li><li>-d    是否后台运行，默认为否</li><li>–net=”bridge”    开启桥接网络</li><li>–expose      暴露端口</li><li>-p映射端口 -p</li></ul></li><li><p>开启容器docker start 042  注意，只能使用id</p></li><li><p>docker run ubuntu /bin/echo “hello wolrd”</p><ul><li>检查本地是否有ubuntu镜像</li><li>利用镜像创建一个容器，并启动该容器</li><li>分配一个文件系统给容器，并在只读镜像层外面挂载一层可读写层</li><li>从宿主主机的配置的网桥接口中桥接一个虚拟接口到容器</li><li>从网桥的地址池配置一个ip给容器</li><li>执行用户指定的应用程序</li><li>执行完命令容器被自动终止</li></ul></li><li><p>查看容器输出</p><ul><li><blockquote><p>docker logs  -f -t  –tail 10 test       查看最后10条并持续输出显示时间</p></blockquote></li></ul></li></ul></li><li><p>停止容器</p><ul><li>docker run –name=ajin2 -it –rm ubuntu bash运行一个容器，命名为ajin2，交互式伪终端运行bash，运行结束后删除该容器</li><li>Ctrl +p    Ctrl+q 后台运行容器，不停止容器的退出</li><li>docker pause ajin2 暂停容器ajin2</li><li>docker stop ajin2 终止容器ajin2</li><li>docker ps 查看容器<ul><li>-l    查看正在运行的容器</li><li>-a    查看所有容器</li><li>-qa   只查看所有容器的id</li></ul></li><li>docker restart 042    重启容器</li></ul></li><li><p>进入容器</p><ul><li>docker attach 042  进入后台容器</li><li>docker exec -it 042 bash  推荐这种方式，在不影响运行应用的情况下开启一个新的bash</li></ul></li><li><p>docker rm -f 042      强行删除容器（不建议）</p></li><li><p>导入和导出容器</p><ul><li>导出容器<ul><li>docker export -o test_export.tar 4ac</li></ul></li><li>导入容器<ul><li>docker import test_export.tar - test/ubuntu:v11这命令我不知道为啥错了</li></ul></li></ul></li><li><p>查看容器</p><ul><li>docker top 4ac       查看运行中的容器进程</li><li>docker stats 4ac  类似与htop命令</li><li>docker inspect 4ac    查看容器信息</li></ul></li><li><p>其他容器命令</p><ul><li>复制文件docker cp dp_2.py 4ac:/tmp，复制本机的文件到容器的tmp下</li><li>反向赋值docker cp 4ac:/test.txt .</li><li>docker  diff 4ac     查看容器数据修改</li><li>docker container port d8  查看端口映射<h1 id="访问docker仓库"><a href="#访问docker仓库" class="headerlink" title="访问docker仓库"></a>访问docker仓库</h1></li></ul></li></ul></li><li><p>各大镜像仓库</p><ul><li>阿里云，网易云，腾讯云docker pull  url</li></ul></li><li><p>搭建本地私有仓库，大家自行学习</p></li></ul><h1 id="docker数据管理"><a href="#docker数据管理" class="headerlink" title="docker数据管理"></a>docker数据管理</h1><ul><li><p>数据卷</p><ul><li>docker volume create -d local test 会在宿主机/var/lib/docker/volumes下创建一个test数据卷</li><li>绑定数据卷<br>  docker run -it -p 80 –name=blog -v /home/ajin_w/blogbak:/home/ajin_w/blog ubuntu /bin/bash     此命令为开启一个名为blog的容器，-v参数为映射本地文件夹blogbak目录到容器blog下，映射目录相当于一个网络驱动器，容器内外的修改均会生效，可在映射结束的位置添加读写权限，例如ro</li></ul></li><li><p>数据容器</p><ul><li><p>数据容器的创建使得挂载该数据容器的容器间可以很方便的进行数据交换</p></li><li><p>创建数据容器</p><ul><li>docker run -it -v /dbdata –name dbdata ubuntu</li></ul></li><li><p>挂载数据容器</p><ul><li>docker run -it –volumes-from dbdata –name db1 ubuntu</li></ul></li><li><p>数据容器不需要保持在运行状态</p></li><li><p>删除数据卷必须在最后一个挂载他的容器显式使用docker rm -v命令来指定同时删除关联的容器</p></li><li><p>数据迁移</p><ul><li>docker run –volumes-from dbdata -v $(pwd):/backup –name worker ubuntu tar -cvf /backup/backup.tar /dbdata</li><li>以上命令解释：创建一个worker容器，挂载dbdata数据卷，使用-v参数挂载本地当前目录到worker的容器的backup目录，容器启动后，打包dbdata为容器的/backup/backup.tar，即宿主机的当前目录下的backup.tar      意思就是挂载两个数据卷，一个本地目录，一个数据卷或者数据容器，将容器内的数据卷打包到容器的backup目录，因为直接挂载数据卷在/目录下，在挂载一个目录，将/目录下的数据卷打包进backup就好，本地目录变成了backup</li></ul></li><li><p>数据恢复</p><ul><li>docker run -v /dbdata –name dbdata2 ubuntu /bin/bash </li><li>创建一个容器挂载dbdata数据卷，名为dbdata2</li><li>docker run –volumes-from dbdata2 -v $(pwd):/backup ubuntu tar xvf /backup/backup.tar </li><li>创建另一份容器挂载dbdata2和当前目录到/backup目录，将本地的目录解压</li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典和集合</title>
      <link href="/2019/11/12/zi-dian-he-ji-he/"/>
      <url>/2019/11/12/zi-dian-he-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="泛映射类型"><a href="#泛映射类型" class="headerlink" title="泛映射类型"></a>泛映射类型</h1><p>collection.abc 模块中有mapping和mutaleMapping这两个抽象基类, 往往为dict和其他类似的类型定义形式接口</p><p>非抽象映射类型一般不会直接继承抽象基类, 会直接对dict或者collection.userdict进行扩展</p><p>标准库里的所有映射类型都是利用dict来实现的, 因此只有可散列的数据类型才能用作这些键(只有键有要求, 值并无要求)</p><blockquote><p>可散列数据类型在这个对象的生命周期内, 其散列值不会改变, 同时还需要实现<strong>hash</strong>和<strong>eq</strong>方法才可进行比较</p></blockquote><blockquote><p>原子不可变类型(str, 数值, bytes)都是可散列类型, frozenset只能存放可散列类型, 因此他也是可散列类型, 元组中所有的元素都是可散列的, 元组才是可散列的</p></blockquote><h1 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h1><pre><code>{key: value for key, value in count.items}</code></pre><h1 id="键的映射方法"><a href="#键的映射方法" class="headerlink" title="键的映射方法"></a>键的映射方法</h1><p>要使用setdeafult来处理找不到的键r.setdeafult(key,[]), 这一句的意思是<code>if key is not in dict: dict[key] = []</code></p><h1 id="映射的弹性查询方法"><a href="#映射的弹性查询方法" class="headerlink" title="映射的弹性查询方法"></a>映射的弹性查询方法</h1><p>在某个键不存在时, 我们也想通过这个键读取一个默认值, 这样有两个方法, 1是使用defaultdict, 2是自己定义一个dict的子类实现<strong>missing</strong>方法</p><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>在设置默认值时, 要使用一个数据类型的构造方法,如<em>list</em>, 如果查找不到对应的记录, 会使用default_factory方法来设定一个值</p><h2 id="特殊的missing方法"><a href="#特殊的missing方法" class="headerlink" title="特殊的missing方法"></a>特殊的<strong>missing</strong>方法</h2><p>所有映射类型找不到键都会调用这个方法, 但是只对getitem有效, 对get和in没有影响</p><pre class="line-numbers language-python"><code class="language-python">l<span class="token punctuation">.</span>__getitem__<span class="token punctuation">(</span>key<span class="token punctuation">)</span>l<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">,</span>default<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种处理是不一样的, 第一种会报错, 第二中会是默认值或者返回为None</p><p>在找不到键的时候使用<strong>missing</strong>方法, 可以做一些特殊的操作</p><p>如果要使用key in dict方法, 就必须要实现<strong>contains</strong>方法, 因为找不到也会到<strong>missing</strong>里面寻找, 产生无限递归, 而使用in操作时, 会产生一个视图, 这种操作查找元素很快</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">strkey</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 再找不到键的时候会在这里进行字符装换</span>    <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>key<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> KeyError<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">[</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> default <span class="token operator">=</span> None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">[</span>key<span class="token punctuation">]</span>        <span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>            <span class="token keyword">return</span> default    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">or</span> str<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>d <span class="token operator">=</span> strkey<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">"2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"None"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 只对get有效而不对__getitem__无效</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h1><p>有序字典collections.OrderedDict 排序</p><pre class="line-numbers language-python"><code class="language-python">d <span class="token operator">=</span> collections<span class="token punctuation">.</span>OrderedDict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> s<span class="token punctuation">:</span>    <span class="token keyword">if</span> i <span class="token keyword">in</span> d<span class="token punctuation">:</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>d <span class="token operator">=</span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token keyword">lambda</span> d<span class="token punctuation">:</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> reverse <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">## 返回列表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>collections.chainMap()做模板之用, 适合嵌套数据</p><p>UserDict并不是dict的一个子类, 继承于dict更推荐使用UserDict, 前者会在有些实现上走一些捷径, 有些方法必须要重写</p><p>UserDict由一个data属性, 实际上是存储的dict里面的属性</p><p>UserDict 继承的是mutableMapping</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> UserDict<span class="token keyword">class</span> <span class="token class-name">user_dict</span><span class="token punctuation">(</span>UserDict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>key<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> KeyError<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">[</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> str<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>data <span class="token comment" spellcheck="true"># data是一个dict实例</span>    <span class="token keyword">def</span> <span class="token function">__setitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>str<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> itemd <span class="token operator">=</span> user_dict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">"2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"None"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">in</span> d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h1><p>types模块中由一个封装类名叫做MapingProxyType, 使用此类包装的数据是动态的, 无法做改变, 需要修改原数据才可以改变包装后的数据</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> types <span class="token keyword">import</span> MappingProxyTyped <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token string">"A"</span><span class="token punctuation">}</span>d_proxy <span class="token operator">=</span> MappingProxyType<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>d<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"x"</span><span class="token keyword">print</span><span class="token punctuation">(</span>d_proxy<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>d_proxy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"b"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合内的元素必须是可散列的, set本身是不可散列的, 但是frozenset可以散列</p><h2 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h2><p>a = {1}</p><blockquote><p>如果是空集, 必须使用无参构造方法<br>对于a = set([1,2]) 和a = {1, 2}来说, 后者的速度会更快一些</p></blockquote><p>frozenset没有特殊字面量说法, 只能采用构造方法</p><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>&amp; 交集</p><p>| 并集</p><p>- 差集</p><p>^ 对称差集 (A U B) - (A n B)</p><blockquote><p>在集合方法discard是移除元素, 不存在不会报错</p></blockquote><h1 id="dict和set的背后"><a href="#dict和set的背后" class="headerlink" title="dict和set的背后"></a>dict和set的背后</h1><p>dict和set搜索都比list快, 是由于list背后没有散列表来支持in运算, 因此每次都会扫描整个列表</p><h2 id="字典中的散列表"><a href="#字典中的散列表" class="headerlink" title="字典中的散列表"></a>字典中的散列表</h2><p>散列表是一个稀疏数组, 在dict的散列表中, 每个键值对都占有表元, 一个是键的引用, 一个是值得引用, 因为所有的表元的大小一致, 所以可以通过偏移量来读取, python会保证1/3是空的, 超过会自动复制到更大的空间</p><p>在插入新值时, python会按照散列表的拥堵程度来决定是否重新分配内存, 为了减小散列冲突, 散列值位数和索引位数也会增加</p><h2 id="dict的实现和后果"><a href="#dict的实现和后果" class="headerlink" title="dict的实现和后果"></a>dict的实现和后果</h2><p>散列需要满足的要求</p><ol><li>支持hash函数, 并且hash计算不变</li><li>支持<strong>eq</strong>来判等</li><li>若a==b, 则hash(a) == hash(b)</li></ol><p>所有用户自定义的对象都是可散列的, 因为散列值是id()来获取</p><blockquote><p>如果实现了<strong>eq</strong>方法, 并且希望是可散列的, 就必须实现<strong>hash</strong>方法, 并保证相等</p></blockquote><p>字典在内存上的开销巨大</p><p>字典的键查询很快, 空间换时间</p><p>键的次序取决于添加顺序</p><p>往字典添加新键可能会改变已有的顺序, 因为每一次添加新键都有可能使字典扩容, 造成散列冲突, 导致打乱原有的顺序</p><blockquote><p>keys, items, values返回的都是字典视图</p></blockquote><h2 id="set的实现以及后果"><a href="#set的实现以及后果" class="headerlink" title="set的实现以及后果"></a>set的实现以及后果</h2><ol><li>集合元素必须是可散列的</li><li>集合很消耗内存</li><li>in很高效</li><li>元素的次序决定于添加的次序</li><li>添加可能会改变次序</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>dict, defaultdict, userdict, orderedDict, ChainMap, Counter, UserDict</p><p>setdefault</p><p><strong>missing</strong></p><p>MappingProxyType</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列构成的数组</title>
      <link href="/2019/11/12/xu-lie-gou-cheng-de-shu-zu/"/>
      <url>/2019/11/12/xu-lie-gou-cheng-de-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="内置序列类型"><a href="#内置序列类型" class="headerlink" title="内置序列类型"></a>内置序列类型</h1><ol><li><p>python标准库使用c实现了丰富的序列类型</p><ol><li>容器序列:list, tuple, collection.deque这些序列能存放不同类型的数据</li><li>扁平序列:str, bytes, bytesarray, memoryview和array.array, 这种序列只能容纳一种类型<blockquote><p>容器序列存放的是他们所包含的对象的引用, 扁平序列存放的是值, 换句话来说, 扁平序列是一段连续的内存空间</p></blockquote></li><li>可变序列:list, bytesarray, array.array, collections.deque, memoryview</li><li>不可变序列: tuple, str和bytes</li></ol></li><li><p>列表推导和生成器表达式</p><ol><li>列表推导式并不一定比map慢</li><li>在初始化序列类型时, 使用生成器表达式是更好的选择, 生成器表达式遵守了迭代器协议, 可以逐个产生元素, 列表推导式是先建立一个完整的列表, 然后再把这个列表传递到某个构造函数里面, 不够节省内存.</li><li>生成器表达式每次for循环才会生成一个组合, 所以会省掉笛卡尔积的for循环开销</li></ol></li><li><p>元组不仅仅是不可变的列表</p><ol><li>元组和记录: 元组其实是对数据的记录, 元组的每个元素都存放了一个字段的数据, for循环可以自动拆包元组, 迭代过程中, print可以接受一个元组作为参数输入, 拆包让元组当做记录来使用.</li><li>元组拆包可以应用到任何可迭代对象上, 但是可迭代对象的元素必须要跟接受这些元素的元组的空挡数已知</li><li>拆包中对于不定长参数使用*获取, 可以应用与任何位置, 自动对应长度</li><li>python3中函数参数不接受元组型(不接受所有迭代序列, 例如(a, b), [a, b])</li></ol></li><li><p>具名元组</p><ol><li>创建一个具名元组需要两个参数, 一个是类名, 另一个是类的各个字段的名字, 后者可以由数个字符串组成的可迭代对象, 或者是有空格分割开的字段名组成的字符串</li><li>存放在对应字段里的数据要以一串参数的形式传入到构造函数中, 元组的构造函数只接受单一的可迭代对象</li><li>可以通过字段名获取对应位置的字段信息</li><li>具名元组里面可以叠加具名元组, 实现高级数据结构</li><li>具名元组相当于一个类</li><li>重复拼接方法<strong>mul</strong>(n), 生成一个新的对象</li></ol></li><li><p>切片</p><ol><li>切片和区间操作会忽略最后一个元素, 符合以0为开始的风格</li><li>python的内置序列类型都是一维的, 他们只支持单一索引</li><li>如果把切片放在赋值语句的左边, 或者把他作为del操作的对象, 我们就可以对序列进行嫁接, 切除, 或者就地修改等操作</li><li>如果赋值的对象是一个切片, 那么右值必须是一个可迭代序列</li></ol></li><li><p>对序列使用+*</p><ol><li>序列支持+*, 在拼接的过程中, 两个被操作的序列都不回被修改, python会新建一个包含同类型的序列作为拼接的结果</li><li>不要使用[[“_”]] * 3这种语法</li><li>序列增量赋值要实现<strong>iadd</strong>方法, 如果没有实现, 解释器会自动转向<strong>add</strong>方法</li><li>在元组中, 有可变序列时, 需要append而不是直接+=</li></ol></li><li><p>list.sort和内置函数sorted</p><ol><li>list.sort()方法会原地赋值, 返回值为None, 并不会产生新的对象</li><li>sorted可以接受任何可迭代的对象作为参数, 甚至不可变序列或生成器</li><li>reverse和key作为可选关键字, key用于序列中的每一个元素, 作为排序的对比关键字, 比如key=len, 进行基于字符串长度的排序</li></ol></li><li><p>用bisect来管理已排序的序列</p><ol><li>bisect.insort(list, item), 讲一个新的item放入list, 保持有序的同时插入, 函数有返回值, 返回值为在新序列中的位置</li><li>bisect中的方法都有left和right可选, 区别在于放在左边还是右边</li></ol></li><li><p>当列表不是首选时</p><ol><li>数组<ol><li>数组支持所有跟可变序列有关的操作, 还提供从文件读取和存入文件更快的方法, frombytes和tofile方法</li><li>数组只能存放限定类型的数据</li></ol></li><li>内存视图, 看不懂</li><li>双向队列<ol><li>maxlen是可选参数, 固定后不可改变</li><li>对满队列添加元素时会自动删除左端或者右端元素</li><li>deque原子操作, 是线程安全的</li></ol></li></ol></li><li><p>总结</p><ol><li>序列类型分为可变序列和不可变序列, 或者说是扁平序列和容器序列, 扁平序列只能保存原子操作, 容器序列可以保存其他序列, 容器:有些对象包含其他对象的引用.</li><li>对于重复拼接在遇到不可变序列时, 会产生新的序列, 如果遇到可变的会就地修改</li><li>元组存放没有关系的数据</li><li>sorted和list.sort背后的算法是timsort自适应算法, 会根据原始数据的特点交替使用插入排序和归并排序</li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机概论</title>
      <link href="/2019/11/11/ji-suan-ji-gai-lun/"/>
      <url>/2019/11/11/ji-suan-ji-gai-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="数据表示方式"><a href="#数据表示方式" class="headerlink" title="数据表示方式"></a>数据表示方式</h1><h2 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h2><p>在计算机中, 所有的数据都是二进制</p><h2 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h2><p>常用的英文编码都是ascii, 每个符号(英文, 数字, 或符号等)都会占用一个bytes, 总共会有2^8中变化, 目前所使用的Unicode编码系统解决了这个问题</p><h1 id="软件程序运作"><a href="#软件程序运作" class="headerlink" title="软件程序运作"></a>软件程序运作</h1><p>目前计算机都将软件分为两大类, 系统软件和应用程序</p><h2 id="机器程序与编译程序"><a href="#机器程序与编译程序" class="headerlink" title="机器程序与编译程序"></a>机器程序与编译程序</h2><p>cpu具有微指令集, 让cpu帮忙工作必须要参考微指令集, 这个流程包括一下方面</p><ol><li>需要了解机器语言</li><li>需要了解所有硬件的相关功能函数</li><li>程序具有不可移植性, 每个cpu都有独特的微指令集, 同样, 每个硬件都有相关功能函数</li><li>程序具有专一性, 要面对相关硬件来编写</li></ol><p>编译程序做了将高级语言转化为机器语言的功能来完成程序的运行</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统也是一组程序, 这组程序主要来管理计算机以及相关硬件</p><p>操作系统放置在内存中的受保护区域, 开机后一直常驻与内存</p><h2 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h2><p>操作系统除了核心程序之外, 通常会提供开发接口, 就是sc, 开发工程师只需要遵循sc参数开发软件</p><ol><li>操作系统的核心层直接参看硬件规格, 所以同一个操作系统不能再不同硬件平台运作</li><li>操作系统只管理硬件资源, 包括cpu, 内存, 输入输出装置及文件系统文件</li><li>应用程序开发参考操作系统提供开发接口</li></ol><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li>system call interface</li><li>程序管理, 内核控制分配cpu资源   </li><li>内存管理</li><li>文件系统管理</li><li>硬件驱动</li></ol><h2 id="操作系统与驱动程序"><a href="#操作系统与驱动程序" class="headerlink" title="操作系统与驱动程序"></a>操作系统与驱动程序</h2><p>操作系统会提供开发接口给硬件开发商, 根据接口设计驱动程序</p><ol><li>操作系统必须能够驱动硬件, 应用程序才能使用该硬件</li><li>一般来说, 操作系统会提供开发接口</li><li>使用新硬件, 必须安装驱动程序</li><li>驱动程序由开发者提供, 与操作系统开发者无关</li></ol><h1 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h1><p>应用程序是参考操作系统开发接口开发的软件, 达到某些计算机功能</p><p>应用程序与操作系统有关系</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>计算机定义: 接受用户输入指令与数据, 经过中央处理器的算逻单元运算后, 产生或存储有用的信息</li><li>计算机五大单元: 输入输出单元, 控制单元, 算逻单元, 记忆单元, cpu占有控制, 算逻单元, 记忆单元又包含主存储器与辅助内存</li><li>数据搂入流出是cpu发出的控制指令, cpu处理的数据来着主存储器</li><li>cpu设计理念分为: 精简指令集与复杂指令集</li><li>新的cpu设计中已经将北桥的内存控制芯片整合到cpu中, 而cpu与主存储器, 显示适配器沟通的总线是系统总线, 南桥是I/O总线</li><li>cpu每次能够处理的数据量称为字组大小, 目前有32/64位区分</li><li>一个byte=8bits</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机系统/linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统/linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据模型</title>
      <link href="/2019/11/09/python-shu-ju-mo-xing/"/>
      <url>/2019/11/09/python-shu-ju-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="python-风格"><a href="#python-风格" class="headerlink" title="python 风格"></a>python 风格</h1><ol><li><p>特殊风格</p><ol><li><strong>getitem</strong>方法是实现列表进行选取的方法, 并且还支持切片语法, 并且只要实现了这个方法, 这个对象就变成了可迭代的对象, 实现方式, 返回一个本对象的一个结点</li><li>in运算符是contains方法实现的, 如果没有实现这个方法, 那么in运算符就是按顺序进行一次迭代搜索</li></ol></li><li><p>如何使用特殊风格<br><br>特殊方法的存在是为了被解释器调用的, 不需要自己调用, 也就是你需要len(object)而不是object.len(), 如果是py内置的类型, 如list, str等, cpython的<strong>len</strong>会直接返回pyvarobject中的ob_size属性, pyvarobject是表示内存中长度可变的内置对象的C语言结构体. 速度会快很多.<br>很多时候, 特殊方法的调用是隐式的, 例如for i in xx, 背后使用的是iter(xx)函数, 而iter实现是xx.<strong>iter</strong>()方法, 通过内置的函数, 如len, str来使用特殊方法是最好的选择, 这些内置函数会调用特殊方法, 且对于内置类来说, 他们的速度会更快.</p><ol><li><p>模拟数值类型</p><ol><li>如果一个对象可以获取 obj 的字符串表示, 他需要实现<strong>repr</strong>或者<strong>str</strong>方法, + 为<strong>add</strong>方法, * 为<strong>mul</strong>方法</li></ol></li><li><p>字符串表示形式<br></p><ol><li><strong>repr</strong> 用于生成正式的表示。可以认为是将对象序列化的方法，原则上要能反序列化回对象。</li><li><strong>str</strong> 用于生成非正式的表示。format 或 print 会调用它来为用户生成“友好的”显示。<blockquote><p>str 与repr对比, repr 并不强制生成的字符串可以反序列化</p></blockquote></li></ol><blockquote><p>1.repr 生成的字符串一般用于 debug，所以一般生成的字符串一般要包含尽可能多的信息，信息要尽可能明确(如默认实现里用 ID 区分开两个不同的对象)。</p></blockquote><blockquote><p>2.不要使用 repr 和 eval 来做序列化/反序列化，用 pickle 或 json。<br>3.obj.<strong>str</strong>() 方法会在 print(obj) 或 ‘{}’.format(obj) 时被调用，一般是为了给用户提供 “友好的” 显示，所以 <strong>str</strong> 不像<strong>repr</strong> 那样原则上对返回值有约定，想怎么搞都行。</p></blockquote><blockquote><p>4.另外，<strong>str</strong> 的默认实现是直接调用了 <strong>repr</strong> 方法。因此如果覆盖了 <strong>repr</strong> 方法，<strong>str</strong> 的结果也会随之改变。</p></blockquote><blockquote><p>5.如果只想实现其中的一个方法, <strong>repr</strong>是最好的选择, 如果一个对象没有str方法而需要使用时, 会使用repr代替</p><ol start="3"><li>自定义的布尔值</li><li>默认情况下, 我们自定义的类总是被认为是真的, 除非是对<strong>bool</strong> 或者<strong>len</strong>做了实现, 如果不存在<strong>bool</strong>, 则会调用<strong>len</strong>方法</li></ol></blockquote></li><li><p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html" target="_blank" rel="noopener">特殊方法对照表</a></p></li></ol></li></ol><p>本章代码<br><a href="/file/getitem_len.py">getitem_len</a><br><a href="/file/vector.py">vector</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秦九韶算法详解</title>
      <link href="/2019/11/09/qin-jiu-shao-suan-fa-xiang-jie/"/>
      <url>/2019/11/09/qin-jiu-shao-suan-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>#秦九韶算法<br>秦九韶算法是将一元n次多项式的求值问题转化为n个一次式的算法，比普通计算方式提高了一个数量级<br>普通算式</p><pre><code>a*x^i</code></pre><p>因为多次求幂，消耗了大量的计算时间</p><p>我们来分析一下秦九韶算法<br>例如：</p><pre><code>求1+x+2x^2+3x^3当x=2时的值</code></pre><p>首先我们将系数按照从大到小的方式提出来排列<br>如图所示，我们需要将系数这样排列计算<br>除了第一个值以外，其他的处置我们都在循环内取得，首先我们需要得到第一个值（注明，从第二个循环开始即使用sum结果进行乘积）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">*</span> x <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从第一个数开始每次乘了加上下一个值，然后继续使用结果乘以x加下一个值<br>#下面附上源码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> MAX 10  </span><span class="token comment" spellcheck="true">//只建议十项</span><span class="token keyword">int</span> <span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token keyword">double</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> sum<span class="token punctuation">;</span>    sum <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">*</span> x <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> sum<span class="token punctuation">;</span>    <span class="token keyword">double</span> arr<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入项数(注明,项数为最高项的幂+1):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入从小到大的系数，以空格隔开，没有的用0代替:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//必须反向存</span>        <span class="token punctuation">{</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入乘数x:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">algorithm</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.9lf"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
